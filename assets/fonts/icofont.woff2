ts);
                if (state.nonLocalJumps & 8) {
                    var returnStatement = void 0;
                    if (outerState) {
                        outerState.nonLocalJumps |= 8;
                        returnStatement = factory.createReturnStatement(loopResultName);
                    }
                    else {
                        returnStatement = factory.createReturnStatement(factory.createPropertyAccessExpression(loopResultName, "value"));
                    }
                    statements.push(factory.createIfStatement(factory.createTypeCheck(loopResultName, "object"), returnStatement));
                }
                if (state.nonLocalJumps & 2) {
                    statements.push(factory.createIfStatement(factory.createStrictEquality(loopResultName, factory.createStringLiteral("break")), factory.createBreakStatement()));
                }
                if (state.labeledNonLocalBreaks || state.labeledNonLocalContinues) {
                    var caseClauses = [];
                    processLabeledJumps(state.labeledNonLocalBreaks, true, loopResultName, outerState, caseClauses);
                    processLabeledJumps(state.labeledNonLocalContinues, false, loopResultName, outerState, caseClauses);
                    statements.push(factory.createSwitchStatement(loopResultName, factory.createCaseBlock(caseClauses)));
                }
            }
            return statements;
        }
        function setLabeledJump(state, isBreak, labelText, labelMarker) {
            if (isBreak) {
                if (!state.labeledNonLocalBreaks) {
                    state.labeledNonLocalBreaks = new ts.Map();
                }
                state.labeledNonLocalBreaks.set(labelText, labelMarker);
            }
            else {
                if (!state.labeledNonLocalContinues) {
                    state.labeledNonLocalContinues = new ts.Map();
                }
                state.labeledNonLocalContinues.set(labelText, labelMarker);
            }
        }
        function processLabeledJumps(table, isBreak, loopResultName, outerLoop, caseClauses) {
            if (!table) {
                return;
            }
            table.forEach(function (labelMarker, labelText) {
                var statements = [];
                if (!outerLoop || (outerLoop.labels && outerLoop.labels.get(labelText))) {
                    var label = factory.createIdentifier(labelText);
                    statements.push(isBreak ? factory.createBreakStatement(label) : factory.createContinueStatement(label));
                }
                else {
                    setLabeledJump(outerLoop, isBreak, labelText, labelMarker);
                    statements.push(factory.createReturnStatement(loopResultName));
                }
                caseClauses.push(factory.createCaseClause(factory.createStringLiteral(labelMarker), statements));
            });
        }
        function processLoopVariableDeclaration(container, decl, loopParameters, loopOutParameters, hasCapturedBindingsInForHead) {
            var name = decl.name;
            if (ts.isBindingPattern(name)) {
                for (var _i = 0, _a = name.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (!ts.isOmittedExpression(element)) {
                        processLoopVariableDeclaration(container, element, loopParameters, loopOutParameters, hasCapturedBindingsInForHead);
                    }
                }
            }
            else {
                loopParameters.push(factory.createParameterDeclaration(undefined, undefined, name));
                var checkFlags = resolver.getNodeCheckFlags(decl);
                if (checkFlags & 4194304 || hasCapturedBindingsInForHead) {
                    var outParamName = factory.createUniqueName("out_" + ts.idText(name));
                    var flags = 0;
                    if (checkFlags & 4194304) {
                        flags |= 1;
                    }
                    if (ts.isForStatement(container)) {
                        if (container.initializer && resolver.isBindingCapturedByNode(container.initializer, decl)) {
                            flags |= 2;
                        }
                        if (container.condition && resolver.isBindingCapturedByNode(container.condition, decl) ||
                            container.incrementor && resolver.isBindingCapturedByNode(container.incrementor, decl)) {
                            flags |= 1;
                        }
                    }
                    loopOutParameters.push({ flags: flags, originalName: name, outParamName: outParamName });
                }
            }
        }
        function addObjectLiteralMembers(expressions, node, receiver, start) {
            var properties = node.properties;
            var numProperties = properties.length;
            for (var i = start; i < numProperties; i++) {
                var property = properties[i];
                switch (property.kind) {
                    case 174:
                    case 175:
                        var accessors = ts.getAllAccessorDeclarations(node.properties, property);
                        if (property === accessors.firstAccessor) {
                            expressions.push(transformAccessorsToExpression(receiver, accessors, node, !!node.multiLine));
                        }
                        break;
                    case 171:
                        expressions.push(transformObjectLiteralMethodDeclarationToExpression(property, receiver, node, node.multiLine));
                        break;
                    case 299:
                        expressions.push(transformPropertyAssignmentToExpression(property, receiver, node.multiLine));
                        break;
                    case 300:
                        expressions.push(transformShorthandPropertyAssignmentToExpression(property, receiver, node.multiLine));
                        break;
                    default:
                        ts.Debug.failBadSyntaxKind(node);
                        break;
                }
            }
        }
        function transformPropertyAssignmentToExpression(property, receiver, startsOnNewLine) {
            var expression = factory.createAssignment(ts.createMemberAccessForPropertyName(factory, receiver, ts.visitNode(property.name, visitor, ts.isPropertyName)), ts.visitNode(property.initializer, visitor, ts.isExpression));
            ts.setTextRange(expression, property);
            if (startsOnNewLine) {
                ts.startOnNewLine(expression);
            }
            return expression;
        }
        function transformShorthandPropertyAssignmentToExpression(property, receiver, startsOnNewLine) {
            var expression = factory.createAssignment(ts.createMemberAccessForPropertyName(factory, receiver, ts.visitNode(property.name, visitor, ts.isPropertyName)), factory.cloneNode(property.name));
            ts.setTextRange(expression, property);
            if (startsOnNewLine) {
                ts.startOnNewLine(expression);
            }
            return expression;
        }
        function transformObjectLiteralMethodDeclarationToExpression(method, receiver, container, startsOnNewLine) {
            var expression = factory.createAssignment(ts.createMemberAccessForPropertyName(factory, receiver, ts.visitNode(method.name, visitor, ts.isPropertyName)), transformFunctionLikeToExpression(method, method, undefined, container));
            ts.setTextRange(expression, method);
            if (startsOnNewLine) {
                ts.startOnNewLine(expression);
            }
            return expression;
        }
        function visitCatchClause(node) {
            var ancestorFacts = enterSubtree(7104, 0);
            var updated;
            ts.Debug.assert(!!node.variableDeclaration, "Catch clause variable should always be present when downleveling ES2015.");
            if (ts.isBindingPattern(node.variableDeclaration.name)) {
                var temp = factory.createTempVariable(undefined);
                var newVariableDeclaration = factory.createVariableDeclaration(temp);
                ts.setTextRange(newVariableDeclaration, node.variableDeclaration);
                var vars = ts.flattenDestructuringBinding(node.variableDeclaration, visitor, context, 0, temp);
                var list = factory.createVariableDeclarationList(vars);
                ts.setTextRange(list, node.variableDeclaration);
                var destructure = factory.createVariableStatement(undefined, list);
                updated = factory.updateCatchClause(node, newVariableDeclaration, addStatementToStartOfBlock(node.block, destructure));
            }
            else {
                updated = ts.visitEachChild(node, visitor, context);
            }
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function addStatementToStartOfBlock(block, statement) {
            var transformedStatements = ts.visitNodes(block.statements, visitor, ts.isStatement);
            return factory.updateBlock(block, __spreadArray([statement], transformedStatements, true));
        }
        function visitMethodDeclaration(node) {
            ts.Debug.assert(!ts.isComputedPropertyName(node.name));
            var functionExpression = transformFunctionLikeToExpression(node, ts.moveRangePos(node, -1), undefined, undefined);
            ts.setEmitFlags(functionExpression, 512 | ts.getEmitFlags(functionExpression));
            return ts.setTextRange(factory.createPropertyAssignment(node.name, functionExpression), node);
        }
        function visitAccessorDeclaration(node) {
            ts.Debug.assert(!ts.isComputedPropertyName(node.name));
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(32670, 65);
            var updated;
            var parameters = ts.visitParameterList(node.parameters, visitor, context);
            var body = transformFunctionBody(node);
            if (node.kind === 174) {
                updated = factory.updateGetAccessorDeclaration(node, node.modifiers, node.name, parameters, node.type, body);
            }
            else {
                updated = factory.updateSetAccessorDeclaration(node, node.modifiers, node.name, parameters, body);
            }
            exitSubtree(ancestorFacts, 98304, 0);
            convertedLoopState = savedConvertedLoopState;
            return updated;
        }
        function visitShorthandPropertyAssignment(node) {
            return ts.setTextRange(factory.createPropertyAssignment(node.name, visitIdentifier(factory.cloneNode(node.name))), node);
        }
        function visitComputedPropertyName(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        function visitYieldExpression(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        function visitArrayLiteralExpression(node) {
            if (ts.some(node.elements, ts.isSpreadElement)) {
                return transformAndSpreadElements(node.elements, false, !!node.multiLine, !!node.elements.hasTrailingComma);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCallExpression(node) {
            if (ts.getEmitFlags(node) & 33554432) {
                return visitTypeScriptClassWrapper(node);
            }
            var expression = ts.skipOuterExpressions(node.expression);
            if (expression.kind === 106 ||
                ts.isSuperProperty(expression) ||
                ts.some(node.arguments, ts.isSpreadElement)) {
                return visitCallExpressionWithPotentialCapturedThisAssignment(node, true);
            }
            return factory.updateCallExpression(node, ts.visitNode(node.expression, callExpressionVisitor, ts.isExpression), undefined, ts.visitNodes(node.arguments, visitor, ts.isExpression));
        }
        function visitTypeScriptClassWrapper(node) {
            var body = ts.cast(ts.cast(ts.skipOuterExpressions(node.expression), ts.isArrowFunction).body, ts.isBlock);
            var isVariableStatementWithInitializer = function (stmt) { return ts.isVariableStatement(stmt) && !!ts.first(stmt.declarationList.declarations).initializer; };
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var bodyStatements = ts.visitNodes(body.statements, classWrapperStatementVisitor, ts.isStatement);
            convertedLoopState = savedConvertedLoopState;
            var classStatements = ts.filter(bodyStatements, isVariableStatementWithInitializer);
            var remainingStatements = ts.filter(bodyStatements, function (stmt) { return !isVariableStatementWithInitializer(stmt); });
            var varStatement = ts.cast(ts.first(classStatements), ts.isVariableStatement);
            var variable = varStatement.declarationList.declarations[0];
            var initializer = ts.skipOuterExpressions(variable.initializer);
            var aliasAssignment = ts.tryCast(initializer, ts.isAssignmentExpression);
            if (!aliasAssignment && ts.isBinaryExpression(initializer) && initializer.operatorToken.kind === 27) {
                aliasAssignment = ts.tryCast(initializer.left, ts.isAssignmentExpression);
            }
            var call = ts.cast(aliasAssignment ? ts.skipOuterExpressions(aliasAssignment.right) : initializer, ts.isCallExpression);
            var func = ts.cast(ts.skipOuterExpressions(call.expression), ts.isFunctionExpression);
            var funcStatements = func.body.statements;
            var classBodyStart = 0;
            var classBodyEnd = -1;
            var statements = [];
            if (aliasAssignment) {
                var extendsCall = ts.tryCast(funcStatements[classBodyStart], ts.isExpressionStatement);
                if (extendsCall) {
                    statements.push(extendsCall);
                    classBodyStart++;
                }
                statements.push(funcStatements[classBodyStart]);
                classBodyStart++;
                statements.push(factory.createExpressionStatement(factory.createAssignment(aliasAssignment.left, ts.cast(variable.name, ts.isIdentifier))));
            }
            while (!ts.isReturnStatement(ts.elementAt(funcStatements, classBodyEnd))) {
                classBodyEnd--;
            }
            ts.addRange(statements, funcStatements, classBodyStart, classBodyEnd);
            if (classBodyEnd < -1) {
                ts.addRange(statements, funcStatements, classBodyEnd + 1);
            }
            ts.addRange(statements, remainingStatements);
            ts.addRange(statements, classStatements, 1);
            return factory.restoreOuterExpressions(node.expression, factory.restoreOuterExpressions(variable.initializer, factory.restoreOuterExpressions(aliasAssignment && aliasAssignment.right, factory.updateCallExpression(call, factory.restoreOuterExpressions(call.expression, factory.updateFunctionExpression(func, undefined, undefined, undefined, undefined, func.parameters, undefined, factory.updateBlock(func.body, statements))), undefined, call.arguments))));
        }
        function visitSuperCallInBody(node) {
            return visitCallExpressionWithPotentialCapturedThisAssignment(node, false);
        }
        function visitCallExpressionWithPotentialCapturedThisAssignment(node, assignToCapturedThis) {
            if (node.transformFlags & 32768 ||
                node.expression.kind === 106 ||
                ts.isSuperProperty(ts.skipOuterExpressions(node.expression))) {
                var _a = factory.createCallBinding(node.expression, hoistVariableDeclaration), target = _a.target, thisArg = _a.thisArg;
                if (node.expression.kind === 106) {
                    ts.setEmitFlags(thisArg, 4);
                }
                var resultingCall = void 0;
                if (node.transformFlags & 32768) {
                    resultingCall = factory.createFunctionApplyCall(ts.visitNode(target, callExpressionVisitor, ts.isExpression), node.expression.kind === 106 ? thisArg : ts.visitNode(thisArg, visitor, ts.isExpression), transformAndSpreadElements(node.arguments, true, false, false));
                }
                else {
                    resultingCall = ts.setTextRange(factory.createFunctionCallCall(ts.visitNode(target, callExpressionVisitor, ts.isExpression), node.expression.kind === 106 ? thisArg : ts.visitNode(thisArg, visitor, ts.isExpression), ts.visitNodes(node.arguments, visitor, ts.isExpression)), node);
                }
                if (node.expression.kind === 106) {
                    var initializer = factory.createLogicalOr(resultingCall, createActualThis());
                    resultingCall = assignToCapturedThis
                        ? factory.createAssignment(factory.createUniqueName("_this", 16 | 32), initializer)
                        : initializer;
                }
                return ts.setOriginalNode(resultingCall, node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitNewExpression(node) {
            if (ts.some(node.arguments, ts.isSpreadElement)) {
                var _a = factory.createCallBinding(factory.createPropertyAccessExpression(node.expression, "bind"), hoistVariableDeclaration), target = _a.target, thisArg = _a.thisArg;
                return factory.createNewExpression(factory.createFunctionApplyCall(ts.visitNode(target, visitor, ts.isExpression), thisArg, transformAndSpreadElements(factory.createNodeArray(__spreadArray([factory.createVoidZero()], node.arguments, true)), true, false, false)), undefined, []);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndSpreadElements(elements, isArgumentList, multiLine, hasTrailingComma) {
            var numElements = elements.length;
            var segments = ts.flatten(ts.spanMap(elements, partitionSpread, function (partition, visitPartition, _start, end) {
                return visitPartition(partition, multiLine, hasTrailingComma && end === numElements);
            }));
            if (segments.length === 1) {
                var firstSegment = segments[0];
                if (isArgumentList && !compilerOptions.downlevelIteration
                    || ts.isPackedArrayLiteral(firstSegment.expression)
                    || ts.isCallToHelper(firstSegment.expression, "___spreadArray")) {
                    return firstSegment.expression;
                }
            }
            var helpers = emitHelpers();
            var startsWithSpread = segments[0].kind !== 0;
            var expression = startsWithSpread ? factory.createArrayLiteralExpression() :
                segments[0].expression;
            for (var i = startsWithSpread ? 0 : 1; i < segments.length; i++) {
                var segment = segments[i];
                expression = helpers.createSpreadArrayHelper(expression, segment.expression, segment.kind === 1 && !isArgumentList);
            }
            return expression;
        }
        function partitionSpread(node) {
            return ts.isSpreadElement(node)
                ? visitSpanOfSpreads
                : visitSpanOfNonSpreads;
        }
        function visitSpanOfSpreads(chunk) {
            return ts.map(chunk, visitExpressionOfSpread);
        }
        function visitExpressionOfSpread(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var isCallToReadHelper = ts.isCallToHelper(expression, "___read");
            var kind = isCallToReadHelper || ts.isPackedArrayLiteral(expression) ? 2 : 1;
            if (compilerOptions.downlevelIteration && kind === 1 && !ts.isArrayLiteralExpression(expression) && !isCallToReadHelper) {
                expression = emitHelpers().createReadHelper(expression, undefined);
                kind = 2;
            }
            return createSpreadSegment(kind, expression);
        }
        function visitSpanOfNonSpreads(chunk, multiLine, hasTrailingComma) {
            var expression = factory.createArrayLiteralExpression(ts.visitNodes(factory.createNodeArray(chunk, hasTrailingComma), visitor, ts.isExpression), multiLine);
            return createSpreadSegment(0, expression);
        }
        function visitSpreadElement(node) {
            return ts.visitNode(node.expression, visitor, ts.isExpression);
        }
        function visitTemplateLiteral(node) {
            return ts.setTextRange(factory.createStringLiteral(node.text), node);
        }
        function visitStringLiteral(node) {
            if (node.hasExtendedUnicodeEscape) {
                return ts.setTextRange(factory.createStringLiteral(node.text), node);
            }
            return node;
        }
        function visitNumericLiteral(node) {
            if (node.numericLiteralFlags & 384) {
                return ts.setTextRange(factory.createNumericLiteral(node.text), node);
            }
            return node;
        }
        function visitTaggedTemplateExpression(node) {
            return ts.processTaggedTemplateExpression(context, node, visitor, currentSourceFile, recordTaggedTemplateString, ts.ProcessLevel.All);
        }
        function visitTemplateExpression(node) {
            var expression = factory.createStringLiteral(node.head.text);
            for (var _i = 0, _a = node.templateSpans; _i < _a.length; _i++) {
                var span = _a[_i];
                var args = [ts.visitNode(span.expression, visitor, ts.isExpression)];
                if (span.literal.text.length > 0) {
                    args.push(factory.createStringLiteral(span.literal.text));
                }
                expression = factory.createCallExpression(factory.createPropertyAccessExpression(expression, "concat"), undefined, args);
            }
            return ts.setTextRange(expression, node);
        }
        function visitSuperKeyword(isExpressionOfCall) {
            return hierarchyFacts & 8
                && !isExpressionOfCall
                ? factory.createPropertyAccessExpression(factory.createUniqueName("_super", 16 | 32), "prototype")
                : factory.createUniqueName("_super", 16 | 32);
        }
        function visitMetaProperty(node) {
            if (node.keywordToken === 103 && node.name.escapedText === "target") {
                hierarchyFacts |= 32768;
                return factory.createUniqueName("_newTarget", 16 | 32);
            }
            return node;
        }
        function onEmitNode(hint, node, emitCallback) {
            if (enabledSubstitutions & 1 && ts.isFunctionLike(node)) {
                var ancestorFacts = enterSubtree(32670, ts.getEmitFlags(node) & 8
                    ? 65 | 16
                    : 65);
                previousOnEmitNode(hint, node, emitCallback);
                exitSubtree(ancestorFacts, 0, 0);
                return;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        function enableSubstitutionsForBlockScopedBindings() {
            if ((enabledSubstitutions & 2) === 0) {
                enabledSubstitutions |= 2;
                context.enableSubstitution(79);
            }
        }
        function enableSubstitutionsForCapturedThis() {
            if ((enabledSubstitutions & 1) === 0) {
                enabledSubstitutions |= 1;
                context.enableSubstitution(108);
                context.enableEmitNotification(173);
                context.enableEmitNotification(171);
                context.enableEmitNotification(174);
                context.enableEmitNotification(175);
                context.enableEmitNotification(216);
                context.enableEmitNotification(215);
                context.enableEmitNotification(259);
            }
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1) {
                return substituteExpression(node);
            }
            if (ts.isIdentifier(node)) {
                return substituteIdentifier(node);
            }
            return node;
        }
        function substituteIdentifier(node) {
            if (enabledSubstitutions & 2 && !ts.isInternalName(node)) {
                var original = ts.getParseTreeNode(node, ts.isIdentifier);
                if (original && isNameOfDeclarationWithCollidingName(original)) {
                    return ts.setTextRange(factory.getGeneratedNameForNode(original), node);
                }
            }
            return node;
        }
        function isNameOfDeclarationWithCollidingName(node) {
            switch (node.parent.kind) {
                case 205:
                case 260:
                case 263:
                case 257:
                    return node.parent.name === node
                        && resolver.isDeclarationWithCollidingName(node.parent);
            }
            return false;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79:
                    return substituteExpressionIdentifier(node);
                case 108:
                    return substituteThisKeyword(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            if (enabledSubstitutions & 2 && !ts.isInternalName(node)) {
                var declaration = resolver.getReferencedDeclarationWithCollidingName(node);
                if (declaration && !(ts.isClassLike(declaration) && isPartOfClassBody(declaration, node))) {
                    return ts.setTextRange(factory.getGeneratedNameForNode(ts.getNameOfDeclaration(declaration)), node);
                }
            }
            return node;
        }
        function isPartOfClassBody(declaration, node) {
            var currentNode = ts.getParseTreeNode(node);
            if (!currentNode || currentNode === declaration || currentNode.end <= declaration.pos || currentNode.pos >= declaration.end) {
                return false;
            }
            var blockScope = ts.getEnclosingBlockScopeContainer(declaration);
            while (currentNode) {
                if (currentNode === blockScope || currentNode === declaration) {
                    return false;
                }
                if (ts.isClassElement(currentNode) && currentNode.parent === declaration) {
                    return true;
                }
                currentNode = currentNode.parent;
            }
            return false;
        }
        function substituteThisKeyword(node) {
            if (enabledSubstitutions & 1
                && hierarchyFacts & 16) {
                return ts.setTextRange(factory.createUniqueName("_this", 16 | 32), node);
            }
            return node;
        }
        function getClassMemberPrefix(node, member) {
            return ts.isStatic(member)
                ? factory.getInternalName(node)
                : factory.createPropertyAccessExpression(factory.getInternalName(node), "prototype");
        }
        function hasSynthesizedDefaultSuperCall(constructor, hasExtendsClause) {
            if (!constructor || !hasExtendsClause) {
                return false;
            }
            if (ts.some(constructor.parameters)) {
                return false;
            }
            var statement = ts.firstOrUndefined(constructor.body.statements);
            if (!statement || !ts.nodeIsSynthesized(statement) || statement.kind !== 241) {
                return false;
            }
            var statementExpression = statement.expression;
            if (!ts.nodeIsSynthesized(statementExpression) || statementExpression.kind !== 210) {
                return false;
            }
            var callTarget = statementExpression.expression;
            if (!ts.nodeIsSynthesized(callTarget) || callTarget.kind !== 106) {
                return false;
            }
            var callArgument = ts.singleOrUndefined(statementExpression.arguments);
            if (!callArgument || !ts.nodeIsSynthesized(callArgument) || callArgument.kind !== 227) {
                return false;
            }
            var expression = callArgument.expression;
            return ts.isIdentifier(expression) && expression.escapedText === "arguments";
        }
    }
    ts.transformES2015 = transformES2015;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformES5(context) {
        var factory = context.factory;
        var compilerOptions = context.getCompilerOptions();
        var previousOnEmitNode;
        var noSubstitution;
        if (compilerOptions.jsx === 1 || compilerOptions.jsx === 3) {
            previousOnEmitNode = context.onEmitNode;
            context.onEmitNode = onEmitNode;
            context.enableEmitNotification(283);
            context.enableEmitNotification(284);
            context.enableEmitNotification(282);
            noSubstitution = [];
        }
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        context.enableSubstitution(208);
        context.enableSubstitution(299);
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            return node;
        }
        function onEmitNode(hint, node, emitCallback) {
            switch (node.kind) {
                case 283:
                case 284:
                case 282:
                    var tagName = node.tagName;
                    noSubstitution[ts.getOriginalNodeId(tagName)] = true;
                    break;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        function onSubstituteNode(hint, node) {
            if (node.id && noSubstitution && noSubstitution[node.id]) {
                return previousOnSubstituteNode(hint, node);
            }
            node = previousOnSubstituteNode(hint, node);
            if (ts.isPropertyAccessExpression(node)) {
                return substitutePropertyAccessExpression(node);
            }
            else if (ts.isPropertyAssignment(node)) {
                return substitutePropertyAssignment(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (ts.isPrivateIdentifier(node.name)) {
                return node;
            }
            var literalName = trySubstituteReservedName(node.name);
            if (literalName) {
                return ts.setTextRange(factory.createElementAccessExpression(node.expression, literalName), node);
            }
            return node;
        }
        function substitutePropertyAssignment(node) {
            var literalName = ts.isIdentifier(node.name) && trySubstituteReservedName(node.name);
            if (literalName) {
                return factory.updatePropertyAssignment(node, literalName, node.initializer);
            }
            return node;
        }
        function trySubstituteReservedName(name) {
            var token = name.originalKeywordKind || (ts.nodeIsSynthesized(name) ? ts.stringToToken(ts.idText(name)) : undefined);
            if (token !== undefined && token >= 81 && token <= 116) {
                return ts.setTextRange(factory.createStringLiteralFromNode(name), name);
            }
            return undefined;
        }
    }
    ts.transformES5 = transformES5;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function getInstructionName(instruction) {
        switch (instruction) {
            case 2: return "return";
            case 3: return "break";
            case 4: return "yield";
            case 5: return "yield*";
            case 7: return "endfinally";
            default: return undefined;
        }
    }
    function transformGenerators(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistFunctionDeclaration = context.hoistFunctionDeclaration, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var resolver = context.getEmitResolver();
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var renamedCatchVariables;
        var renamedCatchVariableDeclarations;
        var inGeneratorFunctionBody;
        var inStatementContainingYield;
        var blocks;
        var blockOffsets;
        var blockActions;
        var blockStack;
        var labelOffsets;
        var labelExpressions;
        var nextLabelId = 1;
        var operations;
        var operationArguments;
        var operationLocations;
        var state;
        var blockIndex = 0;
        var labelNumber = 0;
        var labelNumbers;
        var lastOperationWasAbrupt;
        var lastOperationWasCompletion;
        var clauses;
        var statements;
        var exceptionBlockStack;
        var currentExceptionBlock;
        var withBlockStack;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile || (node.transformFlags & 2048) === 0) {
                return node;
            }
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function visitor(node) {
            var transformFlags = node.transformFlags;
            if (inStatementContainingYield) {
                return visitJavaScriptInStatementContainingYield(node);
            }
            else if (inGeneratorFunctionBody) {
                return visitJavaScriptInGeneratorFunctionBody(node);
            }
            else if (ts.isFunctionLikeDeclaration(node) && node.asteriskToken) {
                return visitGenerator(node);
            }
            else if (transformFlags & 2048) {
                return ts.visitEachChild(node, visitor, context);
            }
            else {
                return node;
            }
        }
        function visitJavaScriptInStatementContainingYield(node) {
            switch (node.kind) {
                case 243:
                    return visitDoStatement(node);
                case 244:
                    return visitWhileStatement(node);
                case 252:
                    return visitSwitchStatement(node);
                case 253:
                    return visitLabeledStatement(node);
                default:
                    return visitJavaScriptInGeneratorFunctionBody(node);
            }
        }
        function visitJavaScriptInGeneratorFunctionBody(node) {
            switch (node.kind) {
                case 259:
                    return visitFunctionDeclaration(node);
                case 215:
                    return visitFunctionExpression(node);
                case 174:
                case 175:
                    return visitAccessorDeclaration(node);
                case 240:
                    return visitVariableStatement(node);
                case 245:
                    return visitForStatement(node);
                case 246:
                    return visitForInStatement(node);
                case 249:
                    return visitBreakStatement(node);
                case 248:
                    return visitContinueStatement(node);
                case 250:
                    return visitReturnStatement(node);
                default:
                    if (node.transformFlags & 1048576) {
                        return visitJavaScriptContainingYield(node);
                    }
                    else if (node.transformFlags & (2048 | 4194304)) {
                        return ts.visitEachChild(node, visitor, context);
                    }
                    else {
                        return node;
                    }
            }
        }
        function visitJavaScriptContainingYield(node) {
            switch (node.kind) {
                case 223:
                    return visitBinaryExpression(node);
                case 354:
                    return visitCommaListExpression(node);
                case 224:
                    return visitConditionalExpression(node);
                case 226:
                    return visitYieldExpression(node);
                case 206:
                    return visitArrayLiteralExpression(node);
                case 207:
                    return visitObjectLiteralExpression(node);
                case 209:
                    return visitElementAccessExpression(node);
                case 210:
                    return visitCallExpression(node);
                case 211:
                    return visitNewExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitGenerator(node) {
            switch (node.kind) {
                case 259:
                    return visitFunctionDeclaration(node);
                case 215:
                    return visitFunctionExpression(node);
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
        }
        function visitFunctionDeclaration(node) {
            if (node.asteriskToken) {
                node = ts.setOriginalNode(ts.setTextRange(factory.createFunctionDeclaration(node.modifiers, undefined, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, transformGeneratorFunctionBody(node.body)), node), node);
            }
            else {
                var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
                var savedInStatementContainingYield = inStatementContainingYield;
                inGeneratorFunctionBody = false;
                inStatementContainingYield = false;
                node = ts.visitEachChild(node, visitor, context);
                inGeneratorFunctionBody = savedInGeneratorFunctionBody;
                inStatementContainingYield = savedInStatementContainingYield;
            }
            if (inGeneratorFunctionBody) {
                hoistFunctionDeclaration(node);
                return undefined;
            }
            else {
                return node;
            }
        }
        function visitFunctionExpression(node) {
            if (node.asteriskToken) {
                node = ts.setOriginalNode(ts.setTextRange(factory.createFunctionExpression(undefined, undefined, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, transformGeneratorFunctionBody(node.body)), node), node);
            }
            else {
                var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
                var savedInStatementContainingYield = inStatementContainingYield;
                inGeneratorFunctionBody = false;
                inStatementContainingYield = false;
                node = ts.visitEachChild(node, visitor, context);
                inGeneratorFunctionBody = savedInGeneratorFunctionBody;
                inStatementContainingYield = savedInStatementContainingYield;
            }
            return node;
        }
        function visitAccessorDeclaration(node) {
            var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
            var savedInStatementContainingYield = inStatementContainingYield;
            inGeneratorFunctionBody = false;
            inStatementContainingYield = false;
            node = ts.visitEachChild(node, visitor, context);
            inGeneratorFunctionBody = savedInGeneratorFunctionBody;
            inStatementContainingYield = savedInStatementContainingYield;
            return node;
        }
        function transformGeneratorFunctionBody(body) {
            var statements = [];
            var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
            var savedInStatementContainingYield = inStatementContainingYield;
            var savedBlocks = blocks;
            var savedBlockOffsets = blockOffsets;
            var savedBlockActions = blockActions;
            var savedBlockStack = blockStack;
            var savedLabelOffsets = labelOffsets;
            var savedLabelExpressions = labelExpressions;
            var savedNextLabelId = nextLabelId;
            var savedOperations = operations;
            var savedOperationArguments = operationArguments;
            var savedOperationLocations = operationLocations;
            var savedState = state;
            inGeneratorFunctionBody = true;
            inStatementContainingYield = false;
            blocks = undefined;
            blockOffsets = undefined;
            blockActions = undefined;
            blockStack = undefined;
            labelOffsets = undefined;
            labelExpressions = undefined;
            nextLabelId = 1;
            operations = undefined;
            operationArguments = undefined;
            operationLocations = undefined;
            state = factory.createTempVariable(undefined);
            resumeLexicalEnvironment();
            var statementOffset = factory.copyPrologue(body.statements, statements, false, visitor);
            transformAndEmitStatements(body.statements, statementOffset);
            var buildResult = build();
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            statements.push(factory.createReturnStatement(buildResult));
            inGeneratorFunctionBody = savedInGeneratorFunctionBody;
            inStatementContainingYield = savedInStatementContainingYield;
            blocks = savedBlocks;
            blockOffsets = savedBlockOffsets;
            blockActions = savedBlockActions;
            blockStack = savedBlockStack;
            labelOffsets = savedLabelOffsets;
            labelExpressions = savedLabelExpressions;
            nextLabelId = savedNextLabelId;
            operations = savedOperations;
            operationArguments = savedOperationArguments;
            operationLocations = savedOperationLocations;
            state = savedState;
            return ts.setTextRange(factory.createBlock(statements, body.multiLine), body);
        }
        function visitVariableStatement(node) {
            if (node.transformFlags & 1048576) {
                transformAndEmitVariableDeclarationList(node.declarationList);
                return undefined;
            }
            else {
                if (ts.getEmitFlags(node) & 1048576) {
                    return node;
                }
                for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    hoistVariableDeclaration(variable.name);
                }
                var variables = ts.getInitializedVariables(node.declarationList);
                if (variables.length === 0) {
                    return undefined;
                }
                return ts.setSourceMapRange(factory.createExpressionStatement(factory.inlineExpressions(ts.map(variables, transformInitializedVariable))), node);
            }
        }
        function visitBinaryExpression(node) {
            var assoc = ts.getExpressionAssociativity(node);
            switch (assoc) {
                case 0:
                    return visitLeftAssociativeBinaryExpression(node);
                case 1:
                    return visitRightAssociativeBinaryExpression(node);
                default:
                    return ts.Debug.assertNever(assoc);
            }
        }
        function visitRightAssociativeBinaryExpression(node) {
            var left = node.left, right = node.right;
            if (containsYield(right)) {
                var target = void 0;
                switch (left.kind) {
                    case 208:
                        target = factory.updatePropertyAccessExpression(left, cacheExpression(ts.visitNode(left.expression, visitor, ts.isLeftHandSideExpression)), left.name);
                        break;
                    case 209:
                        target = factory.updateElementAccessExpression(left, cacheExpression(ts.visitNode(left.expression, visitor, ts.isLeftHandSideExpression)), cacheExpression(ts.visitNode(left.argumentExpression, visitor, ts.isExpression)));
                        break;
                    default:
                        target = ts.visitNode(left, visitor, ts.isExpression);
                        break;
                }
                var operator = node.operatorToken.kind;
                if (ts.isCompoundAssignment(operator)) {
                    return ts.setTextRange(factory.createAssignment(target, ts.setTextRange(factory.createBinaryExpression(cacheExpression(target), ts.getNonAssignmentOperatorForCompoundAssignment(operator), ts.visitNode(right, visitor, ts.isExpression)), node)), node);
                }
                else {
                    return factory.updateBinaryExpression(node, target, node.operatorToken, ts.visitNode(right, visitor, ts.isExpression));
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitLeftAssociativeBinaryExpression(node) {
            if (containsYield(node.right)) {
                if (ts.isLogicalOperator(node.operatorToken.kind)) {
                    return visitLogicalBinaryExpression(node);
                }
                else if (node.operatorToken.kind === 27) {
                    return visitCommaExpression(node);
                }
                return factory.updateBinaryExpression(node, cacheExpression(ts.visitNode(node.left, visitor, ts.isExpression)), node.operatorToken, ts.visitNode(node.right, visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCommaExpression(node) {
            var pendingExpressions = [];
            visit(node.left);
            visit(node.right);
            return factory.inlineExpressions(pendingExpressions);
            function visit(node) {
                if (ts.isBinaryExpression(node) && node.operatorToken.kind === 27) {
                    visit(node.left);
                    visit(node.right);
                }
                else {
                    if (containsYield(node) && pendingExpressions.length > 0) {
                        emitWorker(1, [factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions))]);
                        pendingExpressions = [];
                    }
                    pendingExpressions.push(ts.visitNode(node, visitor, ts.isExpression));
                }
            }
        }
        function visitCommaListExpression(node) {
            var pendingExpressions = [];
            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                var elem = _a[_i];
                if (ts.isBinaryExpression(elem) && elem.operatorToken.kind === 27) {
                    pendingExpressions.push(visitCommaExpression(elem));
                }
                else {
                    if (containsYield(elem) && pendingExpressions.length > 0) {
                        emitWorker(1, [factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions))]);
                        pendingExpressions = [];
                    }
                    pendingExpressions.push(ts.visitNode(elem, visitor, ts.isExpression));
                }
            }
            return factory.inlineExpressions(pendingExpressions);
        }
        function visitLogicalBinaryExpression(node) {
            var resultLabel = defineLabel();
            var resultLocal = declareLocal();
            emitAssignment(resultLocal, ts.visitNode(node.left, visitor, ts.isExpression), node.left);
            if (node.operatorToken.kind === 55) {
                emitBreakWhenFalse(resultLabel, resultLocal, node.left);
            }
            else {
                emitBreakWhenTrue(resultLabel, resultLocal, node.left);
            }
            emitAssignment(resultLocal, ts.visitNode(node.right, visitor, ts.isExpression), node.right);
            markLabel(resultLabel);
            return resultLocal;
        }
        function visitConditionalExpression(node) {
            if (containsYield(node.whenTrue) || containsYield(node.whenFalse)) {
                var whenFalseLabel = defineLabel();
                var resultLabel = defineLabel();
                var resultLocal = declareLocal();
                emitBreakWhenFalse(whenFalseLabel, ts.visitNode(node.condition, visitor, ts.isExpression), node.condition);
                emitAssignment(resultLocal, ts.visitNode(node.whenTrue, visitor, ts.isExpression), node.whenTrue);
                emitBreak(resultLabel);
                markLabel(whenFalseLabel);
                emitAssignment(resultLocal, ts.visitNode(node.whenFalse, visitor, ts.isExpression), node.whenFalse);
                markLabel(resultLabel);
                return resultLocal;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitYieldExpression(node) {
            var resumeLabel = defineLabel();
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            if (node.asteriskToken) {
                var iterator = (ts.getEmitFlags(node.expression) & 8388608) === 0
                    ? ts.setTextRange(emitHelpers().createValuesHelper(expression), node)
                    : expression;
                emitYieldStar(iterator, node);
            }
            else {
                emitYield(expression, node);
            }
            markLabel(resumeLabel);
            return createGeneratorResume(node);
        }
        function visitArrayLiteralExpression(node) {
            return visitElements(node.elements, undefined, undefined, node.multiLine);
        }
        function visitElements(elements, leadingElement, location, multiLine) {
            var numInitialElements = countInitialNodesWithoutYield(elements);
            var temp;
            if (numInitialElements > 0) {
                temp = declareLocal();
                var initialElements = ts.visitNodes(elements, visitor, ts.isExpression, 0, numInitialElements);
                emitAssignment(temp, factory.createArrayLiteralExpression(leadingElement
                    ? __spreadArray([leadingElement], initialElements, true) : initialElements));
                leadingElement = undefined;
            }
            var expressions = ts.reduceLeft(elements, reduceElement, [], numInitialElements);
            return temp
                ? factory.createArrayConcatCall(temp, [factory.createArrayLiteralExpression(expressions, multiLine)])
                : ts.setTextRange(factory.createArrayLiteralExpression(leadingElement ? __spreadArray([leadingElement], expressions, true) : expressions, multiLine), location);
            function reduceElement(expressions, element) {
                if (containsYield(element) && expressions.length > 0) {
                    var hasAssignedTemp = temp !== undefined;
                    if (!temp) {
                        temp = declareLocal();
                    }
                    emitAssignment(temp, hasAssignedTemp
                        ? factory.createArrayConcatCall(temp, [factory.createArrayLiteralExpression(expressions, multiLine)])
                        : factory.createArrayLiteralExpression(leadingElement ? __spreadArray([leadingElement], expressions, true) : expressions, multiLine));
                    leadingElement = undefined;
                    expressions = [];
                }
                expressions.push(ts.visitNode(element, visitor, ts.isExpression));
                return expressions;
            }
        }
        function visitObjectLiteralExpression(node) {
            var properties = node.properties;
            var multiLine = node.multiLine;
            var numInitialProperties = countInitialNodesWithoutYield(properties);
            var temp = declareLocal();
            emitAssignment(temp, factory.createObjectLiteralExpression(ts.visitNodes(properties, visitor, ts.isObjectLiteralElementLike, 0, numInitialProperties), multiLine));
            var expressions = ts.reduceLeft(properties, reduceProperty, [], numInitialProperties);
            expressions.push(multiLine ? ts.startOnNewLine(ts.setParent(ts.setTextRange(factory.cloneNode(temp), temp), temp.parent)) : temp);
            return factory.inlineExpressions(expressions);
            function reduceProperty(expressions, property) {
                if (containsYield(property) && expressions.length > 0) {
                    emitStatement(factory.createExpressionStatement(factory.inlineExpressions(expressions)));
                    expressions = [];
                }
                var expression = ts.createExpressionForObjectLiteralElementLike(factory, node, property, temp);
                var visited = ts.visitNode(expression, visitor, ts.isExpression);
                if (visited) {
                    if (multiLine) {
                        ts.startOnNewLine(visited);
                    }
                    expressions.push(visited);
                }
                return expressions;
            }
        }
        function visitElementAccessExpression(node) {
            if (containsYield(node.argumentExpression)) {
                return factory.updateElementAccessExpression(node, cacheExpression(ts.visitNode(node.expression, visitor, ts.isLeftHandSideExpression)), ts.visitNode(node.argumentExpression, visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCallExpression(node) {
            if (!ts.isImportCall(node) && ts.forEach(node.arguments, containsYield)) {
                var _a = factory.createCallBinding(node.expression, hoistVariableDeclaration, languageVersion, true), target = _a.target, thisArg = _a.thisArg;
                return ts.setOriginalNode(ts.setTextRange(factory.createFunctionApplyCall(cacheExpression(ts.visitNode(target, visitor, ts.isLeftHandSideExpression)), thisArg, visitElements(node.arguments)), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitNewExpression(node) {
            if (ts.forEach(node.arguments, containsYield)) {
                var _a = factory.createCallBinding(factory.createPropertyAccessExpression(node.expression, "bind"), hoistVariableDeclaration), target = _a.target, thisArg = _a.thisArg;
                return ts.setOriginalNode(ts.setTextRange(factory.createNewExpression(factory.createFunctionApplyCall(cacheExpression(ts.visitNode(target, visitor, ts.isExpression)), thisArg, visitElements(node.arguments, factory.createVoidZero())), undefined, []), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndEmitStatements(statements, start) {
            if (start === void 0) { start = 0; }
            var numStatements = statements.length;
            for (var i = start; i < numStatements; i++) {
                transformAndEmitStatement(statements[i]);
            }
        }
        function transformAndEmitEmbeddedStatement(node) {
            if (ts.isBlock(node)) {
                transformAndEmitStatements(node.statements);
            }
            else {
                transformAndEmitStatement(node);
            }
        }
        function transformAndEmitStatement(node) {
            var savedInStatementContainingYield = inStatementContainingYield;
            if (!inStatementContainingYield) {
                inStatementContainingYield = containsYield(node);
            }
            transformAndEmitStatementWorker(node);
            inStatementContainingYield = savedInStatementContainingYield;
        }
        function transformAndEmitStatementWorker(node) {
            switch (node.kind) {
                case 238:
                    return transformAndEmitBlock(node);
                case 241:
                    return transformAndEmitExpressionStatement(node);
                case 242:
                    return transformAndEmitIfStatement(node);
                case 243:
                    return transformAndEmitDoStatement(node);
                case 244:
                    return transformAndEmitWhileStatement(node);
                case 245:
                    return transformAndEmitForStatement(node);
                case 246:
                    return transformAndEmitForInStatement(node);
                case 248:
                    return transformAndEmitContinueStatement(node);
                case 249:
                    return transformAndEmitBreakStatement(node);
                case 250:
                    return transformAndEmitReturnStatement(node);
                case 251:
                    return transformAndEmitWithStatement(node);
                case 252:
                    return transformAndEmitSwitchStatement(node);
                case 253:
                    return transformAndEmitLabeledStatement(node);
                case 254:
                    return transformAndEmitThrowStatement(node);
                case 255:
                    return transformAndEmitTryStatement(node);
                default:
                    return emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitBlock(node) {
            if (containsYield(node)) {
                transformAndEmitStatements(node.statements);
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitExpressionStatement(node) {
            emitStatement(ts.visitNode(node, visitor, ts.isStatement));
        }
        function transformAndEmitVariableDeclarationList(node) {
            for (var _i = 0, _a = node.declarations; _i < _a.length; _i++) {
                var variable = _a[_i];
                var name = factory.cloneNode(variable.name);
                ts.setCommentRange(name, variable.name);
                hoistVariableDeclaration(name);
            }
            var variables = ts.getInitializedVariables(node);
            var numVariables = variables.length;
            var variablesWritten = 0;
            var pendingExpressions = [];
            while (variablesWritten < numVariables) {
                for (var i = variablesWritten; i < numVariables; i++) {
                    var variable = variables[i];
                    if (containsYield(variable.initializer) && pendingExpressions.length > 0) {
                        break;
                    }
                    pendingExpressions.push(transformInitializedVariable(variable));
                }
                if (pendingExpressions.length) {
                    emitStatement(factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions)));
                    variablesWritten += pendingExpressions.length;
                    pendingExpressions = [];
                }
            }
            return undefined;
        }
        function transformInitializedVariable(node) {
            return ts.setSourceMapRange(factory.createAssignment(ts.setSourceMapRange(factory.cloneNode(node.name), node.name), ts.visitNode(node.initializer, visitor, ts.isExpression)), node);
        }
        function transformAndEmitIfStatement(node) {
            if (containsYield(node)) {
                if (containsYield(node.thenStatement) || containsYield(node.elseStatement)) {
                    var endLabel = defineLabel();
                    var elseLabel = node.elseStatement ? defineLabel() : undefined;
                    emitBreakWhenFalse(node.elseStatement ? elseLabel : endLabel, ts.visitNode(node.expression, visitor, ts.isExpression), node.expression);
                    transformAndEmitEmbeddedStatement(node.thenStatement);
                    if (node.elseStatement) {
                        emitBreak(endLabel);
                        markLabel(elseLabel);
                        transformAndEmitEmbeddedStatement(node.elseStatement);
                    }
                    markLabel(endLabel);
                }
                else {
                    emitStatement(ts.visitNode(node, visitor, ts.isStatement));
                }
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitDoStatement(node) {
            if (containsYield(node)) {
                var conditionLabel = defineLabel();
                var loopLabel = defineLabel();
                beginLoopBlock(conditionLabel);
                markLabel(loopLabel);
                transformAndEmitEmbeddedStatement(node.statement);
                markLabel(conditionLabel);
                emitBreakWhenTrue(loopLabel, ts.visitNode(node.expression, visitor, ts.isExpression));
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitDoStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
                node = ts.visitEachChild(node, visitor, context);
                endLoopBlock();
                return node;
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformAndEmitWhileStatement(node) {
            if (containsYield(node)) {
                var loopLabel = defineLabel();
                var endLabel = beginLoopBlock(loopLabel);
                markLabel(loopLabel);
                emitBreakWhenFalse(endLabel, ts.visitNode(node.expression, visitor, ts.isExpression));
                transformAndEmitEmbeddedStatement(node.statement);
                emitBreak(loopLabel);
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitWhileStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
                node = ts.visitEachChild(node, visitor, context);
                endLoopBlock();
                return node;
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformAndEmitForStatement(node) {
            if (containsYield(node)) {
                var conditionLabel = defineLabel();
                var incrementLabel = defineLabel();
                var endLabel = beginLoopBlock(incrementLabel);
                if (node.initializer) {
                    var initializer = node.initializer;
                    if (ts.isVariableDeclarationList(initializer)) {
                        transformAndEmitVariableDeclarationList(initializer);
                    }
                    else {
                        emitStatement(ts.setTextRange(factory.createExpressionStatement(ts.visitNode(initializer, visitor, ts.isExpression)), initializer));
                    }
                }
                markLabel(conditionLabel);
                if (node.condition) {
                    emitBreakWhenFalse(endLabel, ts.visitNode(node.condition, visitor, ts.isExpression));
                }
                transformAndEmitEmbeddedStatement(node.statement);
                markLabel(incrementLabel);
                if (node.incrementor) {
                    emitStatement(ts.setTextRange(factory.createExpressionStatement(ts.visitNode(node.incrementor, visitor, ts.isExpression)), node.incrementor));
                }
                emitBreak(conditionLabel);
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitForStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
            }
            var initializer = node.initializer;
            if (initializer && ts.isVariableDeclarationList(initializer)) {
                for (var _i = 0, _a = initializer.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    hoistVariableDeclaration(variable.name);
                }
                var variables = ts.getInitializedVariables(initializer);
                node = factory.updateForStatement(node, variables.length > 0
                    ? factory.inlineExpressions(ts.map(variables, transformInitializedVariable))
                    : undefined, ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitor, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
            }
            else {
                node = ts.visitEachChild(node, visitor, context);
            }
            if (inStatementContainingYield) {
                endLoopBlock();
            }
            return node;
        }
        function transformAndEmitForInStatement(node) {
            if (containsYield(node)) {
                var obj = declareLocal();
                var keysArray = declareLocal();
                var key = declareLocal();
                var keysIndex = factory.createLoopVariable();
                var initializer = node.initializer;
                hoistVariableDeclaration(keysIndex);
                emitAssignment(obj, ts.visitNode(node.expression, visitor, ts.isExpression));
                emitAssignment(keysArray, factory.createArrayLiteralExpression());
                emitStatement(factory.createForInStatement(key, obj, factory.createExpressionStatement(factory.createCallExpression(factory.createPropertyAccessExpression(keysArray, "push"), undefined, [key]))));
                emitAssignment(keysIndex, factory.createNumericLiteral(0));
                var conditionLabel = defineLabel();
                var incrementLabel = defineLabel();
                var endLoopLabel = beginLoopBlock(incrementLabel);
                markLabel(conditionLabel);
                emitBreakWhenFalse(endLoopLabel, factory.createLessThan(keysIndex, factory.createPropertyAccessExpression(keysArray, "length")));
                emitAssignment(key, factory.createElementAccessExpression(keysArray, keysIndex));
                emitBreakWhenFalse(incrementLabel, factory.createBinaryExpression(key, 101, obj));
                var variable = void 0;
                if (ts.isVariableDeclarationList(initializer)) {
                    for (var _i = 0, _a = initializer.declarations; _i < _a.length; _i++) {
                        var variable_1 = _a[_i];
                        hoistVariableDeclaration(variable_1.name);
                    }
                    variable = factory.cloneNode(initializer.declarations[0].name);
                }
                else {
                    variable = ts.visitNode(initializer, visitor, ts.isExpression);
                    ts.Debug.assert(ts.isLeftHandSideExpression(variable));
                }
                emitAssignment(variable, key);
                transformAndEmitEmbeddedStatement(node.statement);
                markLabel(incrementLabel);
                emitStatement(factory.createExpressionStatement(factory.createPostfixIncrement(keysIndex)));
                emitBreak(conditionLabel);
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitForInStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
            }
            var initializer = node.initializer;
            if (ts.isVariableDeclarationList(initializer)) {
                for (var _i = 0, _a = initializer.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    hoistVariableDeclaration(variable.name);
                }
                node = factory.updateForInStatement(node, initializer.declarations[0].name, ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitNode(node.statement, visitor, ts.isStatement, factory.liftToBlock));
            }
            else {
                node = ts.visitEachChild(node, visitor, context);
            }
            if (inStatementContainingYield) {
                endLoopBlock();
            }
            return node;
        }
        function transformAndEmitContinueStatement(node) {
            var label = findContinueTarget(node.label ? ts.idText(node.label) : undefined);
            if (label > 0) {
                emitBreak(label, node);
            }
            else {
                emitStatement(node);
            }
        }
        function visitContinueStatement(node) {
            if (inStatementContainingYield) {
                var label = findContinueTarget(node.label && ts.idText(node.label));
                if (label > 0) {
                    return createInlineBreak(label, node);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndEmitBreakStatement(node) {
            var label = findBreakTarget(node.label ? ts.idText(node.label) : undefined);
            if (label > 0) {
                emitBreak(label, node);
            }
            else {
                emitStatement(node);
            }
        }
        function visitBreakStatement(node) {
            if (inStatementContainingYield) {
                var label = findBreakTarget(node.label && ts.idText(node.label));
                if (label > 0) {
                    return createInlineBreak(label, node);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndEmitReturnStatement(node) {
            emitReturn(ts.visitNode(node.expression, visitor, ts.isExpression), node);
        }
        function visitReturnStatement(node) {
            return createInlineReturn(ts.visitNode(node.expression, visitor, ts.isExpression), node);
        }
        function transformAndEmitWithStatement(node) {
            if (containsYield(node)) {
                beginWithBlock(cacheExpression(ts.visitNode(node.expression, visitor, ts.isExpression)));
                transformAndEmitEmbeddedStatement(node.statement);
                endWithBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitSwitchStatement(node) {
            if (containsYield(node.caseBlock)) {
                var caseBlock = node.caseBlock;
                var numClauses = caseBlock.clauses.length;
                var endLabel = beginSwitchBlock();
                var expression = cacheExpression(ts.visitNode(node.expression, visitor, ts.isExpression));
                var clauseLabels = [];
                var defaultClauseIndex = -1;
                for (var i = 0; i < numClauses; i++) {
                    var clause = caseBlock.clauses[i];
                    clauseLabels.push(defineLabel());
                    if (clause.kind === 293 && defaultClauseIndex === -1) {
                        defaultClauseIndex = i;
                    }
                }
                var clausesWritten = 0;
                var pendingClauses = [];
                while (clausesWritten < numClauses) {
                    var defaultClausesSkipped = 0;
                    for (var i = clausesWritten; i < numClauses; i++) {
                        var clause = caseBlock.clauses[i];
                        if (clause.kind === 292) {
                            if (containsYield(clause.expression) && pendingClauses.length > 0) {
                                break;
                            }
                            pendingClauses.push(factory.createCaseClause(ts.visitNode(clause.expression, visitor, ts.isExpression), [
                                createInlineBreak(clauseLabels[i], clause.expression)
                            ]));
                        }
                        else {
                            defaultClausesSkipped++;
                        }
                    }
                    if (pendingClauses.length) {
                        emitStatement(factory.createSwitchStatement(expression, factory.createCaseBlock(pendingClauses)));
                        clausesWritten += pendingClauses.length;
                        pendingClauses = [];
                    }
                    if (defaultClausesSkipped > 0) {
                        clausesWritten += defaultClausesSkipped;
                        defaultClausesSkipped = 0;
                    }
                }
                if (defaultClauseIndex >= 0) {
                    emitBreak(clauseLabels[defaultClauseIndex]);
                }
                else {
                    emitBreak(endLabel);
                }
                for (var i = 0; i < numClauses; i++) {
                    markLabel(clauseLabels[i]);
                    transformAndEmitStatements(caseBlock.clauses[i].statements);
                }
                endSwitchBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitSwitchStatement(node) {
            if (inStatementContainingYield) {
                beginScriptSwitchBlock();
            }
            node = ts.visitEachChild(node, visitor, context);
            if (inStatementContainingYield) {
                endSwitchBlock();
            }
            return node;
        }
        function transformAndEmitLabeledStatement(node) {
            if (containsYield(node)) {
                beginLabeledBlock(ts.idText(node.label));
                transformAndEmitEmbeddedStatement(node.statement);
                endLabeledBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitLabeledStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLabeledBlock(ts.idText(node.label));
            }
            node = ts.visitEachChild(node, visitor, context);
            if (inStatementContainingYield) {
                endLabeledBlock();
            }
            return node;
        }
        function transformAndEmitThrowStatement(node) {
            var _a;
            emitThrow(ts.visitNode((_a = node.expression) !== null && _a !== void 0 ? _a : factory.createVoidZero(), visitor, ts.isExpression), node);
        }
        function transformAndEmitTryStatement(node) {
            if (containsYield(node)) {
                beginExceptionBlock();
                transformAndEmitEmbeddedStatement(node.tryBlock);
                if (node.catchClause) {
                    beginCatchBlock(node.catchClause.variableDeclaration);
                    transformAndEmitEmbeddedStatement(node.catchClause.block);
                }
                if (node.finallyBlock) {
                    beginFinallyBlock();
                    transformAndEmitEmbeddedStatement(node.finallyBlock);
                }
                endExceptionBlock();
            }
            else {
                emitStatement(ts.visitEachChild(node, visitor, context));
            }
        }
        function containsYield(node) {
            return !!node && (node.transformFlags & 1048576) !== 0;
        }
        function countInitialNodesWithoutYield(nodes) {
            var numNodes = nodes.length;
            for (var i = 0; i < numNodes; i++) {
                if (containsYield(nodes[i])) {
                    return i;
                }
            }
            return -1;
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            if (ts.isIdentifier(node)) {
                return substituteExpressionIdentifier(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            if (!ts.isGeneratedIdentifier(node) && renamedCatchVariables && renamedCatchVariables.has(ts.idText(node))) {
                var original = ts.getOriginalNode(node);
                if (ts.isIdentifier(original) && original.parent) {
                    var declaration = resolver.getReferencedValueDeclaration(original);
                    if (declaration) {
                        var name = renamedCatchVariableDeclarations[ts.getOriginalNodeId(declaration)];
                        if (name) {
                            var clone_6 = ts.setParent(ts.setTextRange(factory.cloneNode(name), name), name.parent);
                            ts.setSourceMapRange(clone_6, node);
                            ts.setCommentRange(clone_6, node);
                            return clone_6;
                        }
                    }
                }
            }
            return node;
        }
        function cacheExpression(node) {
            if (ts.isGeneratedIdentifier(node) || ts.getEmitFlags(node) & 4096) {
                return node;
            }
            var temp = factory.createTempVariable(hoistVariableDeclaration);
            emitAssignment(temp, node, node);
            return temp;
        }
        function declareLocal(name) {
            var temp = name
                ? factory.createUniqueName(name)
                : factory.createTempVariable(undefined);
            hoistVariableDeclaration(temp);
            return temp;
        }
        function defineLabel() {
            if (!labelOffsets) {
                labelOffsets = [];
            }
            var label = nextLabelId;
            nextLabelId++;
            labelOffsets[label] = -1;
            return label;
        }
        function markLabel(label) {
            ts.Debug.assert(labelOffsets !== undefined, "No labels were defined.");
            labelOffsets[label] = operations ? operations.length : 0;
        }
        function beginBlock(block) {
            if (!blocks) {
                blocks = [];
                blockActions = [];
                blockOffsets = [];
                blockStack = [];
            }
            var index = blockActions.length;
            blockActions[index] = 0;
            blockOffsets[index] = operations ? operations.length : 0;
            blocks[index] = block;
            blockStack.push(block);
            return index;
        }
        function endBlock() {
            var block = peekBlock();
            if (block === undefined)
                return ts.Debug.fail("beginBlock was never called.");
            var index = blockActions.length;
            blockActions[index] = 1;
            blockOffsets[index] = operations ? operations.length : 0;
            blocks[index] = block;
            blockStack.pop();
            return block;
        }
        function peekBlock() {
            return ts.lastOrUndefined(blockStack);
        }
        function peekBlockKind() {
            var block = peekBlock();
            return block && block.kind;
        }
        function beginWithBlock(expression) {
            var startLabel = defineLabel();
            var endLabel = defineLabel();
            markLabel(startLabel);
            beginBlock({
                kind: 1,
                expression: expression,
                startLabel: startLabel,
                endLabel: endLabel
            });
        }
        function endWithBlock() {
            ts.Debug.assert(peekBlockKind() === 1);
            var block = endBlock();
            markLabel(block.endLabel);
        }
        function beginExceptionBlock() {
            var startLabel = defineLabel();
            var endLabel = defineLabel();
            markLabel(startLabel);
            beginBlock({
                kind: 0,
                state: 0,
                startLabel: startLabel,
                endLabel: endLabel
            });
            emitNop();
            return endLabel;
        }
        function beginCatchBlock(variable) {
            ts.Debug.assert(peekBlockKind() === 0);
            var name;
            if (ts.isGeneratedIdentifier(variable.name)) {
                name = variable.name;
                hoistVariableDeclaration(variable.name);
            }
            else {
                var text = ts.idText(variable.name);
                name = declareLocal(text);
                if (!renamedCatchVariables) {
                    renamedCatchVariables = new ts.Map();
                    renamedCatchVariableDeclarations = [];
                    context.enableSubstitution(79);
                }
                renamedCatchVariables.set(text, true);
                renamedCatchVariableDeclarations[ts.getOriginalNodeId(variable)] = name;
            }
            var exception = peekBlock();
            ts.Debug.assert(exception.state < 1);
            var endLabel = exception.endLabel;
            emitBreak(endLabel);
            var catchLabel = defineLabel();
            markLabel(catchLabel);
            exception.state = 1;
            exception.catchVariable = name;
            exception.catchLabel = catchLabel;
            emitAssignment(name, factory.createCallExpression(factory.createPropertyAccessExpression(state, "sent"), undefined, []));
            emitNop();
        }
        function beginFinallyBlock() {
            ts.Debug.assert(peekBlockKind() === 0);
            var exception = peekBlock();
            ts.Debug.assert(exception.state < 2);
            var endLabel = exception.endLabel;
            emitBreak(endLabel);
            var finallyLabel = defineLabel();
            markLabel(finallyLabel);
            exception.state = 2;
            exception.finallyLabel = finallyLabel;
        }
        function endExceptionBlock() {
            ts.Debug.assert(peekBlockKind() === 0);
            var exception = endBlock();
            var state = exception.state;
            if (state < 2) {
                emitBreak(exception.endLabel);
            }
            else {
                emitEndfinally();
            }
            markLabel(exception.endLabel);
            emitNop();
            exception.state = 3;
        }
        function beginScriptLoopBlock() {
            beginBlock({
                kind: 3,
                isScript: true,
                breakLabel: -1,
                continueLabel: -1
            });
        }
        function beginLoopBlock(continueLabel) {
            var breakLabel = defineLabel();
            beginBlock({
                kind: 3,
                isScript: false,
                breakLabel: breakLabel,
                continueLabel: continueLabel,
            });
            return breakLabel;
        }
        function endLoopBlock() {
            ts.Debug.assert(peekBlockKind() === 3);
            var block = endBlock();
            var breakLabel = block.breakLabel;
            if (!block.isScript) {
                markLabel(breakLabel);
            }
        }
        function beginScriptSwitchBlock() {
            beginBlock({
                kind: 2,
                isScript: true,
                breakLabel: -1
            });
        }
        function beginSwitchBlock() {
            var breakLabel = defineLabel();
            beginBlock({
                kind: 2,
                isScript: false,
                breakLabel: breakLabel,
            });
            return breakLabel;
        }
        function endSwitchBlock() {
            ts.Debug.assert(peekBlockKind() === 2);
            var block = endBlock();
            var breakLabel = block.breakLabel;
            if (!block.isScript) {
                markLabel(breakLabel);
            }
        }
        function beginScriptLabeledBlock(labelText) {
            beginBlock({
                kind: 4,
                isScript: true,
                labelText: labelText,
                breakLabel: -1
            });
        }
        function beginLabeledBlock(labelText) {
            var breakLabel = defineLabel();
            beginBlock({
                kind: 4,
                isScript: false,
                labelText: labelText,
                breakLabel: breakLabel
            });
        }
        function endLabeledBlock() {
            ts.Debug.assert(peekBlockKind() === 4);
            var block = endBlock();
            if (!block.isScript) {
                markLabel(block.breakLabel);
            }
        }
        function supportsUnlabeledBreak(block) {
            return block.kind === 2
                || block.kind === 3;
        }
        function supportsLabeledBreakOrContinue(block) {
            return block.kind === 4;
        }
        function supportsUnlabeledContinue(block) {
            return block.kind === 3;
        }
        function hasImmediateContainingLabeledBlock(labelText, start) {
            for (var j = start; j >= 0; j--) {
                var containingBlock = blockStack[j];
                if (supportsLabeledBreakOrContinue(containingBlock)) {
                    if (containingBlock.labelText === labelText) {
                        return true;
                    }
                }
                else {
                    break;
                }
            }
            return false;
        }
        function findBreakTarget(labelText) {
            if (blockStack) {
                if (labelText) {
                    for (var i = blockStack.length - 1; i >= 0; i--) {
                        var block = blockStack[i];
                        if (supportsLabeledBreakOrContinue(block) && block.labelText === labelText) {
                            return block.breakLabel;
                        }
                        else if (supportsUnlabeledBreak(block) && hasImmediateContainingLabeledBlock(labelText, i - 1)) {
                            return block.breakLabel;
                        }
                    }
                }
                else {
                    for (var i = blockStack.length - 1; i >= 0; i--) {
                        var block = blockStack[i];
                        if (supportsUnlabeledBreak(block)) {
                            return block.breakLabel;
                        }
                    }
                }
            }
            return 0;
        }
        function findContinueTarget(labelText) {
            if (blockStack) {
                if (labelText) {
                    for (var i = blockStack.length - 1; i >= 0; i--) {
                        var block = blockStack[i];
                        if (supportsUnlabeledContinue(block) && hasImmediateContainingLabeledBlock(labelText, i - 1)) {
                            return block.continueLabel;
                        }
                    }
                }
                else {
                    for (var i = blockStack.length - 1; i >= 0; i--) {
                        var block = blockStack[i];
                        if (supportsUnlabeledContinue(block)) {
                            return block.continueLabel;
                        }
                    }
                }
            }
            return 0;
        }
        function createLabel(label) {
            if (label !== undefined && label > 0) {
                if (labelExpressions === undefined) {
                    labelExpressions = [];
                }
                var expression = factory.createNumericLiteral(-1);
                if (labelExpressions[label] === undefined) {
                    labelExpressions[label] = [expression];
                }
                else {
                    labelExpressions[label].push(expression);
                }
                return expression;
            }
            return factory.createOmittedExpression();
        }
        function createInstruction(instruction) {
            var literal = factory.createNumericLiteral(instruction);
            ts.addSyntheticTrailingComment(literal, 3, getInstructionName(instruction));
            return literal;
        }
        function createInlineBreak(label, location) {
            ts.Debug.assertLessThan(0, label, "Invalid label");
            return ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(3),
                createLabel(label)
            ])), location);
        }
        function createInlineReturn(expression, location) {
            return ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression(expression
                ? [createInstruction(2), expression]
                : [createInstruction(2)])), location);
        }
        function createGeneratorResume(location) {
            return ts.setTextRange(factory.createCallExpression(factory.createPropertyAccessExpression(state, "sent"), undefined, []), location);
        }
        function emitNop() {
            emitWorker(0);
        }
        function emitStatement(node) {
            if (node) {
                emitWorker(1, [node]);
            }
            else {
                emitNop();
            }
        }
        function emitAssignment(left, right, location) {
            emitWorker(2, [left, right], location);
        }
        function emitBreak(label, location) {
            emitWorker(3, [label], location);
        }
        function emitBreakWhenTrue(label, condition, location) {
            emitWorker(4, [label, condition], location);
        }
        function emitBreakWhenFalse(label, condition, location) {
            emitWorker(5, [label, condition], location);
        }
        function emitYieldStar(expression, location) {
            emitWorker(7, [expression], location);
        }
        function emitYield(expression, location) {
            emitWorker(6, [expression], location);
        }
        function emitReturn(expression, location) {
            emitWorker(8, [expression], location);
        }
        function emitThrow(expression, location) {
            emitWorker(9, [expression], location);
        }
        function emitEndfinally() {
            emitWorker(10);
        }
        function emitWorker(code, args, location) {
            if (operations === undefined) {
                operations = [];
                operationArguments = [];
                operationLocations = [];
            }
            if (labelOffsets === undefined) {
                markLabel(defineLabel());
            }
            var operationIndex = operations.length;
            operations[operationIndex] = code;
            operationArguments[operationIndex] = args;
            operationLocations[operationIndex] = location;
        }
        function build() {
            blockIndex = 0;
            labelNumber = 0;
            labelNumbers = undefined;
            lastOperationWasAbrupt = false;
            lastOperationWasCompletion = false;
            clauses = undefined;
            statements = undefined;
            exceptionBlockStack = undefined;
            currentExceptionBlock = undefined;
            withBlockStack = undefined;
            var buildResult = buildStatements();
            return emitHelpers().createGeneratorHelper(ts.setEmitFlags(factory.createFunctionExpression(undefined, undefined, undefined, undefined, [factory.createParameterDeclaration(undefined, undefined, state)], undefined, factory.createBlock(buildResult, buildResult.length > 0)), 524288));
        }
        function buildStatements() {
            if (operations) {
                for (var operationIndex = 0; operationIndex < operations.length; operationIndex++) {
                    writeOperation(operationIndex);
                }
                flushFinalLabel(operations.length);
            }
            else {
                flushFinalLabel(0);
            }
            if (clauses) {
                var labelExpression = factory.createPropertyAccessExpression(state, "label");
                var switchStatement = factory.createSwitchStatement(labelExpression, factory.createCaseBlock(clauses));
                return [ts.startOnNewLine(switchStatement)];
            }
            if (statements) {
                return statements;
            }
            return [];
        }
        function flushLabel() {
            if (!statements) {
                return;
            }
            appendLabel(!lastOperationWasAbrupt);
            lastOperationWasAbrupt = false;
            lastOperationWasCompletion = false;
            labelNumber++;
        }
        function flushFinalLabel(operationIndex) {
            if (isFinalLabelReachable(operationIndex)) {
                tryEnterLabel(operationIndex);
                withBlockStack = undefined;
                writeReturn(undefined, undefined);
            }
            if (statements && clauses) {
                appendLabel(false);
            }
            updateLabelExpressions();
        }
        function isFinalLabelReachable(operationIndex) {
            if (!lastOperationWasCompletion) {
                return true;
            }
            if (!labelOffsets || !labelExpressions) {
                return false;
            }
            for (var label = 0; label < labelOffsets.length; label++) {
                if (labelOffsets[label] === operationIndex && labelExpressions[label]) {
                    return true;
                }
            }
            return false;
        }
        function appendLabel(markLabelEnd) {
            if (!clauses) {
                clauses = [];
            }
            if (statements) {
                if (withBlockStack) {
                    for (var i = withBlockStack.length - 1; i >= 0; i--) {
                        var withBlock = withBlockStack[i];
                        statements = [factory.createWithStatement(withBlock.expression, factory.createBlock(statements))];
                    }
                }
                if (currentExceptionBlock) {
                    var startLabel = currentExceptionBlock.startLabel, catchLabel = currentExceptionBlock.catchLabel, finallyLabel = currentExceptionBlock.finallyLabel, endLabel = currentExceptionBlock.endLabel;
                    statements.unshift(factory.createExpressionStatement(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(state, "trys"), "push"), undefined, [
                        factory.createArrayLiteralExpression([
                            createLabel(startLabel),
                            createLabel(catchLabel),
                            createLabel(finallyLabel),
                            createLabel(endLabel)
                        ])
                    ])));
                    currentExceptionBlock = undefined;
                }
                if (markLabelEnd) {
                    statements.push(factory.createExpressionStatement(factory.createAssignment(factory.createPropertyAccessExpression(state, "label"), factory.createNumericLiteral(labelNumber + 1))));
                }
            }
            clauses.push(factory.createCaseClause(factory.createNumericLiteral(labelNumber), statements || []));
            statements = undefined;
        }
        function tryEnterLabel(operationIndex) {
            if (!labelOffsets) {
                return;
            }
            for (var label = 0; label < labelOffsets.length; label++) {
                if (labelOffsets[label] === operationIndex) {
                    flushLabel();
                    if (labelNumbers === undefined) {
                        labelNumbers = [];
                    }
                    if (labelNumbers[labelNumber] === undefined) {
                        labelNumbers[labelNumber] = [label];
                    }
                    else {
                        labelNumbers[labelNumber].push(label);
                    }
                }
            }
        }
        function updateLabelExpressions() {
            if (labelExpressions !== undefined && labelNumbers !== undefined) {
                for (var labelNumber_1 = 0; labelNumber_1 < labelNumbers.length; labelNumber_1++) {
                    var labels = labelNumbers[labelNumber_1];
                    if (labels !== undefined) {
                        for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
                            var label = labels_1[_i];
                            var expressions = labelExpressions[label];
                            if (expressions !== undefined) {
                                for (var _a = 0, expressions_1 = expressions; _a < expressions_1.length; _a++) {
                                    var expression = expressions_1[_a];
                                    expression.text = String(labelNumber_1);
                                }
                            }
                        }
                    }
                }
            }
        }
        function tryEnterOrLeaveBlock(operationIndex) {
            if (blocks) {
                for (; blockIndex < blockActions.length && blockOffsets[blockIndex] <= operationIndex; blockIndex++) {
                    var block = blocks[blockIndex];
                    var blockAction = blockActions[blockIndex];
                    switch (block.kind) {
                        case 0:
                            if (blockAction === 0) {
                                if (!exceptionBlockStack) {
                                    exceptionBlockStack = [];
                                }
                                if (!statements) {
                                    statements = [];
                                }
                                exceptionBlockStack.push(currentExceptionBlock);
                                currentExceptionBlock = block;
                            }
                            else if (blockAction === 1) {
                                currentExceptionBlock = exceptionBlockStack.pop();
                            }
                            break;
                        case 1:
                            if (blockAction === 0) {
                                if (!withBlockStack) {
                                    withBlockStack = [];
                                }
                                withBlockStack.push(block);
                            }
                            else if (blockAction === 1) {
                                withBlockStack.pop();
                            }
                            break;
                    }
                }
            }
        }
        function writeOperation(operationIndex) {
            tryEnterLabel(operationIndex);
            tryEnterOrLeaveBlock(operationIndex);
            if (lastOperationWasAbrupt) {
                return;
            }
            lastOperationWasAbrupt = false;
            lastOperationWasCompletion = false;
            var opcode = operations[operationIndex];
            if (opcode === 0) {
                return;
            }
            else if (opcode === 10) {
                return writeEndfinally();
            }
            var args = operationArguments[operationIndex];
            if (opcode === 1) {
                return writeStatement(args[0]);
            }
            var location = operationLocations[operationIndex];
            switch (opcode) {
                case 2:
                    return writeAssign(args[0], args[1], location);
                case 3:
                    return writeBreak(args[0], location);
                case 4:
                    return writeBreakWhenTrue(args[0], args[1], location);
                case 5:
                    return writeBreakWhenFalse(args[0], args[1], location);
                case 6:
                    return writeYield(args[0], location);
                case 7:
                    return writeYieldStar(args[0], location);
                case 8:
                    return writeReturn(args[0], location);
                case 9:
                    return writeThrow(args[0], location);
            }
        }
        function writeStatement(statement) {
            if (statement) {
                if (!statements) {
                    statements = [statement];
                }
                else {
                    statements.push(statement);
                }
            }
        }
        function writeAssign(left, right, operationLocation) {
            writeStatement(ts.setTextRange(factory.createExpressionStatement(factory.createAssignment(left, right)), operationLocation));
        }
        function writeThrow(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            lastOperationWasCompletion = true;
            writeStatement(ts.setTextRange(factory.createThrowStatement(expression), operationLocation));
        }
        function writeReturn(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            lastOperationWasCompletion = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression(expression
                ? [createInstruction(2), expression]
                : [createInstruction(2)])), operationLocation), 384));
        }
        function writeBreak(label, operationLocation) {
            lastOperationWasAbrupt = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(3),
                createLabel(label)
            ])), operationLocation), 384));
        }
        function writeBreakWhenTrue(label, condition, operationLocation) {
            writeStatement(ts.setEmitFlags(factory.createIfStatement(condition, ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(3),
                createLabel(label)
            ])), operationLocation), 384)), 1));
        }
        function writeBreakWhenFalse(label, condition, operationLocation) {
            writeStatement(ts.setEmitFlags(factory.createIfStatement(factory.createLogicalNot(condition), ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(3),
                createLabel(label)
            ])), operationLocation), 384)), 1));
        }
        function writeYield(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression(expression
                ? [createInstruction(4), expression]
                : [createInstruction(4)])), operationLocation), 384));
        }
        function writeYieldStar(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(5),
                expression
            ])), operationLocation), 384));
        }
        function writeEndfinally() {
            lastOperationWasAbrupt = true;
            writeStatement(factory.createReturnStatement(factory.createArrayLiteralExpression([
                createInstruction(7)
            ])));
        }
    }
    ts.transformGenerators = transformGenerators;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformModule(context) {
        function getTransformModuleDelegate(moduleKind) {
            switch (moduleKind) {
                case ts.ModuleKind.AMD: return transformAMDModule;
                case ts.ModuleKind.UMD: return transformUMDModule;
                default: return transformCommonJSModule;
            }
        }
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, startLexicalEnvironment = context.startLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var compilerOptions = context.getCompilerOptions();
        var resolver = context.getEmitResolver();
        var host = context.getEmitHost();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var moduleKind = ts.getEmitModuleKind(compilerOptions);
        var previousOnSubstituteNode = context.onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        context.onEmitNode = onEmitNode;
        context.enableSubstitution(210);
        context.enableSubstitution(212);
        context.enableSubstitution(79);
        context.enableSubstitution(223);
        context.enableSubstitution(300);
        context.enableEmitNotification(308);
        var moduleInfoMap = [];
        var deferredExports = [];
        var currentSourceFile;
        var currentModuleInfo;
        var noSubstitution = [];
        var needUMDDynamicImportHelper;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile ||
                !(ts.isEffectiveExternalModule(node, compilerOptions) ||
                    node.transformFlags & 8388608 ||
                    (ts.isJsonSourceFile(node) && ts.hasJsonModuleEmitEnabled(compilerOptions) && ts.outFile(compilerOptions)))) {
                return node;
            }
            currentSourceFile = node;
            currentModuleInfo = ts.collectExternalModuleInfo(context, node, resolver, compilerOptions);
            moduleInfoMap[ts.getOriginalNodeId(node)] = currentModuleInfo;
            var transformModule = getTransformModuleDelegate(moduleKind);
            var updated = transformModule(node);
            currentSourceFile = undefined;
            currentModuleInfo = undefined;
            needUMDDynamicImportHelper = false;
            return updated;
        }
        function shouldEmitUnderscoreUnderscoreESModule() {
            if (!currentModuleInfo.exportEquals && ts.isExternalModule(currentSourceFile)) {
                return true;
            }
            return false;
        }
        function transformCommonJSModule(node) {
            startLexicalEnvironment();
            var statements = [];
            var ensureUseStrict = ts.getStrictOptionValue(compilerOptions, "alwaysStrict") || (!compilerOptions.noImplicitUseStrict && ts.isExternalModule(currentSourceFile));
            var statementOffset = factory.copyPrologue(node.statements, statements, ensureUseStrict && !ts.isJsonSourceFile(node), topLevelVisitor);
            if (shouldEmitUnderscoreUnderscoreESModule()) {
                ts.append(statements, createUnderscoreUnderscoreESModule());
            }
            if (ts.length(currentModuleInfo.exportedNames)) {
                var chunkSize = 50;
                for (var i = 0; i < currentModuleInfo.exportedNames.length; i += chunkSize) {
                    ts.append(statements, factory.createExpressionStatement(ts.reduceLeft(currentModuleInfo.exportedNames.slice(i, i + chunkSize), function (prev, nextId) { return factory.createAssignment(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), factory.createIdentifier(ts.idText(nextId))), prev); }, factory.createVoidZero())));
                }
            }
            ts.append(statements, ts.visitNode(currentModuleInfo.externalHelpersImportDeclaration, topLevelVisitor, ts.isStatement));
            ts.addRange(statements, ts.visitNodes(node.statements, topLevelVisitor, ts.isStatement, statementOffset));
            addExportEqualsIfNeeded(statements, false);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var updated = factory.updateSourceFile(node, ts.setTextRange(factory.createNodeArray(statements), node.statements));
            ts.addEmitHelpers(updated, context.readEmitHelpers());
            return updated;
        }
        function transformAMDModule(node) {
            var define = factory.createIdentifier("define");
            var moduleName = ts.tryGetModuleNameFromFile(factory, node, host, compilerOptions);
            var jsonSourceFile = ts.isJsonSourceFile(node) && node;
            var _a = collectAsynchronousDependencies(node, true), aliasedModuleNames = _a.aliasedModuleNames, unaliasedModuleNames = _a.unaliasedModuleNames, importAliasNames = _a.importAliasNames;
            var updated = factory.updateSourceFile(node, ts.setTextRange(factory.createNodeArray([
                factory.createExpressionStatement(factory.createCallExpression(define, undefined, __spreadArray(__spreadArray([], (moduleName ? [moduleName] : []), true), [
                    factory.createArrayLiteralExpression(jsonSourceFile ? ts.emptyArray : __spreadArray(__spreadArray([
                        factory.createStringLiteral("require"),
                        factory.createStringLiteral("exports")
                    ], aliasedModuleNames, true), unaliasedModuleNames, true)),
                    jsonSourceFile ?
                        jsonSourceFile.statements.length ? jsonSourceFile.statements[0].expression : factory.createObjectLiteralExpression() :
                        factory.createFunctionExpression(undefined, undefined, undefined, undefined, __spreadArray([
                            factory.createParameterDeclaration(undefined, undefined, "require"),
                            factory.createParameterDeclaration(undefined, undefined, "exports")
                        ], importAliasNames, true), undefined, transformAsynchronousModuleBody(node))
                ], false)))
            ]), node.statements));
            ts.addEmitHelpers(updated, context.readEmitHelpers());
            return updated;
        }
        function transformUMDModule(node) {
            var _a = collectAsynchronousDependencies(node, false), aliasedModuleNames = _a.aliasedModuleNames, unaliasedModuleNames = _a.unaliasedModuleNames, importAliasNames = _a.importAliasNames;
            var moduleName = ts.tryGetModuleNameFromFile(factory, node, host, compilerOptions);
            var umdHeader = factory.createFunctionExpression(undefined, undefined, undefined, undefined, [factory.createParameterDeclaration(undefined, undefined, "factory")], undefined, ts.setTextRange(factory.createBlock([
                factory.createIfStatement(factory.createLogicalAnd(factory.createTypeCheck(factory.createIdentifier("module"), "object"), factory.createTypeCheck(factory.createPropertyAccessExpression(factory.createIdentifier("module"), "exports"), "object")), factory.createBlock([
                    factory.createVariableStatement(undefined, [
                        factory.createVariableDeclaration("v", undefined, undefined, factory.createCallExpression(factory.createIdentifier("factory"), undefined, [
                            factory.createIdentifier("require"),
                            factory.createIdentifier("exports")
                        ]))
                    ]),
                    ts.setEmitFlags(factory.createIfStatement(factory.createStrictInequality(factory.createIdentifier("v"), factory.createIdentifier("undefined")), factory.createExpressionStatement(factory.createAssignment(factory.createPropertyAccessExpression(factory.createIdentifier("module"), "exports"), factory.createIdentifier("v")))), 1)
                ]), factory.createIfStatement(factory.createLogicalAnd(factory.createTypeCheck(factory.createIdentifier("define"), "function"), factory.createPropertyAccessExpression(factory.createIdentifier("define"), "amd")), factory.createBlock([
                    factory.createExpressionStatement(factory.createCallExpression(factory.createIdentifier("define"), undefined, __spreadArray(__spreadArray([], (moduleName ? [moduleName] : []), true), [
                        factory.createArrayLiteralExpression(__spreadArray(__spreadArray([
                            factory.createStringLiteral("require"),
                            factory.createStringLiteral("exports")
                        ], aliasedModuleNames, true), unaliasedModuleNames, true)),
                        factory.createIdentifier("factory")
                    ], false)))
                ])))
            ], true), undefined));
            var updated = factory.updateSourceFile(node, ts.setTextRange(factory.createNodeArray([
                factory.createExpressionStatement(factory.createCallExpression(umdHeader, undefined, [
                    factory.createFunctionExpression(undefined, undefined, undefined, undefined, __spreadArray([
                        factory.createParameterDeclaration(undefined, undefined, "require"),
                        factory.createParameterDeclaration(undefined, undefined, "exports")
                    ], importAliasNames, true), undefined, transformAsynchronousModuleBody(node))
                ]))
            ]), node.statements));
            ts.addEmitHelpers(updated, context.readEmitHelpers());
            return updated;
        }
        function collectAsynchronousDependencies(node, includeNonAmdDependencies) {
            var aliasedModuleNames = [];
            var unaliasedModuleNames = [];
            var importAliasNames = [];
            for (var _i = 0, _a = node.amdDependencies; _i < _a.length; _i++) {
                var amdDependency = _a[_i];
                if (amdDependency.name) {
                    aliasedModuleNames.push(factory.createStringLiteral(amdDependency.path));
                    importAliasNames.push(factory.createParameterDeclaration(undefined, undefined, amdDependency.name));
                }
                else {
                    unaliasedModuleNames.push(factory.createStringLiteral(amdDependency.path));
                }
            }
            for (var _b = 0, _c = currentModuleInfo.externalImports; _b < _c.length; _b++) {
                var importNode = _c[_b];
                var externalModuleName = ts.getExternalModuleNameLiteral(factory, importNode, currentSourceFile, host, resolver, compilerOptions);
                var importAliasName = ts.getLocalNameForExternalImport(factory, importNode, currentSourceFile);
                if (externalModuleName) {
                    if (includeNonAmdDependencies && importAliasName) {
                        ts.setEmitFlags(importAliasName, 4);
                        aliasedModuleNames.push(externalModuleName);
                        importAliasNames.push(factory.createParameterDeclaration(undefined, undefined, importAliasName));
                    }
                    else {
                        unaliasedModuleNames.push(externalModuleName);
                    }
                }
            }
            return { aliasedModuleNames: aliasedModuleNames, unaliasedModuleNames: unaliasedModuleNames, importAliasNames: importAliasNames };
        }
        function getAMDImportExpressionForImport(node) {
            if (ts.isImportEqualsDeclaration(node) || ts.isExportDeclaration(node) || !ts.getExternalModuleNameLiteral(factory, node, currentSourceFile, host, resolver, compilerOptions)) {
                return undefined;
            }
            var name = ts.getLocalNameForExternalImport(factory, node, currentSourceFile);
            var expr = getHelperExpressionForImport(node, name);
            if (expr === name) {
                return undefined;
            }
            return factory.createExpressionStatement(factory.createAssignment(name, expr));
        }
        function transformAsynchronousModuleBody(node) {
            startLexicalEnvironment();
            var statements = [];
            var statementOffset = factory.copyPrologue(node.statements, statements, !compilerOptions.noImplicitUseStrict, topLevelVisitor);
            if (shouldEmitUnderscoreUnderscoreESModule()) {
                ts.append(statements, createUnderscoreUnderscoreESModule());
            }
            if (ts.length(currentModuleInfo.exportedNames)) {
                ts.append(statements, factory.createExpressionStatement(ts.reduceLeft(currentModuleInfo.exportedNames, function (prev, nextId) { return factory.createAssignment(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), factory.createIdentifier(ts.idText(nextId))), prev); }, factory.createVoidZero())));
            }
            ts.append(statements, ts.visitNode(currentModuleInfo.externalHelpersImportDeclaration, topLevelVisitor, ts.isStatement));
            if (moduleKind === ts.ModuleKind.AMD) {
                ts.addRange(statements, ts.mapDefined(currentModuleInfo.externalImports, getAMDImportExpressionForImport));
            }
            ts.addRange(statements, ts.visitNodes(node.statements, topLevelVisitor, ts.isStatement, statementOffset));
            addExportEqualsIfNeeded(statements, true);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var body = factory.createBlock(statements, true);
            if (needUMDDynamicImportHelper) {
                ts.addEmitHelper(body, dynamicImportUMDHelper);
            }
            return body;
        }
        function addExportEqualsIfNeeded(statements, emitAsReturn) {
            if (currentModuleInfo.exportEquals) {
                var expressionResult = ts.visitNode(currentModuleInfo.exportEquals.expression, visitor);
                if (expressionResult) {
                    if (emitAsReturn) {
                        var statement = factory.createReturnStatement(expressionResult);
                        ts.setTextRange(statement, currentModuleInfo.exportEquals);
                        ts.setEmitFlags(statement, 384 | 1536);
                        statements.push(statement);
                    }
                    else {
                        var statement = factory.createExpressionStatement(factory.createAssignment(factory.createPropertyAccessExpression(factory.createIdentifier("module"), "exports"), expressionResult));
                        ts.setTextRange(statement, currentModuleInfo.exportEquals);
                        ts.setEmitFlags(statement, 1536);
                        statements.push(statement);
                    }
                }
            }
        }
        function topLevelVisitor(node) {
            switch (node.kind) {
                case 269:
                    return visitImportDeclaration(node);
                case 268:
                    return visitImportEqualsDeclaration(node);
                case 275:
                    return visitExportDeclaration(node);
                case 274:
                    return visitExportAssignment(node);
                case 240:
                    return visitVariableStatement(node);
                case 259:
                    return visitFunctionDeclaration(node);
                case 260:
                    return visitClassDeclaration(node);
                case 355:
                    return visitMergeDeclarationMarker(node);
                case 356:
                    return visitEndOfDeclarationMarker(node);
                default:
                    return visitor(node);
            }
        }
        function visitorWorker(node, valueIsDiscarded) {
            if (!(node.transformFlags & (8388608 | 4096 | 268435456))) {
                return node;
            }
            switch (node.kind) {
                case 245:
                    return visitForStatement(node);
                case 241:
                    return visitExpressionStatement(node);
                case 214:
                    return visitParenthesizedExpression(node, valueIsDiscarded);
                case 353:
                    return visitPartiallyEmittedExpression(node, valueIsDiscarded);
                case 210:
                    if (ts.isImportCall(node) && currentSourceFile.impliedNodeFormat === undefined) {
                        return visitImportCallExpression(node);
                    }
                    break;
                case 223:
                    if (ts.isDestructuringAssignment(node)) {
                        return visitDestructuringAssignment(node, valueIsDiscarded);
                    }
                    break;
                case 221:
                case 222:
                    return visitPreOrPostfixUnaryExpression(node, valueIsDiscarded);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            return visitorWorker(node, false);
        }
        function discardedValueVisitor(node) {
            return visitorWorker(node, true);
        }
        function destructuringNeedsFlattening(node) {
            if (ts.isObjectLiteralExpression(node)) {
                for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
                    var elem = _a[_i];
                    switch (elem.kind) {
                        case 299:
                            if (destructuringNeedsFlattening(elem.initializer)) {
                                return true;
                            }
                            break;
                        case 300:
                            if (destructuringNeedsFlattening(elem.name)) {
                                return true;
                            }
                            break;
                        case 301:
                            if (destructuringNeedsFlattening(elem.expression)) {
                                return true;
                            }
                            break;
                        case 171:
                        case 174:
                        case 175:
                            return false;
                        default: ts.Debug.assertNever(elem, "Unhandled object member kind");
                    }
                }
            }
            else if (ts.isArrayLiteralExpression(node)) {
                for (var _b = 0, _c = node.elements; _b < _c.length; _b++) {
                    var elem = _c[_b];
                    if (ts.isSpreadElement(elem)) {
                        if (destructuringNeedsFlattening(elem.expression)) {
                            return true;
                        }
                    }
                    else if (destructuringNeedsFlattening(elem)) {
                        return true;
                    }
                }
            }
            else if (ts.isIdentifier(node)) {
                return ts.length(getExports(node)) > (ts.isExportName(node) ? 1 : 0);
            }
            return false;
        }
        function visitDestructuringAssignment(node, valueIsDiscarded) {
            if (destructuringNeedsFlattening(node.left)) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 0, !valueIsDiscarded, createAllExportExpressions);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, discardedValueVisitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, discardedValueVisitor, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
        }
        function visitExpressionStatement(node) {
            return factory.updateExpressionStatement(node, ts.visitNode(node.expression, discardedValueVisitor, ts.isExpression));
        }
        function visitParenthesizedExpression(node, valueIsDiscarded) {
            return factory.updateParenthesizedExpression(node, ts.visitNode(node.expression, valueIsDiscarded ? discardedValueVisitor : visitor, ts.isExpression));
        }
        function visitPartiallyEmittedExpression(node, valueIsDiscarded) {
            return factory.updatePartiallyEmittedExpression(node, ts.visitNode(node.expression, valueIsDiscarded ? discardedValueVisitor : visitor, ts.isExpression));
        }
        function visitPreOrPostfixUnaryExpression(node, valueIsDiscarded) {
            if ((node.operator === 45 || node.operator === 46)
                && ts.isIdentifier(node.operand)
                && !ts.isGeneratedIdentifier(node.operand)
                && !ts.isLocalName(node.operand)
                && !ts.isDeclarationNameOfEnumOrNamespace(node.operand)) {
                var exportedNames = getExports(node.operand);
                if (exportedNames) {
                    var temp = void 0;
                    var expression = ts.visitNode(node.operand, visitor, ts.isExpression);
                    if (ts.isPrefixUnaryExpression(node)) {
                        expression = factory.updatePrefixUnaryExpression(node, expression);
                    }
                    else {
                        expression = factory.updatePostfixUnaryExpression(node, expression);
                        if (!valueIsDiscarded) {
                            temp = factory.createTempVariable(hoistVariableDeclaration);
                            expression = factory.createAssignment(temp, expression);
                            ts.setTextRange(expression, node);
                        }
                        expression = factory.createComma(expression, factory.cloneNode(node.operand));
                        ts.setTextRange(expression, node);
                    }
                    for (var _i = 0, exportedNames_1 = exportedNames; _i < exportedNames_1.length; _i++) {
                        var exportName = exportedNames_1[_i];
                        noSubstitution[ts.getNodeId(expression)] = true;
                        expression = createExportExpression(exportName, expression);
                        ts.setTextRange(expression, node);
                    }
                    if (temp) {
                        noSubstitution[ts.getNodeId(expression)] = true;
                        expression = factory.createComma(expression, temp);
                        ts.setTextRange(expression, node);
                    }
                    return expression;
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitImportCallExpression(node) {
            var externalModuleName = ts.getExternalModuleNameLiteral(factory, node, currentSourceFile, host, resolver, compilerOptions);
            var firstArgument = ts.visitNode(ts.firstOrUndefined(node.arguments), visitor);
            var argument = externalModuleName && (!firstArgument || !ts.isStringLiteral(firstArgument) || firstArgument.text !== externalModuleName.text) ? externalModuleName : firstArgument;
            var containsLexicalThis = !!(node.transformFlags & 16384);
            switch (compilerOptions.module) {
                case ts.ModuleKind.AMD:
                    return createImportCallExpressionAMD(argument, containsLexicalThis);
                case ts.ModuleKind.UMD:
                    return createImportCallExpressionUMD(argument !== null && argument !== void 0 ? argument : factory.createVoidZero(), containsLexicalThis);
                case ts.ModuleKind.CommonJS:
                default:
                    return createImportCallExpressionCommonJS(argument);
            }
        }
        function createImportCallExpressionUMD(arg, containsLexicalThis) {
            needUMDDynamicImportHelper = true;
            if (ts.isSimpleCopiableExpression(arg)) {
                var argClone = ts.isGeneratedIdentifier(arg) ? arg : ts.isStringLiteral(arg) ? factory.createStringLiteralFromNode(arg) : ts.setEmitFlags(ts.setTextRange(factory.cloneNode(arg), arg), 1536);
                return factory.createConditionalExpression(factory.createIdentifier("__syncRequire"), undefined, createImportCallExpressionCommonJS(arg), undefined, createImportCallExpressionAMD(argClone, containsLexicalThis));
            }
            else {
                var temp = factory.createTempVariable(hoistVariableDeclaration);
                return factory.createComma(factory.createAssignment(temp, arg), factory.createConditionalExpression(factory.createIdentifier("__syncRequire"), undefined, createImportCallExpressionCommonJS(temp, true), undefined, createImportCallExpressionAMD(temp, containsLexicalThis)));
            }
        }
        function createImportCallExpressionAMD(arg, containsLexicalThis) {
            var resolve = factory.createUniqueName("resolve");
            var reject = factory.createUniqueName("reject");
            var parameters = [
                factory.createParameterDeclaration(undefined, undefined, resolve),
                factory.createParameterDeclaration(undefined, undefined, reject)
            ];
            var body = factory.createBlock([
                factory.createExpressionStatement(factory.createCallExpression(factory.createIdentifier("require"), undefined, [factory.createArrayLiteralExpression([arg || factory.createOmittedExpression()]), resolve, reject]))
            ]);
            var func;
            if (languageVersion >= 2) {
                func = factory.createArrowFunction(undefined, undefined, parameters, undefined, undefined, body);
            }
            else {
                func = factory.createFunctionExpression(undefined, undefined, undefined, undefined, parameters, undefined, body);
                if (containsLexicalThis) {
                    ts.setEmitFlags(func, 8);
                }
            }
            var promise = factory.createNewExpression(factory.createIdentifier("Promise"), undefined, [func]);
            if (ts.getESModuleInterop(compilerOptions)) {
                return factory.createCallExpression(factory.createPropertyAccessExpression(promise, factory.createIdentifier("then")), undefined, [emitHelpers().createImportStarCallbackHelper()]);
            }
            return promise;
        }
        function createImportCallExpressionCommonJS(arg, isInlineable) {
            var temp = arg && !ts.isSimpleInlineableExpression(arg) && !isInlineable ? factory.createTempVariable(hoistVariableDeclaration) : undefined;
            var promiseResolveCall = factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Promise"), "resolve"), undefined, []);
            var requireCall = factory.createCallExpression(factory.createIdentifier("require"), undefined, temp ? [temp] : arg ? [arg] : []);
            if (ts.getESModuleInterop(compilerOptions)) {
                requireCall = emitHelpers().createImportStarHelper(requireCall);
            }
            var func;
            if (languageVersion >= 2) {
                func = factory.createArrowFunction(undefined, undefined, [], undefined, undefined, requireCall);
            }
            else {
                func = factory.createFunctionExpression(undefined, undefined, undefined, undefined, [], undefined, factory.createBlock([factory.createReturnStatement(requireCall)]));
            }
            var downleveledImport = factory.createCallExpression(factory.createPropertyAccessExpression(promiseResolveCall, "then"), undefined, [func]);
            return temp === undefined ? downleveledImport : factory.createCommaListExpression([factory.createAssignment(temp, arg), downleveledImport]);
        }
        function getHelperExpressionForExport(node, innerExpr) {
            if (!ts.getESModuleInterop(compilerOptions) || ts.getEmitFlags(node) & 67108864) {
                return innerExpr;
            }
            if (ts.getExportNeedsImportStarHelper(node)) {
                return emitHelpers().createImportStarHelper(innerExpr);
            }
            return innerExpr;
        }
        function getHelperExpressionForImport(node, innerExpr) {
            if (!ts.getESModuleInterop(compilerOptions) || ts.getEmitFlags(node) & 67108864) {
                return innerExpr;
            }
            if (ts.getImportNeedsImportStarHelper(node)) {
                return emitHelpers().createImportStarHelper(innerExpr);
            }
            if (ts.getImportNeedsImportDefaultHelper(node)) {
                return emitHelpers().createImportDefaultHelper(innerExpr);
            }
            return innerExpr;
        }
        function visitImportDeclaration(node) {
            var statements;
            var namespaceDeclaration = ts.getNamespaceDeclarationNode(node);
            if (moduleKind !== ts.ModuleKind.AMD) {
                if (!node.importClause) {
                    return ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(createRequireCall(node)), node), node);
                }
                else {
                    var variables = [];
                    if (namespaceDeclaration && !ts.isDefaultImport(node)) {
                        variables.push(factory.createVariableDeclaration(factory.cloneNode(namespaceDeclaration.name), undefined, undefined, getHelperExpressionForImport(node, createRequireCall(node))));
                    }
                    else {
                        variables.push(factory.createVariableDeclaration(factory.getGeneratedNameForNode(node), undefined, undefined, getHelperExpressionForImport(node, createRequireCall(node))));
                        if (namespaceDeclaration && ts.isDefaultImport(node)) {
                            variables.push(factory.createVariableDeclaration(factory.cloneNode(namespaceDeclaration.name), undefined, undefined, factory.getGeneratedNameForNode(node)));
                        }
                    }
                    statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createVariableStatement(undefined, factory.createVariableDeclarationList(variables, languageVersion >= 2 ? 2 : 0)), node), node));
                }
            }
            else if (namespaceDeclaration && ts.isDefaultImport(node)) {
                statements = ts.append(statements, factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                    ts.setOriginalNode(ts.setTextRange(factory.createVariableDeclaration(factory.cloneNode(namespaceDeclaration.name), undefined, undefined, factory.getGeneratedNameForNode(node)), node), node)
                ], languageVersion >= 2 ? 2 : 0)));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfImportDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function createRequireCall(importNode) {
            var moduleName = ts.getExternalModuleNameLiteral(factory, importNode, currentSourceFile, host, resolver, compilerOptions);
            var args = [];
            if (moduleName) {
                args.push(moduleName);
            }
            return factory.createCallExpression(factory.createIdentifier("require"), undefined, args);
        }
        function visitImportEqualsDeclaration(node) {
            ts.Debug.assert(ts.isExternalModuleImportEqualsDeclaration(node), "import= for internal module references should be handled in an earlier transformer.");
            var statements;
            if (moduleKind !== ts.ModuleKind.AMD) {
                if (ts.hasSyntacticModifier(node, 1)) {
                    statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(createExportExpression(node.name, createRequireCall(node))), node), node));
                }
                else {
                    statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                        factory.createVariableDeclaration(factory.cloneNode(node.name), undefined, undefined, createRequireCall(node))
                    ], languageVersion >= 2 ? 2 : 0)), node), node));
                }
            }
            else {
                if (ts.hasSyntacticModifier(node, 1)) {
                    statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(createExportExpression(factory.getExportName(node), factory.getLocalName(node))), node), node));
                }
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfImportEqualsDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitExportDeclaration(node) {
            if (!node.moduleSpecifier) {
                return undefined;
            }
            var generatedName = factory.getGeneratedNameForNode(node);
            if (node.exportClause && ts.isNamedExports(node.exportClause)) {
                var statements = [];
                if (moduleKind !== ts.ModuleKind.AMD) {
                    statements.push(ts.setOriginalNode(ts.setTextRange(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                        factory.createVariableDeclaration(generatedName, undefined, undefined, createRequireCall(node))
                    ])), node), node));
                }
                for (var _i = 0, _a = node.exportClause.elements; _i < _a.length; _i++) {
                    var specifier = _a[_i];
                    if (languageVersion === 0) {
                        statements.push(ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(emitHelpers().createCreateBindingHelper(generatedName, factory.createStringLiteralFromNode(specifier.propertyName || specifier.name), specifier.propertyName ? factory.createStringLiteralFromNode(specifier.name) : undefined)), specifier), specifier));
                    }
                    else {
                        var exportNeedsImportDefault = !!ts.getESModuleInterop(compilerOptions) &&
                            !(ts.getEmitFlags(node) & 67108864) &&
                            ts.idText(specifier.propertyName || specifier.name) === "default";
                        var exportedValue = factory.createPropertyAccessExpression(exportNeedsImportDefault ? emitHelpers().createImportDefaultHelper(generatedName) : generatedName, specifier.propertyName || specifier.name);
                        statements.push(ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(createExportExpression(factory.getExportName(specifier), exportedValue, undefined, true)), specifier), specifier));
                    }
                }
                return ts.singleOrMany(statements);
            }
            else if (node.exportClause) {
                var statements = [];
                statements.push(ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(createExportExpression(factory.cloneNode(node.exportClause.name), getHelperExpressionForExport(node, moduleKind !== ts.ModuleKind.AMD ?
                    createRequireCall(node) :
                    ts.isExportNamespaceAsDefaultDeclaration(node) ? generatedName :
                        factory.createIdentifier(ts.idText(node.exportClause.name))))), node), node));
                return ts.singleOrMany(statements);
            }
            else {
                return ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(emitHelpers().createExportStarHelper(moduleKind !== ts.ModuleKind.AMD ? createRequireCall(node) : generatedName)), node), node);
            }
        }
        function visitExportAssignment(node) {
            if (node.isExportEquals) {
                return undefined;
            }
            var statements;
            var original = node.original;
            if (original && hasAssociatedEndOfDeclarationMarker(original)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportStatement(deferredExports[id], factory.createIdentifier("default"), ts.visitNode(node.expression, visitor), node, true);
            }
            else {
                statements = appendExportStatement(statements, factory.createIdentifier("default"), ts.visitNode(node.expression, visitor), node, true);
            }
            return ts.singleOrMany(statements);
        }
        function visitFunctionDeclaration(node) {
            var statements;
            if (ts.hasSyntacticModifier(node, 1)) {
                statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createFunctionDeclaration(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, factory.getDeclarationName(node, true, true), undefined, ts.visitNodes(node.parameters, visitor), undefined, ts.visitEachChild(node.body, visitor, context)), node), node));
            }
            else {
                statements = ts.append(statements, ts.visitEachChild(node, visitor, context));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfHoistedDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitClassDeclaration(node) {
            var statements;
            if (ts.hasSyntacticModifier(node, 1)) {
                statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createClassDeclaration(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifierLike), factory.getDeclarationName(node, true, true), undefined, ts.visitNodes(node.heritageClauses, visitor), ts.visitNodes(node.members, visitor)), node), node));
            }
            else {
                statements = ts.append(statements, ts.visitEachChild(node, visitor, context));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfHoistedDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitVariableStatement(node) {
            var statements;
            var variables;
            var expressions;
            if (ts.hasSyntacticModifier(node, 1)) {
                var modifiers = void 0;
                var removeCommentsOnExpressions = false;
                for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    if (ts.isIdentifier(variable.name) && ts.isLocalName(variable.name)) {
                        if (!modifiers) {
                            modifiers = ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier);
                        }
                        variables = ts.append(variables, variable);
                    }
                    else if (variable.initializer) {
                        if (!ts.isBindingPattern(variable.name) && (ts.isArrowFunction(variable.initializer) || ts.isFunctionExpression(variable.initializer) || ts.isClassExpression(variable.initializer))) {
                            var expression = factory.createAssignment(ts.setTextRange(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), variable.name), variable.name), factory.createIdentifier(ts.getTextOfIdentifierOrLiteral(variable.name)));
                            var updatedVariable = factory.createVariableDeclaration(variable.name, variable.exclamationToken, variable.type, ts.visitNode(variable.initializer, visitor));
                            variables = ts.append(variables, updatedVariable);
                            expressions = ts.append(expressions, expression);
                            removeCommentsOnExpressions = true;
                        }
                        else {
                            expressions = ts.append(expressions, transformInitializedVariable(variable));
                        }
                    }
                }
                if (variables) {
                    statements = ts.append(statements, factory.updateVariableStatement(node, modifiers, factory.updateVariableDeclarationList(node.declarationList, variables)));
                }
                if (expressions) {
                    var statement = ts.setOriginalNode(ts.setTextRange(factory.createExpressionStatement(factory.inlineExpressions(expressions)), node), node);
                    if (removeCommentsOnExpressions) {
                        ts.removeAllComments(statement);
                    }
                    statements = ts.append(statements, statement);
                }
            }
            else {
                statements = ts.append(statements, ts.visitEachChild(node, visitor, context));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfVariableStatement(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function createAllExportExpressions(name, value, location) {
            var exportedNames = getExports(name);
            if (exportedNames) {
                var expression = ts.isExportName(name) ? value : factory.createAssignment(name, value);
                for (var _i = 0, exportedNames_2 = exportedNames; _i < exportedNames_2.length; _i++) {
                    var exportName = exportedNames_2[_i];
                    ts.setEmitFlags(expression, 4);
                    expression = createExportExpression(exportName, expression, location);
                }
                return expression;
            }
            return factory.createAssignment(name, value);
        }
        function transformInitializedVariable(node) {
            if (ts.isBindingPattern(node.name)) {
                return ts.flattenDestructuringAssignment(ts.visitNode(node, visitor), undefined, context, 0, false, createAllExportExpressions);
            }
            else {
                return factory.createAssignment(ts.setTextRange(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), node.name), node.name), node.initializer ? ts.visitNode(node.initializer, visitor) : factory.createVoidZero());
            }
        }
        function visitMergeDeclarationMarker(node) {
            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === 240) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node.original);
            }
            return node;
        }
        function hasAssociatedEndOfDeclarationMarker(node) {
            return (ts.getEmitFlags(node) & 4194304) !== 0;
        }
        function visitEndOfDeclarationMarker(node) {
            var id = ts.getOriginalNodeId(node);
            var statements = deferredExports[id];
            if (statements) {
                delete deferredExports[id];
                return ts.append(statements, node);
            }
            return node;
        }
        function appendExportsOfImportDeclaration(statements, decl) {
            if (currentModuleInfo.exportEquals) {
                return statements;
            }
            var importClause = decl.importClause;
            if (!importClause) {
                return statements;
            }
            if (importClause.name) {
                statements = appendExportsOfDeclaration(statements, importClause);
            }
            var namedBindings = importClause.namedBindings;
            if (namedBindings) {
                switch (namedBindings.kind) {
                    case 271:
                        statements = appendExportsOfDeclaration(statements, namedBindings);
                        break;
                    case 272:
                        for (var _i = 0, _a = namedBindings.elements; _i < _a.length; _i++) {
                            var importBinding = _a[_i];
                            statements = appendExportsOfDeclaration(statements, importBinding, true);
                        }
                        break;
                }
            }
            return statements;
        }
        function appendExportsOfImportEqualsDeclaration(statements, decl) {
            if (currentModuleInfo.exportEquals) {
                return statements;
            }
            return appendExportsOfDeclaration(statements, decl);
        }
        function appendExportsOfVariableStatement(statements, node) {
            if (currentModuleInfo.exportEquals) {
                return statements;
            }
            for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                var decl = _a[_i];
                statements = appendExportsOfBindingElement(statements, decl);
            }
            return statements;
        }
        function appendExportsOfBindingElement(statements, decl) {
            if (currentModuleInfo.exportEquals) {
                return statements;
            }
            if (ts.isBindingPattern(decl.name)) {
                for (var _i = 0, _a = decl.name.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (!ts.isOmittedExpression(element)) {
                        statements = appendExportsOfBindingElement(statements, element);
                    }
                }
            }
            else if (!ts.isGeneratedIdentifier(decl.name)) {
                statements = appendExportsOfDeclaration(statements, decl);
            }
            return statements;
        }
        function appendExportsOfHoistedDeclaration(statements, decl) {
            if (currentModuleInfo.exportEquals) {
                return statements;
            }
            if (ts.hasSyntacticModifier(decl, 1)) {
                var exportName = ts.hasSyntacticModifier(decl, 1024) ? factory.createIdentifier("default") : factory.getDeclarationName(decl);
                statements = appendExportStatement(statements, exportName, factory.getLocalName(decl), decl);
            }
            if (decl.name) {
                statements = appendExportsOfDeclaration(statements, decl);
            }
            return statements;
        }
        function appendExportsOfDeclaration(statements, decl, liveBinding) {
            var name = factory.getDeclarationName(decl);
            var exportSpecifiers = currentModuleInfo.exportSpecifiers.get(ts.idText(name));
            if (exportSpecifiers) {
                for (var _i = 0, exportSpecifiers_1 = exportSpecifiers; _i < exportSpecifiers_1.length; _i++) {
                    var exportSpecifier = exportSpecifiers_1[_i];
                    statements = appendExportStatement(statements, exportSpecifier.name, name, exportSpecifier.name, undefined, liveBinding);
                }
            }
            return statements;
        }
        function appendExportStatement(statements, exportName, expression, location, allowComments, liveBinding) {
            statements = ts.append(statements, createExportStatement(exportName, expression, location, allowComments, liveBinding));
            return statements;
        }
        function createUnderscoreUnderscoreESModule() {
            var statement;
            if (languageVersion === 0) {
                statement = factory.createExpressionStatement(createExportExpression(factory.createIdentifier("__esModule"), factory.createTrue()));
            }
            else {
                statement = factory.createExpressionStatement(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "defineProperty"), undefined, [
                    factory.createIdentifier("exports"),
                    factory.createStringLiteral("__esModule"),
                    factory.createObjectLiteralExpression([
                        factory.createPropertyAssignment("value", factory.createTrue())
                    ])
                ]));
            }
            ts.setEmitFlags(statement, 1048576);
            return statement;
        }
        function createExportStatement(name, value, location, allowComments, liveBinding) {
            var statement = ts.setTextRange(factory.createExpressionStatement(createExportExpression(name, value, undefined, liveBinding)), location);
            ts.startOnNewLine(statement);
            if (!allowComments) {
                ts.setEmitFlags(statement, 1536);
            }
            return statement;
        }
        function createExportExpression(name, value, location, liveBinding) {
            return ts.setTextRange(liveBinding && languageVersion !== 0 ? factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "defineProperty"), undefined, [
                factory.createIdentifier("exports"),
                factory.createStringLiteralFromNode(name),
                factory.createObjectLiteralExpression([
                    factory.createPropertyAssignment("enumerable", factory.createTrue()),
                    factory.createPropertyAssignment("get", factory.createFunctionExpression(undefined, undefined, undefined, undefined, [], undefined, factory.createBlock([factory.createReturnStatement(value)])))
                ])
            ]) : factory.createAssignment(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), factory.cloneNode(name)), value), location);
        }
        function modifierVisitor(node) {
            switch (node.kind) {
                case 93:
                case 88:
                    return undefined;
            }
            return node;
        }
        function onEmitNode(hint, node, emitCallback) {
            if (node.kind === 308) {
                currentSourceFile = node;
                currentModuleInfo = moduleInfoMap[ts.getOriginalNodeId(currentSourceFile)];
                previousOnEmitNode(hint, node, emitCallback);
                currentSourceFile = undefined;
                currentModuleInfo = undefined;
            }
            else {
                previousOnEmitNode(hint, node, emitCallback);
            }
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (node.id && noSubstitution[node.id]) {
                return node;
            }
            if (hint === 1) {
                return substituteExpression(node);
            }
            else if (ts.isShorthandPropertyAssignment(node)) {
                return substituteShorthandPropertyAssignment(node);
            }
            return node;
        }
        function substituteShorthandPropertyAssignment(node) {
            var name = node.name;
            var exportedOrImportedName = substituteExpressionIdentifier(name);
            if (exportedOrImportedName !== name) {
                if (node.objectAssignmentInitializer) {
                    var initializer = factory.createAssignment(exportedOrImportedName, node.objectAssignmentInitializer);
                    return ts.setTextRange(factory.createPropertyAssignment(name, initializer), node);
                }
                return ts.setTextRange(factory.createPropertyAssignment(name, exportedOrImportedName), node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79:
                    return substituteExpressionIdentifier(node);
                case 210:
                    return substituteCallExpression(node);
                case 212:
                    return substituteTaggedTemplateExpression(node);
                case 223:
                    return substituteBinaryExpression(node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            if (ts.isIdentifier(node.expression)) {
                var expression = substituteExpressionIdentifier(node.expression);
                noSubstitution[ts.getNodeId(expression)] = true;
                if (!ts.isIdentifier(expression) && !(ts.getEmitFlags(node.expression) & 4096)) {
                    return ts.addEmitFlags(factory.updateCallExpression(node, expression, undefined, node.arguments), 536870912);
                }
            }
            return node;
        }
        function substituteTaggedTemplateExpression(node) {
            if (ts.isIdentifier(node.tag)) {
                var tag = substituteExpressionIdentifier(node.tag);
                noSubstitution[ts.getNodeId(tag)] = true;
                if (!ts.isIdentifier(tag) && !(ts.getEmitFlags(node.tag) & 4096)) {
                    return ts.addEmitFlags(factory.updateTaggedTemplateExpression(node, tag, undefined, node.template), 536870912);
                }
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            var _a, _b;
            if (ts.getEmitFlags(node) & 4096) {
                var externalHelpersModuleName = ts.getExternalHelpersModuleName(currentSourceFile);
                if (externalHelpersModuleName) {
                    return factory.createPropertyAccessExpression(externalHelpersModuleName, node);
                }
                return node;
            }
            else if (!(ts.isGeneratedIdentifier(node) && !(node.autoGenerateFlags & 64)) && !ts.isLocalName(node)) {
                var exportContainer = resolver.getReferencedExportContainer(node, ts.isExportName(node));
                if (exportContainer && exportContainer.kind === 308) {
                    return ts.setTextRange(factory.createPropertyAccessExpression(factory.createIdentifier("exports"), factory.cloneNode(node)), node);
                }
                var importDeclaration = resolver.getReferencedImportDeclaration(node);
                if (importDeclaration) {
                    if (ts.isImportClause(importDeclaration)) {
                        return ts.setTextRange(factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(importDeclaration.parent), factory.createIdentifier("default")), node);
                    }
                    else if (ts.isImportSpecifier(importDeclaration)) {
                        var name = importDeclaration.propertyName || importDeclaration.name;
                        return ts.setTextRange(factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(((_b = (_a = importDeclaration.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent) || importDeclaration), factory.cloneNode(name)), node);
                    }
                }
            }
            return node;
        }
        function substituteBinaryExpression(node) {
            if (ts.isAssignmentOperator(node.operatorToken.kind)
                && ts.isIdentifier(node.left)
                && !ts.isGeneratedIdentifier(node.left)
                && !ts.isLocalName(node.left)
                && !ts.isDeclarationNameOfEnumOrNamespace(node.left)) {
                var exportedNames = getExports(node.left);
                if (exportedNames) {
                    var expression = node;
                    for (var _i = 0, exportedNames_3 = exportedNames; _i < exportedNames_3.length; _i++) {
                        var exportName = exportedNames_3[_i];
                        noSubstitution[ts.getNodeId(expression)] = true;
                        expression = createExportExpression(exportName, expression, node);
                    }
                    return expression;
                }
            }
            return node;
        }
        function getExports(name) {
            if (!ts.isGeneratedIdentifier(name)) {
                var valueDeclaration = resolver.getReferencedImportDeclaration(name)
                    || resolver.getReferencedValueDeclaration(name);
                if (valueDeclaration) {
                    return currentModuleInfo
                        && currentModuleInfo.exportedBindings[ts.getOriginalNodeId(valueDeclaration)];
                }
            }
        }
    }
    ts.transformModule = transformModule;
    var dynamicImportUMDHelper = {
        name: "typescript:dynamicimport-sync-require",
        scoped: true,
        text: "\n            var __syncRequire = typeof module === \"object\" && typeof module.exports === \"object\";"
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformSystemModule(context) {
        var factory = context.factory, startLexicalEnvironment = context.startLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var compilerOptions = context.getCompilerOptions();
        var resolver = context.getEmitResolver();
        var host = context.getEmitHost();
        var previousOnSubstituteNode = context.onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        context.onEmitNode = onEmitNode;
        context.enableSubstitution(79);
        context.enableSubstitution(300);
        context.enableSubstitution(223);
        context.enableSubstitution(233);
        context.enableEmitNotification(308);
        var moduleInfoMap = [];
        var deferredExports = [];
        var exportFunctionsMap = [];
        var noSubstitutionMap = [];
        var contextObjectMap = [];
        var currentSourceFile;
        var moduleInfo;
        var exportFunction;
        var contextObject;
        var hoistedStatements;
        var enclosingBlockScopedContainer;
        var noSubstitution;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile || !(ts.isEffectiveExternalModule(node, compilerOptions) || node.transformFlags & 8388608)) {
                return node;
            }
            var id = ts.getOriginalNodeId(node);
            currentSourceFile = node;
            enclosingBlockScopedContainer = node;
            moduleInfo = moduleInfoMap[id] = ts.collectExternalModuleInfo(context, node, resolver, compilerOptions);
            exportFunction = factory.createUniqueName("exports");
            exportFunctionsMap[id] = exportFunction;
            contextObject = contextObjectMap[id] = factory.createUniqueName("context");
            var dependencyGroups = collectDependencyGroups(moduleInfo.externalImports);
            var moduleBodyBlock = createSystemModuleBody(node, dependencyGroups);
            var moduleBodyFunction = factory.createFunctionExpression(undefined, undefined, undefined, undefined, [
                factory.createParameterDeclaration(undefined, undefined, exportFunction),
                factory.createParameterDeclaration(undefined, undefined, contextObject)
            ], undefined, moduleBodyBlock);
            var moduleName = ts.tryGetModuleNameFromFile(factory, node, host, compilerOptions);
            var dependencies = factory.createArrayLiteralExpression(ts.map(dependencyGroups, function (dependencyGroup) { return dependencyGroup.name; }));
            var updated = ts.setEmitFlags(factory.updateSourceFile(node, ts.setTextRange(factory.createNodeArray([
                factory.createExpressionStatement(factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("System"), "register"), undefined, moduleName
                    ? [moduleName, dependencies, moduleBodyFunction]
                    : [dependencies, moduleBodyFunction]))
            ]), node.statements)), 1024);
            if (!ts.outFile(compilerOptions)) {
                ts.moveEmitHelpers(updated, moduleBodyBlock, function (helper) { return !helper.scoped; });
            }
            if (noSubstitution) {
                noSubstitutionMap[id] = noSubstitution;
                noSubstitution = undefined;
            }
            currentSourceFile = undefined;
            moduleInfo = undefined;
            exportFunction = undefined;
            contextObject = undefined;
            hoistedStatements = undefined;
            enclosingBlockScopedContainer = undefined;
            return updated;
        }
        function collectDependencyGroups(externalImports) {
            var groupIndices = new ts.Map();
            var dependencyGroups = [];
            for (var _i = 0, externalImports_1 = externalImports; _i < externalImports_1.length; _i++) {
                var externalImport = externalImports_1[_i];
                var externalModuleName = ts.getExternalModuleNameLiteral(factory, externalImport, currentSourceFile, host, resolver, compilerOptions);
                if (externalModuleName) {
                    var text = externalModuleName.text;
                    var groupIndex = groupIndices.get(text);
                    if (groupIndex !== undefined) {
                        dependencyGroups[groupIndex].externalImports.push(externalImport);
                    }
                    else {
                        groupIndices.set(text, dependencyGroups.length);
                        dependencyGroups.push({
                            name: externalModuleName,
                            externalImports: [externalImport]
                        });
                    }
                }
            }
            return dependencyGroups;
        }
        function createSystemModuleBody(node, dependencyGroups) {
            var statements = [];
            startLexicalEnvironment();
            var ensureUseStrict = ts.getStrictOptionValue(compilerOptions, "alwaysStrict") || (!compilerOptions.noImplicitUseStrict && ts.isExternalModule(currentSourceFile));
            var statementOffset = factory.copyPrologue(node.statements, statements, ensureUseStrict, topLevelVisitor);
            statements.push(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration("__moduleName", undefined, undefined, factory.createLogicalAnd(contextObject, factory.createPropertyAccessExpression(contextObject, "id")))
            ])));
            ts.visitNode(moduleInfo.externalHelpersImportDeclaration, topLevelVisitor, ts.isStatement);
            var executeStatements = ts.visitNodes(node.statements, topLevelVisitor, ts.isStatement, statementOffset);
            ts.addRange(statements, hoistedStatements);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var exportStarFunction = addExportStarIfNeeded(statements);
            var modifiers = node.transformFlags & 2097152 ?
                factory.createModifiersFromModifierFlags(512) :
                undefined;
            var moduleObject = factory.createObjectLiteralExpression([
                factory.createPropertyAssignment("setters", createSettersArray(exportStarFunction, dependencyGroups)),
                factory.createPropertyAssignment("execute", factory.createFunctionExpression(modifiers, undefined, undefined, undefined, [], undefined, factory.createBlock(executeStatements, true)))
            ], true);
            statements.push(factory.createReturnStatement(moduleObject));
            return factory.createBlock(statements, true);
        }
        function addExportStarIfNeeded(statements) {
            if (!moduleInfo.hasExportStarsToExportValues) {
                return;
            }
            if (!moduleInfo.exportedNames && moduleInfo.exportSpecifiers.size === 0) {
                var hasExportDeclarationWithExportClause = false;
                for (var _i = 0, _a = moduleInfo.externalImports; _i < _a.length; _i++) {
                    var externalImport = _a[_i];
                    if (externalImport.kind === 275 && externalImport.exportClause) {
                        hasExportDeclarationWithExportClause = true;
                        break;
                    }
                }
                if (!hasExportDeclarationWithExportClause) {
                    var exportStarFunction_1 = createExportStarFunction(undefined);
                    statements.push(exportStarFunction_1);
                    return exportStarFunction_1.name;
                }
            }
            var exportedNames = [];
            if (moduleInfo.exportedNames) {
                for (var _b = 0, _c = moduleInfo.exportedNames; _b < _c.length; _b++) {
                    var exportedLocalName = _c[_b];
                    if (exportedLocalName.escapedText === "default") {
                        continue;
                    }
                    exportedNames.push(factory.createPropertyAssignment(factory.createStringLiteralFromNode(exportedLocalName), factory.createTrue()));
                }
            }
            var exportedNamesStorageRef = factory.createUniqueName("exportedNames");
            statements.push(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration(exportedNamesStorageRef, undefined, undefined, factory.createObjectLiteralExpression(exportedNames, true))
            ])));
            var exportStarFunction = createExportStarFunction(exportedNamesStorageRef);
            statements.push(exportStarFunction);
            return exportStarFunction.name;
        }
        function createExportStarFunction(localNames) {
            var exportStarFunction = factory.createUniqueName("exportStar");
            var m = factory.createIdentifier("m");
            var n = factory.createIdentifier("n");
            var exports = factory.createIdentifier("exports");
            var condition = factory.createStrictInequality(n, factory.createStringLiteral("default"));
            if (localNames) {
                condition = factory.createLogicalAnd(condition, factory.createLogicalNot(factory.createCallExpression(factory.createPropertyAccessExpression(localNames, "hasOwnProperty"), undefined, [n])));
            }
            return factory.createFunctionDeclaration(undefined, undefined, exportStarFunction, undefined, [factory.createParameterDeclaration(undefined, undefined, m)], undefined, factory.createBlock([
                factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                    factory.createVariableDeclaration(exports, undefined, undefined, factory.createObjectLiteralExpression([]))
                ])),
                factory.createForInStatement(factory.createVariableDeclarationList([
                    factory.createVariableDeclaration(n)
                ]), m, factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(condition, factory.createExpressionStatement(factory.createAssignment(factory.createElementAccessExpression(exports, n), factory.createElementAccessExpression(m, n)))), 1)
                ])),
                factory.createExpressionStatement(factory.createCallExpression(exportFunction, undefined, [exports]))
            ], true));
        }
        function createSettersArray(exportStarFunction, dependencyGroups) {
            var setters = [];
            for (var _i = 0, dependencyGroups_1 = dependencyGroups; _i < dependencyGroups_1.length; _i++) {
                var group_2 = dependencyGroups_1[_i];
                var localName = ts.forEach(group_2.externalImports, function (i) { return ts.getLocalNameForExternalImport(factory, i, currentSourceFile); });
                var parameterName = localName ? factory.getGeneratedNameForNode(localName) : factory.createUniqueName("");
                var statements = [];
                for (var _a = 0, _b = group_2.externalImports; _a < _b.length; _a++) {
                    var entry = _b[_a];
                    var importVariableName = ts.getLocalNameForExternalImport(factory, entry, currentSourceFile);
                    switch (entry.kind) {
                        case 269:
                            if (!entry.importClause) {
                                break;
                            }
                        case 268:
                            ts.Debug.assert(importVariableName !== undefined);
                            statements.push(factory.createExpressionStatement(factory.createAssignment(importVariableName, parameterName)));
                            if (ts.hasSyntacticModifier(entry, 1)) {
                                statements.push(factory.createExpressionStatement(factory.createCallExpression(exportFunction, undefined, [
                                    factory.createStringLiteral(ts.idText(importVariableName)),
                                    parameterName,
                                ])));
                            }
                            break;
                        case 275:
                            ts.Debug.assert(importVariableName !== undefined);
                            if (entry.exportClause) {
                                if (ts.isNamedExports(entry.exportClause)) {
                                    var properties = [];
                                    for (var _c = 0, _d = entry.exportClause.elements; _c < _d.length; _c++) {
                                        var e = _d[_c];
                                        properties.push(factory.createPropertyAssignment(factory.createStringLiteral(ts.idText(e.name)), factory.createElementAccessExpression(parameterName, factory.createStringLiteral(ts.idText(e.propertyName || e.name)))));
                                    }
                                    statements.push(factory.createExpressionStatement(factory.createCallExpression(exportFunction, undefined, [factory.createObjectLiteralExpression(properties, true)])));
                                }
                                else {
                                    statements.push(factory.createExpressionStatement(factory.createCallExpression(exportFunction, undefined, [
                                        factory.createStringLiteral(ts.idText(entry.exportClause.name)),
                                        parameterName
                                    ])));
                                }
                            }
                            else {
                                statements.push(factory.createExpressionStatement(factory.createCallExpression(exportStarFunction, undefined, [parameterName])));
                            }
                            break;
                    }
                }
                setters.push(factory.createFunctionExpression(undefined, undefined, undefined, undefined, [factory.createParameterDeclaration(undefined, undefined, parameterName)], undefined, factory.createBlock(statements, true)));
            }
            return factory.createArrayLiteralExpression(setters, true);
        }
        function topLevelVisitor(node) {
            switch (node.kind) {
                case 269:
                    return visitImportDeclaration(node);
                case 268:
                    return visitImportEqualsDeclaration(node);
                case 275:
                    return visitExportDeclaration(node);
                case 274:
                    return visitExportAssignment(node);
                default:
                    return topLevelNestedVisitor(node);
            }
        }
        function visitImportDeclaration(node) {
            var statements;
            if (node.importClause) {
                hoistVariableDeclaration(ts.getLocalNameForExternalImport(factory, node, currentSourceFile));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfImportDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfImportDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitExportDeclaration(node) {
            ts.Debug.assertIsDefined(node);
            return undefined;
        }
        function visitImportEqualsDeclaration(node) {
            ts.Debug.assert(ts.isExternalModuleImportEqualsDeclaration(node), "import= for internal module references should be handled in an earlier transformer.");
            var statements;
            hoistVariableDeclaration(ts.getLocalNameForExternalImport(factory, node, currentSourceFile));
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfImportEqualsDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfImportEqualsDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitExportAssignment(node) {
            if (node.isExportEquals) {
                return undefined;
            }
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var original = node.original;
            if (original && hasAssociatedEndOfDeclarationMarker(original)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportStatement(deferredExports[id], factory.createIdentifier("default"), expression, true);
            }
            else {
                return createExportStatement(factory.createIdentifier("default"), expression, true);
            }
        }
        function visitFunctionDeclaration(node) {
            if (ts.hasSyntacticModifier(node, 1)) {
                hoistedStatements = ts.append(hoistedStatements, factory.updateFunctionDeclaration(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifierLike), node.asteriskToken, factory.getDeclarationName(node, true, true), undefined, ts.visitNodes(node.parameters, visitor, ts.isParameterDeclaration), undefined, ts.visitNode(node.body, visitor, ts.isBlock)));
            }
            else {
                hoistedStatements = ts.append(hoistedStatements, ts.visitEachChild(node, visitor, context));
            }
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);
            }
            else {
                hoistedStatements = appendExportsOfHoistedDeclaration(hoistedStatements, node);
            }
            return undefined;
        }
        function visitClassDeclaration(node) {
            var statements;
            var name = factory.getLocalName(node);
            hoistVariableDeclaration(name);
            statements = ts.append(statements, ts.setTextRange(factory.createExpressionStatement(factory.createAssignment(name, ts.setTextRange(factory.createClassExpression(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifierLike), node.name, undefined, ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause), ts.visitNodes(node.members, visitor, ts.isClassElement)), node))), node));
            if (hasAssociatedEndOfDeclarationMarker(node)) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfHoistedDeclaration(deferredExports[id], node);
            }
            else {
                statements = appendExportsOfHoistedDeclaration(statements, node);
            }
            return ts.singleOrMany(statements);
        }
        function visitVariableStatement(node) {
            if (!shouldHoistVariableDeclarationList(node.declarationList)) {
                return ts.visitNode(node, visitor, ts.isStatement);
            }
            var expressions;
            var isExportedDeclaration = ts.hasSyntacticModifier(node, 1);
            var isMarkedDeclaration = hasAssociatedEndOfDeclarationMarker(node);
            for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                var variable = _a[_i];
                if (variable.initializer) {
                    expressions = ts.append(expressions, transformInitializedVariable(variable, isExportedDeclaration && !isMarkedDeclaration));
                }
                else {
                    hoistBindingElement(variable);
                }
            }
            var statements;
            if (expressions) {
                statements = ts.append(statements, ts.setTextRange(factory.createExpressionStatement(factory.inlineExpressions(expressions)), node));
            }
            if (isMarkedDeclaration) {
                var id = ts.getOriginalNodeId(node);
                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node, isExportedDeclaration);
            }
            else {
                statements = appendExportsOfVariableStatement(statements, node, false);
            }
            return ts.singleOrMany(statements);
        }
        function hoistBindingElement(node) {
            if (ts.isBindingPattern(node.name)) {
                for (var _i = 0, _a = node.name.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (!ts.isOmittedExpression(element)) {
                        hoistBindingElement(element);
                    }
                }
            }
            else {
                hoistVariableDeclaration(factory.cloneNode(node.name));
            }
        }
        function shouldHoistVariableDeclarationList(node) {
            return (ts.getEmitFlags(node) & 2097152) === 0
                && (enclosingBlockScopedContainer.kind === 308
                    || (ts.getOriginalNode(node).flags & 3) === 0);
        }
        function transformInitializedVariable(node, isExportedDeclaration) {
            var createAssignment = isExportedDeclaration ? createExportedVariableAssignment : createNonExportedVariableAssignment;
            return ts.isBindingPattern(node.name)
                ? ts.flattenDestructuringAssignment(node, visitor, context, 0, false, createAssignment)
                : node.initializer ? createAssignment(node.name, ts.visitNode(node.initializer, visitor, ts.isExpression)) : node.name;
        }
        function createExportedVariableAssignment(name, value, location) {
            return createVariableAssignment(name, value, location, true);
        }
        function createNonExportedVariableAssignment(name, value, location) {
            return createVariableAssignment(name, value, location, false);
        }
        function createVariableAssignment(name, value, location, isExportedDeclaration) {
            hoistVariableDeclaration(factory.cloneNode(name));
            return isExportedDeclaration
                ? createExportExpression(name, preventSubstitution(ts.setTextRange(factory.createAssignment(name, value), location)))
                : preventSubstitution(ts.setTextRange(factory.createAssignment(name, value), location));
        }
        function visitMergeDeclarationMarker(node) {
            if (hasAssociatedEndOfDeclarationMarker(node) && node.original.kind === 240) {
                var id = ts.getOriginalNodeId(node);
                var isExportedDeclaration = ts.hasSyntacticModifier(node.original, 1);
                deferredExports[id] = appendExportsOfVariableStatement(deferredExports[id], node.original, isExportedDeclaration);
            }
            return node;
        }
        function hasAssociatedEndOfDeclarationMarker(node) {
            return (ts.getEmitFlags(node) & 4194304) !== 0;
        }
        function visitEndOfDeclarationMarker(node) {
            var id = ts.getOriginalNodeId(node);
            var statements = deferredExports[id];
            if (statements) {
                delete deferredExports[id];
                return ts.append(statements, node);
            }
            else {
                var original = ts.getOriginalNode(node);
                if (ts.isModuleOrEnumDeclaration(original)) {
                    return ts.append(appendExportsOfDeclaration(statements, original), node);
                }
            }
            return node;
        }
        function appendExportsOfImportDeclaration(statements, decl) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            var importClause = decl.importClause;
            if (!importClause) {
                return statements;
            }
            if (importClause.name) {
                statements = appendExportsOfDeclaration(statements, importClause);
            }
            var namedBindings = importClause.namedBindings;
            if (namedBindings) {
                switch (namedBindings.kind) {
                    case 271:
                        statements = appendExportsOfDeclaration(statements, namedBindings);
                        break;
                    case 272:
                        for (var _i = 0, _a = namedBindings.elements; _i < _a.length; _i++) {
                            var importBinding = _a[_i];
                            statements = appendExportsOfDeclaration(statements, importBinding);
                        }
                        break;
                }
            }
            return statements;
        }
        function appendExportsOfImportEqualsDeclaration(statements, decl) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            return appendExportsOfDeclaration(statements, decl);
        }
        function appendExportsOfVariableStatement(statements, node, exportSelf) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                var decl = _a[_i];
                if (decl.initializer || exportSelf) {
                    statements = appendExportsOfBindingElement(statements, decl, exportSelf);
                }
            }
            return statements;
        }
        function appendExportsOfBindingElement(statements, decl, exportSelf) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            if (ts.isBindingPattern(decl.name)) {
                for (var _i = 0, _a = decl.name.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (!ts.isOmittedExpression(element)) {
                        statements = appendExportsOfBindingElement(statements, element, exportSelf);
                    }
                }
            }
            else if (!ts.isGeneratedIdentifier(decl.name)) {
                var excludeName = void 0;
                if (exportSelf) {
                    statements = appendExportStatement(statements, decl.name, factory.getLocalName(decl));
                    excludeName = ts.idText(decl.name);
                }
                statements = appendExportsOfDeclaration(statements, decl, excludeName);
            }
            return statements;
        }
        function appendExportsOfHoistedDeclaration(statements, decl) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            var excludeName;
            if (ts.hasSyntacticModifier(decl, 1)) {
                var exportName = ts.hasSyntacticModifier(decl, 1024) ? factory.createStringLiteral("default") : decl.name;
                statements = appendExportStatement(statements, exportName, factory.getLocalName(decl));
                excludeName = ts.getTextOfIdentifierOrLiteral(exportName);
            }
            if (decl.name) {
                statements = appendExportsOfDeclaration(statements, decl, excludeName);
            }
            return statements;
        }
        function appendExportsOfDeclaration(statements, decl, excludeName) {
            if (moduleInfo.exportEquals) {
                return statements;
            }
            var name = factory.getDeclarationName(decl);
            var exportSpecifiers = moduleInfo.exportSpecifiers.get(ts.idText(name));
            if (exportSpecifiers) {
                for (var _i = 0, exportSpecifiers_2 = exportSpecifiers; _i < exportSpecifiers_2.length; _i++) {
                    var exportSpecifier = exportSpecifiers_2[_i];
                    if (exportSpecifier.name.escapedText !== excludeName) {
                        statements = appendExportStatement(statements, exportSpecifier.name, name);
                    }
                }
            }
            return statements;
        }
        function appendExportStatement(statements, exportName, expression, allowComments) {
            statements = ts.append(statements, createExportStatement(exportName, expression, allowComments));
            return statements;
        }
        function createExportStatement(name, value, allowComments) {
            var statement = factory.createExpressionStatement(createExportExpression(name, value));
            ts.startOnNewLine(statement);
            if (!allowComments) {
                ts.setEmitFlags(statement, 1536);
            }
            return statement;
        }
        function createExportExpression(name, value) {
            var exportName = ts.isIdentifier(name) ? factory.createStringLiteralFromNode(name) : name;
            ts.setEmitFlags(value, ts.getEmitFlags(value) | 1536);
            return ts.setCommentRange(factory.createCallExpression(exportFunction, undefined, [exportName, value]), value);
        }
        function topLevelNestedVisitor(node) {
            switch (node.kind) {
                case 240:
                    return visitVariableStatement(node);
                case 259:
                    return visitFunctionDeclaration(node);
                case 260:
                    return visitClassDeclaration(node);
                case 245:
                    return visitForStatement(node, true);
                case 246:
                    return visitForInStatement(node);
                case 247:
                    return visitForOfStatement(node);
                case 243:
                    return visitDoStatement(node);
                case 244:
                    return visitWhileStatement(node);
                case 253:
                    return visitLabeledStatement(node);
                case 251:
                    return visitWithStatement(node);
                case 252:
                    return visitSwitchStatement(node);
                case 266:
                    return visitCaseBlock(node);
                case 292:
                    return visitCaseClause(node);
                case 293:
                    return visitDefaultClause(node);
                case 255:
                    return visitTryStatement(node);
                case 295:
                    return visitCatchClause(node);
                case 238:
                    return visitBlock(node);
                case 355:
                    return visitMergeDeclarationMarker(node);
                case 356:
                    return visitEndOfDeclarationMarker(node);
                default:
                    return visitor(node);
            }
        }
        function visitForStatement(node, isTopLevel) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = factory.updateForStatement(node, ts.visitNode(node.initializer, isTopLevel ? visitForInitializer : discardedValueVisitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, discardedValueVisitor, ts.isExpression), ts.visitIterationBody(node.statement, isTopLevel ? topLevelNestedVisitor : visitor, context));
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function visitForInStatement(node) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = factory.updateForInStatement(node, visitForInitializer(node.initializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, topLevelNestedVisitor, context));
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function visitForOfStatement(node) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = factory.updateForOfStatement(node, node.awaitModifier, visitForInitializer(node.initializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, topLevelNestedVisitor, context));
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function shouldHoistForInitializer(node) {
            return ts.isVariableDeclarationList(node)
                && shouldHoistVariableDeclarationList(node);
        }
        function visitForInitializer(node) {
            if (shouldHoistForInitializer(node)) {
                var expressions = void 0;
                for (var _i = 0, _a = node.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    expressions = ts.append(expressions, transformInitializedVariable(variable, false));
                    if (!variable.initializer) {
                        hoistBindingElement(variable);
                    }
                }
                return expressions ? factory.inlineExpressions(expressions) : factory.createOmittedExpression();
            }
            else {
                return ts.visitNode(node, discardedValueVisitor, ts.isExpression);
            }
        }
        function visitDoStatement(node) {
            return factory.updateDoStatement(node, ts.visitIterationBody(node.statement, topLevelNestedVisitor, context), ts.visitNode(node.expression, visitor, ts.isExpression));
        }
        function visitWhileStatement(node) {
            return factory.updateWhileStatement(node, ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, topLevelNestedVisitor, context));
        }
        function visitLabeledStatement(node) {
            return factory.updateLabeledStatement(node, node.label, ts.visitNode(node.statement, topLevelNestedVisitor, ts.isStatement, factory.liftToBlock));
        }
        function visitWithStatement(node) {
            return factory.updateWithStatement(node, ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitNode(node.statement, topLevelNestedVisitor, ts.isStatement, factory.liftToBlock));
        }
        function visitSwitchStatement(node) {
            return factory.updateSwitchStatement(node, ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitNode(node.caseBlock, topLevelNestedVisitor, ts.isCaseBlock));
        }
        function visitCaseBlock(node) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = factory.updateCaseBlock(node, ts.visitNodes(node.clauses, topLevelNestedVisitor, ts.isCaseOrDefaultClause));
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function visitCaseClause(node) {
            return factory.updateCaseClause(node, ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitNodes(node.statements, topLevelNestedVisitor, ts.isStatement));
        }
        function visitDefaultClause(node) {
            return ts.visitEachChild(node, topLevelNestedVisitor, context);
        }
        function visitTryStatement(node) {
            return ts.visitEachChild(node, topLevelNestedVisitor, context);
        }
        function visitCatchClause(node) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = factory.updateCatchClause(node, node.variableDeclaration, ts.visitNode(node.block, topLevelNestedVisitor, ts.isBlock));
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function visitBlock(node) {
            var savedEnclosingBlockScopedContainer = enclosingBlockScopedContainer;
            enclosingBlockScopedContainer = node;
            node = ts.visitEachChild(node, topLevelNestedVisitor, context);
            enclosingBlockScopedContainer = savedEnclosingBlockScopedContainer;
            return node;
        }
        function visitorWorker(node, valueIsDiscarded) {
            if (!(node.transformFlags & (4096 | 8388608 | 268435456))) {
                return node;
            }
            switch (node.kind) {
                case 245:
                    return visitForStatement(node, false);
                case 241:
                    return visitExpressionStatement(node);
                case 214:
                    return visitParenthesizedExpression(node, valueIsDiscarded);
                case 353:
                    return visitPartiallyEmittedExpression(node, valueIsDiscarded);
                case 223:
                    if (ts.isDestructuringAssignment(node)) {
                        return visitDestructuringAssignment(node, valueIsDiscarded);
                    }
                    break;
                case 210:
                    if (ts.isImportCall(node)) {
                        return visitImportCallExpression(node);
                    }
                    break;
                case 221:
                case 222:
                    return visitPrefixOrPostfixUnaryExpression(node, valueIsDiscarded);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            return visitorWorker(node, false);
        }
        function discardedValueVisitor(node) {
            return visitorWorker(node, true);
        }
        function visitExpressionStatement(node) {
            return factory.updateExpressionStatement(node, ts.visitNode(node.expression, discardedValueVisitor, ts.isExpression));
        }
        function visitParenthesizedExpression(node, valueIsDiscarded) {
            return factory.updateParenthesizedExpression(node, ts.visitNode(node.expression, valueIsDiscarded ? discardedValueVisitor : visitor, ts.isExpression));
        }
        function visitPartiallyEmittedExpression(node, valueIsDiscarded) {
            return factory.updatePartiallyEmittedExpression(node, ts.visitNode(node.expression, valueIsDiscarded ? discardedValueVisitor : visitor, ts.isExpression));
        }
        function visitImportCallExpression(node) {
            var externalModuleName = ts.getExternalModuleNameLiteral(factory, node, currentSourceFile, host, resolver, compilerOptions);
            var firstArgument = ts.visitNode(ts.firstOrUndefined(node.arguments), visitor);
            var argument = externalModuleName && (!firstArgument || !ts.isStringLiteral(firstArgument) || firstArgument.text !== externalModuleName.text) ? externalModuleName : firstArgument;
            return factory.createCallExpression(factory.createPropertyAccessExpression(contextObject, factory.createIdentifier("import")), undefined, argument ? [argument] : []);
        }
        function visitDestructuringAssignment(node, valueIsDiscarded) {
            if (hasExportedReferenceInDestructuringTarget(node.left)) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 0, !valueIsDiscarded);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function hasExportedReferenceInDestructuringTarget(node) {
            if (ts.isAssignmentExpression(node, true)) {
                return hasExportedReferenceInDestructuringTarget(node.left);
            }
            else if (ts.isSpreadElement(node)) {
                return hasExportedReferenceInDestructuringTarget(node.expression);
            }
            else if (ts.isObjectLiteralExpression(node)) {
                return ts.some(node.properties, hasExportedReferenceInDestructuringTarget);
            }
            else if (ts.isArrayLiteralExpression(node)) {
                return ts.some(node.elements, hasExportedReferenceInDestructuringTarget);
            }
            else if (ts.isShorthandPropertyAssignment(node)) {
                return hasExportedReferenceInDestructuringTarget(node.name);
            }
            else if (ts.isPropertyAssignment(node)) {
                return hasExportedReferenceInDestructuringTarget(node.initializer);
            }
            else if (ts.isIdentifier(node)) {
                var container = resolver.getReferencedExportContainer(node);
                return container !== undefined && container.kind === 308;
            }
            else {
                return false;
            }
        }
        function visitPrefixOrPostfixUnaryExpression(node, valueIsDiscarded) {
            if ((node.operator === 45 || node.operator === 46)
                && ts.isIdentifier(node.operand)
                && !ts.isGeneratedIdentifier(node.operand)
                && !ts.isLocalName(node.operand)
                && !ts.isDeclarationNameOfEnumOrNamespace(node.operand)) {
                var exportedNames = getExports(node.operand);
                if (exportedNames) {
                    var temp = void 0;
                    var expression = ts.visitNode(node.operand, visitor, ts.isExpression);
                    if (ts.isPrefixUnaryExpression(node)) {
                        expression = factory.updatePrefixUnaryExpression(node, expression);
                    }
                    else {
                        expression = factory.updatePostfixUnaryExpression(node, expression);
                        if (!valueIsDiscarded) {
                            temp = factory.createTempVariable(hoistVariableDeclaration);
                            expression = factory.createAssignment(temp, expression);
                            ts.setTextRange(expression, node);
                        }
                        expression = factory.createComma(expression, factory.cloneNode(node.operand));
                        ts.setTextRange(expression, node);
                    }
                    for (var _i = 0, exportedNames_4 = exportedNames; _i < exportedNames_4.length; _i++) {
                        var exportName = exportedNames_4[_i];
                        expression = createExportExpression(exportName, preventSubstitution(expression));
                    }
                    if (temp) {
                        expression = factory.createComma(expression, temp);
                        ts.setTextRange(expression, node);
                    }
                    return expression;
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function modifierVisitor(node) {
            switch (node.kind) {
                case 93:
                case 88:
                    return undefined;
            }
            return node;
        }
        function onEmitNode(hint, node, emitCallback) {
            if (node.kind === 308) {
                var id = ts.getOriginalNodeId(node);
                currentSourceFile = node;
                moduleInfo = moduleInfoMap[id];
                exportFunction = exportFunctionsMap[id];
                noSubstitution = noSubstitutionMap[id];
                contextObject = contextObjectMap[id];
                if (noSubstitution) {
                    delete noSubstitutionMap[id];
                }
                previousOnEmitNode(hint, node, emitCallback);
                currentSourceFile = undefined;
                moduleInfo = undefined;
                exportFunction = undefined;
                contextObject = undefined;
                noSubstitution = undefined;
            }
            else {
                previousOnEmitNode(hint, node, emitCallback);
            }
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (isSubstitutionPrevented(node)) {
                return node;
            }
            if (hint === 1) {
                return substituteExpression(node);
            }
            else if (hint === 4) {
                return substituteUnspecified(node);
            }
            return node;
        }
        function substituteUnspecified(node) {
            switch (node.kind) {
                case 300:
                    return substituteShorthandPropertyAssignment(node);
            }
            return node;
        }
        function substituteShorthandPropertyAssignment(node) {
            var _a, _b;
            var name = node.name;
            if (!ts.isGeneratedIdentifier(name) && !ts.isLocalName(name)) {
                var importDeclaration = resolver.getReferencedImportDeclaration(name);
                if (importDeclaration) {
                    if (ts.isImportClause(importDeclaration)) {
                        return ts.setTextRange(factory.createPropertyAssignment(factory.cloneNode(name), factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(importDeclaration.parent), factory.createIdentifier("default"))), node);
                    }
                    else if (ts.isImportSpecifier(importDeclaration)) {
                        return ts.setTextRange(factory.createPropertyAssignment(factory.cloneNode(name), factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(((_b = (_a = importDeclaration.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent) || importDeclaration), factory.cloneNode(importDeclaration.propertyName || importDeclaration.name))), node);
                    }
                }
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79:
                    return substituteExpressionIdentifier(node);
                case 223:
                    return substituteBinaryExpression(node);
                case 233:
                    return substituteMetaProperty(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            var _a, _b;
            if (ts.getEmitFlags(node) & 4096) {
                var externalHelpersModuleName = ts.getExternalHelpersModuleName(currentSourceFile);
                if (externalHelpersModuleName) {
                    return factory.createPropertyAccessExpression(externalHelpersModuleName, node);
                }
                return node;
            }
            if (!ts.isGeneratedIdentifier(node) && !ts.isLocalName(node)) {
                var importDeclaration = resolver.getReferencedImportDeclaration(node);
                if (importDeclaration) {
                    if (ts.isImportClause(importDeclaration)) {
                        return ts.setTextRange(factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(importDeclaration.parent), factory.createIdentifier("default")), node);
                    }
                    else if (ts.isImportSpecifier(importDeclaration)) {
                        return ts.setTextRange(factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(((_b = (_a = importDeclaration.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent) || importDeclaration), factory.cloneNode(importDeclaration.propertyName || importDeclaration.name)), node);
                    }
                }
            }
            return node;
        }
        function substituteBinaryExpression(node) {
            if (ts.isAssignmentOperator(node.operatorToken.kind)
                && ts.isIdentifier(node.left)
                && !ts.isGeneratedIdentifier(node.left)
                && !ts.isLocalName(node.left)
                && !ts.isDeclarationNameOfEnumOrNamespace(node.left)) {
                var exportedNames = getExports(node.left);
                if (exportedNames) {
                    var expression = node;
                    for (var _i = 0, exportedNames_5 = exportedNames; _i < exportedNames_5.length; _i++) {
                        var exportName = exportedNames_5[_i];
                        expression = createExportExpression(exportName, preventSubstitution(expression));
                    }
                    return expression;
                }
            }
            return node;
        }
        function substituteMetaProperty(node) {
            if (ts.isImportMeta(node)) {
                return factory.createPropertyAccessExpression(contextObject, factory.createIdentifier("meta"));
            }
            return node;
        }
        function getExports(name) {
            var exportedNames;
            if (!ts.isGeneratedIdentifier(name)) {
                var valueDeclaration = resolver.getReferencedImportDeclaration(name)
                    || resolver.getReferencedValueDeclaration(name);
                if (valueDeclaration) {
                    var exportContainer = resolver.getReferencedExportContainer(name, false);
                    if (exportContainer && exportContainer.kind === 308) {
                        exportedNames = ts.append(exportedNames, factory.getDeclarationName(valueDeclaration));
                    }
                    exportedNames = ts.addRange(exportedNames, moduleInfo && moduleInfo.exportedBindings[ts.getOriginalNodeId(valueDeclaration)]);
                }
            }
            return exportedNames;
        }
        function preventSubstitution(node) {
            if (noSubstitution === undefined)
                noSubstitution = [];
            noSubstitution[ts.getNodeId(node)] = true;
            return node;
        }
        function isSubstitutionPrevented(node) {
            return noSubstitution && node.id && noSubstitution[node.id];
        }
    }
    ts.transformSystemModule = transformSystemModule;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformECMAScriptModule(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory;
        var host = context.getEmitHost();
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var previousOnEmitNode = context.onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        context.enableEmitNotification(308);
        context.enableSubstitution(79);
        var helperNameSubstitutions;
        var currentSourceFile;
        var importRequireStatements;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            if (ts.isExternalModule(node) || compilerOptions.isolatedModules) {
                currentSourceFile = node;
                importRequireStatements = undefined;
                var result = updateExternalModule(node);
                currentSourceFile = undefined;
                if (importRequireStatements) {
                    result = factory.updateSourceFile(result, ts.setTextRange(factory.createNodeArray(ts.insertStatementsAfterCustomPrologue(result.statements.slice(), importRequireStatements)), result.statements));
                }
                if (!ts.isExternalModule(node) || ts.some(result.statements, ts.isExternalModuleIndicator)) {
                    return result;
                }
                return factory.updateSourceFile(result, ts.setTextRange(factory.createNodeArray(__spreadArray(__spreadArray([], result.statements, true), [ts.createEmptyExports(factory)], false)), result.statements));
            }
            return node;
        }
        function updateExternalModule(node) {
            var externalHelpersImportDeclaration = ts.createExternalHelpersImportDeclarationIfNeeded(factory, emitHelpers(), node, compilerOptions);
            if (externalHelpersImportDeclaration) {
                var statements = [];
                var statementOffset = factory.copyPrologue(node.statements, statements);
                ts.append(statements, externalHelpersImportDeclaration);
                ts.addRange(statements, ts.visitNodes(node.statements, visitor, ts.isStatement, statementOffset));
                return factory.updateSourceFile(node, ts.setTextRange(factory.createNodeArray(statements), node.statements));
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitor(node) {
            switch (node.kind) {
                case 268:
                    return ts.getEmitModuleKind(compilerOptions) >= ts.ModuleKind.Node16 ? visitImportEqualsDeclaration(node) : undefined;
                case 274:
                    return visitExportAssignment(node);
                case 275:
                    var exportDecl = node;
                    return visitExportDeclaration(exportDecl);
            }
            return node;
        }
        function createRequireCall(importNode) {
            var moduleName = ts.getExternalModuleNameLiteral(factory, importNode, ts.Debug.checkDefined(currentSourceFile), host, resolver, compilerOptions);
            var args = [];
            if (moduleName) {
                args.push(moduleName);
            }
            if (!importRequireStatements) {
                var createRequireName = factory.createUniqueName("_createRequire", 16 | 32);
                var importStatement = factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports([
                    factory.createImportSpecifier(false, factory.createIdentifier("createRequire"), createRequireName)
                ])), factory.createStringLiteral("module"));
                var requireHelperName = factory.createUniqueName("__require", 16 | 32);
                var requireStatement = factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                    factory.createVariableDeclaration(requireHelperName, undefined, undefined, factory.createCallExpression(factory.cloneNode(createRequireName), undefined, [
                        factory.createPropertyAccessExpression(factory.createMetaProperty(100, factory.createIdentifier("meta")), factory.createIdentifier("url"))
                    ]))
                ], languageVersion >= 2 ? 2 : 0));
                importRequireStatements = [importStatement, requireStatement];
            }
            var name = importRequireStatements[1].declarationList.declarations[0].name;
            ts.Debug.assertNode(name, ts.isIdentifier);
            return factory.createCallExpression(factory.cloneNode(name), undefined, args);
        }
        function visitImportEqualsDeclaration(node) {
            ts.Debug.assert(ts.isExternalModuleImportEqualsDeclaration(node), "import= for internal module references should be handled in an earlier transformer.");
            var statements;
            statements = ts.append(statements, ts.setOriginalNode(ts.setTextRange(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration(factory.cloneNode(node.name), undefined, undefined, createRequireCall(node))
            ], languageVersion >= 2 ? 2 : 0)), node), node));
            statements = appendExportsOfImportEqualsDeclaration(statements, node);
            return ts.singleOrMany(statements);
        }
        function appendExportsOfImportEqualsDeclaration(statements, node) {
            if (ts.hasSyntacticModifier(node, 1)) {
                statements = ts.append(statements, factory.createExportDeclaration(undefined, node.isTypeOnly, factory.createNamedExports([factory.createExportSpecifier(false, undefined, ts.idText(node.name))])));
            }
            return statements;
        }
        function visitExportAssignment(node) {
            return node.isExportEquals ? undefined : node;
        }
        function visitExportDeclaration(node) {
            if (compilerOptions.module !== undefined && compilerOptions.module > ts.ModuleKind.ES2015) {
                return node;
            }
            if (!node.exportClause || !ts.isNamespaceExport(node.exportClause) || !node.moduleSpecifier) {
                return node;
            }
            var oldIdentifier = node.exportClause.name;
            var synthName = factory.getGeneratedNameForNode(oldIdentifier);
            var importDecl = factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamespaceImport(synthName)), node.moduleSpecifier, node.assertClause);
            ts.setOriginalNode(importDecl, node.exportClause);
            var exportDecl = ts.isExportNamespaceAsDefaultDeclaration(node) ? factory.createExportDefault(synthName) : factory.createExportDeclaration(undefined, false, factory.createNamedExports([factory.createExportSpecifier(false, synthName, oldIdentifier)]));
            ts.setOriginalNode(exportDecl, node);
            return [importDecl, exportDecl];
        }
        function onEmitNode(hint, node, emitCallback) {
            if (ts.isSourceFile(node)) {
                if ((ts.isExternalModule(node) || compilerOptions.isolatedModules) && compilerOptions.importHelpers) {
                    helperNameSubstitutions = new ts.Map();
                }
                previousOnEmitNode(hint, node, emitCallback);
                helperNameSubstitutions = undefined;
            }
            else {
                previousOnEmitNode(hint, node, emitCallback);
            }
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (helperNameSubstitutions && ts.isIdentifier(node) && ts.getEmitFlags(node) & 4096) {
                return substituteHelperName(node);
            }
            return node;
        }
        function substituteHelperName(node) {
            var name = ts.idText(node);
            var substitution = helperNameSubstitutions.get(name);
            if (!substitution) {
                helperNameSubstitutions.set(name, substitution = factory.createUniqueName(name, 16 | 32));
            }
            return substitution;
        }
    }
    ts.transformECMAScriptModule = transformECMAScriptModule;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformNodeModule(context) {
        var previousOnSubstituteNode = context.onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        var esmTransform = ts.transformECMAScriptModule(context);
        var esmOnSubstituteNode = context.onSubstituteNode;
        var esmOnEmitNode = context.onEmitNode;
        context.onSubstituteNode = previousOnSubstituteNode;
        context.onEmitNode = previousOnEmitNode;
        var cjsTransform = ts.transformModule(context);
        var cjsOnSubstituteNode = context.onSubstituteNode;
        var cjsOnEmitNode = context.onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        context.onEmitNode = onEmitNode;
        context.enableSubstitution(308);
        context.enableEmitNotification(308);
        var currentSourceFile;
        return transformSourceFileOrBundle;
        function onSubstituteNode(hint, node) {
            if (ts.isSourceFile(node)) {
                currentSourceFile = node;
                return previousOnSubstituteNode(hint, node);
            }
            else {
                if (!currentSourceFile) {
                    return previousOnSubstituteNode(hint, node);
                }
                if (currentSourceFile.impliedNodeFormat === ts.ModuleKind.ESNext) {
                    return esmOnSubstituteNode(hint, node);
                }
                return cjsOnSubstituteNode(hint, node);
            }
        }
        function onEmitNode(hint, node, emitCallback) {
            if (ts.isSourceFile(node)) {
                currentSourceFile = node;
            }
            if (!currentSourceFile) {
                return previousOnEmitNode(hint, node, emitCallback);
            }
            if (currentSourceFile.impliedNodeFormat === ts.ModuleKind.ESNext) {
                return esmOnEmitNode(hint, node, emitCallback);
            }
            return cjsOnEmitNode(hint, node, emitCallback);
        }
        function getModuleTransformForFile(file) {
            return file.impliedNodeFormat === ts.ModuleKind.ESNext ? esmTransform : cjsTransform;
        }
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            var result = getModuleTransformForFile(node)(node);
            currentSourceFile = undefined;
            ts.Debug.assert(ts.isSourceFile(result));
            return result;
        }
        function transformSourceFileOrBundle(node) {
            return node.kind === 308 ? transformSourceFile(node) : transformBundle(node);
        }
        function transformBundle(node) {
            return context.factory.createBundle(ts.map(node.sourceFiles, transformSourceFile), node.prepends);
        }
    }
    ts.transformNodeModule = transformNodeModule;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function canProduceDiagnostics(node) {
        return ts.isVariableDeclaration(node) ||
            ts.isPropertyDeclaration(node) ||
            ts.isPropertySignature(node) ||
            ts.isBindingElement(node) ||
            ts.isSetAccessor(node) ||
            ts.isGetAccessor(node) ||
            ts.isConstructSignatureDeclaration(node) ||
            ts.isCallSignatureDeclaration(node) ||
            ts.isMethodDeclaration(node) ||
            ts.isMethodSignature(node) ||
            ts.isFunctionDeclaration(node) ||
            ts.isParameter(node) ||
            ts.isTypeParameterDeclaration(node) ||
            ts.isExpressionWithTypeArguments(node) ||
            ts.isImportEqualsDeclaration(node) ||
            ts.isTypeAliasDeclaration(node) ||
            ts.isConstructorDeclaration(node) ||
            ts.isIndexSignatureDeclaration(node) ||
            ts.isPropertyAccessExpression(node) ||
            ts.isJSDocTypeAlias(node);
    }
    ts.canProduceDiagnostics = canProduceDiagnostics;
    function createGetSymbolAccessibilityDiagnosticForNodeName(node) {
        if (ts.isSetAccessor(node) || ts.isGetAccessor(node)) {
            return getAccessorNameVisibilityError;
        }
        else if (ts.isMethodSignature(node) || ts.isMethodDeclaration(node)) {
            return getMethodNameVisibilityError;
        }
        else {
            return createGetSymbolAccessibilityDiagnosticForNode(node);
        }
        function getAccessorNameVisibilityError(symbolAccessibilityResult) {
            var diagnosticMessage = getAccessorNameVisibilityDiagnosticMessage(symbolAccessibilityResult);
            return diagnosticMessage !== undefined ? {
                diagnosticMessage: diagnosticMessage,
                errorNode: node,
                typeName: node.name
            } : undefined;
        }
        function getAccessorNameVisibilityDiagnosticMessage(symbolAccessibilityResult) {
            if (ts.isStatic(node)) {
                return symbolAccessibilityResult.errorModuleName ?
                    symbolAccessibilityResult.accessibility === 2 ?
                        ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                        ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 :
                    ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_private_name_1;
            }
            else if (node.parent.kind === 260) {
                return symbolAccessibilityResult.errorModuleName ?
                    symbolAccessibilityResult.accessibility === 2 ?
                        ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                        ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 :
                    ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_private_name_1;
            }
            else {
                return symbolAccessibilityResult.errorModuleName ?
                    ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 :
                    ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_private_name_1;
            }
        }
        function getMethodNameVisibilityError(symbolAccessibilityResult) {
            var diagnosticMessage = getMethodNameVisibilityDiagnosticMessage(symbolAccessibilityResult);
            return diagnosticMessage !== undefined ? {
                diagnosticMessage: diagnosticMessage,
                errorNode: node,
                typeName: node.name
            } : undefined;
        }
        function getMethodNameVisibilityDiagnosticMessage(symbolAccessibilityResult) {
            if (ts.isStatic(node)) {
                return symbolAccessibilityResult.errorModuleName ?
                    symbolAccessibilityResult.accessibility === 2 ?
                        ts.Diagnostics.Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                        ts.Diagnostics.Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 :
                    ts.Diagnostics.Public_static_method_0_of_exported_class_has_or_is_using_private_name_1;
            }
            else if (node.parent.kind === 260) {
                return symbolAccessibilityResult.errorModuleName ?
                    symbolAccessibilityResult.accessibility === 2 ?
                        ts.Diagnostics.Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                        ts.Diagnostics.Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 :
                    ts.Diagnostics.Public_method_0_of_exported_class_has_or_is_using_private_name_1;
            }
            else {
                return symbolAccessibilityResult.errorModuleName ?
                    ts.Diagnostics.Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 :
                    ts.Diagnostics.Method_0_of_exported_interface_has_or_is_using_private_name_1;
            }
        }
    }
    ts.createGetSymbolAccessibilityDiagnosticForNodeName = createGetSymbolAccessibilityDiagnosticForNodeName;
    function createGetSymbolAccessibilityDiagnosticForNode(node) {
        if (ts.isVariableDeclaration(node) || ts.isPropertyDeclaration(node) || ts.isPropertySignature(node) || ts.isPropertyAccessExpression(node) || ts.isBindingElement(node) || ts.isConstructorDeclaration(node)) {
            return getVariableDeclarationTypeVisibilityError;
        }
        else if (ts.isSetAccessor(node) || ts.isGetAccessor(node)) {
            return getAccessorDeclarationTypeVisibilityError;
        }
        else if (ts.isConstructSignatureDeclaration(node) || ts.isCallSignatureDeclaration(node) || ts.isMethodDeclaration(node) || ts.isMethodSignature(node) || ts.isFunctionDeclaration(node) || ts.isIndexSignatureDeclaration(node)) {
            return getReturnTypeVisibilityError;
        }
        else if (ts.isParameter(node)) {
            if (ts.isParameterPropertyDeclaration(node, node.parent) && ts.hasSyntacticModifier(node.parent, 8)) {
                return getVariableDeclarationTypeVisibilityError;
            }
            return getParameterDeclarationTypeVisibilityError;
        }
        else if (ts.isTypeParameterDeclaration(node)) {
            return getTypeParameterConstraintVisibilityError;
        }
        else if (ts.isExpressionWithTypeArguments(node)) {
            return getHeritageClauseVisibilityError;
        }
        else if (ts.isImportEqualsDeclaration(node)) {
            return getImportEntityNameVisibilityError;
        }
        else if (ts.isTypeAliasDeclaration(node) || ts.isJSDocTypeAlias(node)) {
            return getTypeAliasDeclarationVisibilityError;
        }
        else {
            return ts.Debug.assertNever(node, "Attempted to set a declaration diagnostic context for unhandled node kind: ".concat(ts.Debug.formatSyntaxKind(node.kind)));
        }
        function getVariableDeclarationTypeVisibilityDiagnosticMessage(symbolAccessibilityResult) {
            if (node.kind === 257 || node.kind === 205) {
                return symbolAccessibilityResult.errorModuleName ?
                    symbolAccessibilityResult.accessibility === 2 ?
                        ts.Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                        ts.Diagnostics.Exported_variable_0_has_or_is_using_name_1_from_private_module_2 :
                    ts.Diagnostics.Exported_variable_0_has_or_is_using_private_name_1;
            }
            else if (node.kind === 169 || node.kind === 208 || node.kind === 168 ||
                (node.kind === 166 && ts.hasSyntacticModifier(node.parent, 8))) {
                if (ts.isStatic(node)) {
                    return symbolAccessibilityResult.errorModuleName ?
                        symbolAccessibilityResult.accessibility === 2 ?
                            ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                            ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Public_static_property_0_of_exported_class_has_or_is_using_private_name_1;
                }
                else if (node.parent.kind === 260 || node.kind === 166) {
                    return symbolAccessibilityResult.errorModuleName ?
                        symbolAccessibilityResult.accessibility === 2 ?
                            ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                            ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Public_property_0_of_exported_class_has_or_is_using_private_name_1;
                }
                else {
                    return symbolAccessibilityResult.errorModuleName ?
                        ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Property_0_of_exported_interface_has_or_is_using_private_name_1;
                }
            }
        }
        function getVariableDeclarationTypeVisibilityError(symbolAccessibilityResult) {
            var diagnosticMessage = getVariableDeclarationTypeVisibilityDiagnosticMessage(symbolAccessibilityResult);
            return diagnosticMessage !== undefined ? {
                diagnosticMessage: diagnosticMessage,
                errorNode: node,
                typeName: node.name
            } : undefined;
        }
        function getAccessorDeclarationTypeVisibilityError(symbolAccessibilityResult) {
            var diagnosticMessage;
            if (node.kind === 175) {
                if (ts.isStatic(node)) {
                    diagnosticMessage = symbolAccessibilityResult.errorModuleName ?
                        ts.Diagnostics.Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1;
                }
                else {
                    diagnosticMessage = symbolAccessibilityResult.errorModuleName ?
                        ts.Diagnostics.Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1;
                }
            }
            else {
                if (ts.isStatic(node)) {
                    diagnosticMessage = symbolAccessibilityResult.errorModuleName ?
                        symbolAccessibilityResult.accessibility === 2 ?
                            ts.Diagnostics.Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                            ts.Diagnostics.Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1;
                }
                else {
                    diagnosticMessage = symbolAccessibilityResult.errorModuleName ?
                        symbolAccessibilityResult.accessibility === 2 ?
                            ts.Diagnostics.Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                            ts.Diagnostics.Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1;
                }
            }
            return {
                diagnosticMessage: diagnosticMessage,
                errorNode: node.name,
                typeName: node.name
            };
        }
        function getReturnTypeVisibilityError(symbolAccessibilityResult) {
            var diagnosticMessage;
            switch (node.kind) {
                case 177:
                    diagnosticMessage = symbolAccessibilityResult.errorModuleName ?
                        ts.Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 :
                        ts.Diagnostics.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0;
                    break;
                case 176:
                    diagnosticMessage = symbolAccessibilityResult.errorModuleName ?
                        ts.Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 :
                        ts.Diagnostics.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0;
                    break;
                case 178:
                    diagnosticMessage = symbolAccessibilityResult.errorModuleName ?
                        ts.Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 :
                        ts.Diagnostics.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0;
                    break;
                case 171:
                case 170:
                    if (ts.isStatic(node)) {
                        diagnosticMessage = symbolAccessibilityResult.errorModuleName ?
                            symbolAccessibilityResult.accessibility === 2 ?
                                ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named :
                                ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 :
                            ts.Diagnostics.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0;
                    }
                    else if (node.parent.kind === 260) {
                        diagnosticMessage = symbolAccessibilityResult.errorModuleName ?
                            symbolAccessibilityResult.accessibility === 2 ?
                                ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named :
                                ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 :
                            ts.Diagnostics.Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0;
                    }
                    else {
                        diagnosticMessage = symbolAccessibilityResult.errorModuleName ?
                            ts.Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1 :
                            ts.Diagnostics.Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0;
                    }
                    break;
                case 259:
                    diagnosticMessage = symbolAccessibilityResult.errorModuleName ?
                        symbolAccessibilityResult.accessibility === 2 ?
                            ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named :
                            ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1 :
                        ts.Diagnostics.Return_type_of_exported_function_has_or_is_using_private_name_0;
                    break;
                default:
                    return ts.Debug.fail("This is unknown kind for signature: " + node.kind);
            }
            return {
                diagnosticMessage: diagnosticMessage,
                errorNode: node.name || node
            };
        }
        function getParameterDeclarationTypeVisibilityError(symbolAccessibilityResult) {
            var diagnosticMessage = getParameterDeclarationTypeVisibilityDiagnosticMessage(symbolAccessibilityResult);
            return diagnosticMessage !== undefined ? {
                diagnosticMessage: diagnosticMessage,
                errorNode: node,
                typeName: node.name
            } : undefined;
        }
        function getParameterDeclarationTypeVisibilityDiagnosticMessage(symbolAccessibilityResult) {
            switch (node.parent.kind) {
                case 173:
                    return symbolAccessibilityResult.errorModuleName ?
                        symbolAccessibilityResult.accessibility === 2 ?
                            ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                            ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1;
                case 177:
                case 182:
                    return symbolAccessibilityResult.errorModuleName ?
                        ts.Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;
                case 176:
                    return symbolAccessibilityResult.errorModuleName ?
                        ts.Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;
                case 178:
                    return symbolAccessibilityResult.errorModuleName ?
                        ts.Diagnostics.Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1;
                case 171:
                case 170:
                    if (ts.isStatic(node.parent)) {
                        return symbolAccessibilityResult.errorModuleName ?
                            symbolAccessibilityResult.accessibility === 2 ?
                                ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                                ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 :
                            ts.Diagnostics.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;
                    }
                    else if (node.parent.parent.kind === 260) {
                        return symbolAccessibilityResult.errorModuleName ?
                            symbolAccessibilityResult.accessibility === 2 ?
                                ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                                ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 :
                            ts.Diagnostics.Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;
                    }
                    else {
                        return symbolAccessibilityResult.errorModuleName ?
                            ts.Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 :
                            ts.Diagnostics.Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;
                    }
                case 259:
                case 181:
                    return symbolAccessibilityResult.errorModuleName ?
                        symbolAccessibilityResult.accessibility === 2 ?
                            ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                            ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Parameter_0_of_exported_function_has_or_is_using_private_name_1;
                case 175:
                case 174:
                    return symbolAccessibilityResult.errorModuleName ?
                        symbolAccessibilityResult.accessibility === 2 ?
                            ts.Diagnostics.Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named :
                            ts.Diagnostics.Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2 :
                        ts.Diagnostics.Parameter_0_of_accessor_has_or_is_using_private_name_1;
                default:
                    return ts.Debug.fail("Unknown parent for parameter: ".concat(ts.Debug.formatSyntaxKind(node.parent.kind)));
            }
        }
        function getTypeParameterConstraintVisibilityError() {
            var diagnosticMessage;
            switch (node.parent.kind) {
                case 260:
                    diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_exported_class_has_or_is_using_private_name_1;
                    break;
                case 261:
                    diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1;
                    break;
                case 197:
                    diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1;
                    break;
                case 182:
                case 177:
                    diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1;
                    break;
                case 176:
                    diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1;
                    break;
                case 171:
                case 170:
                    if (ts.isStatic(node.parent)) {
                        diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1;
                    }
                    else if (node.parent.parent.kind === 260) {
                        diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1;
                    }
                    else {
                        diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1;
                    }
                    break;
                case 181:
                case 259:
                    diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_exported_function_has_or_is_using_private_name_1;
                    break;
                case 262:
                    diagnosticMessage = ts.Diagnostics.Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1;
                    break;
                default:
                    return ts.Debug.fail("This is unknown parent for type parameter: " + node.parent.kind);
            }
            return {
                diagnosticMessage: diagnosticMessage,
                errorNode: node,
                typeName: node.name
            };
        }
        function getHeritageClauseVisibilityError() {
            var diagnosticMessage;
            if (ts.isClassDeclaration(node.parent.parent)) {
                diagnosticMessage = ts.isHeritageClause(node.parent) && node.parent.token === 117 ?
                    ts.Diagnostics.Implements_clause_of_exported_class_0_has_or_is_using_private_name_1 :
                    node.parent.parent.name ? ts.Diagnostics.extends_clause_of_exported_class_0_has_or_is_using_private_name_1 :
                        ts.Diagnostics.extends_clause_of_exported_class_has_or_is_using_private_name_0;
            }
            else {
                diagnosticMessage = ts.Diagnostics.extends_clause_of_exported_interface_0_has_or_is_using_private_name_1;
            }
            return {
                diagnosticMessage: diagnosticMessage,
                errorNode: node,
                typeName: ts.getNameOfDeclaration(node.parent.parent)
            };
        }
        function getImportEntityNameVisibilityError() {
            return {
                diagnosticMessage: ts.Diagnostics.Import_declaration_0_is_using_private_name_1,
                errorNode: node,
                typeName: node.name
            };
        }
        function getTypeAliasDeclarationVisibilityError(symbolAccessibilityResult) {
            return {
                diagnosticMessage: symbolAccessibilityResult.errorModuleName
                    ? ts.Diagnostics.Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2
                    : ts.Diagnostics.Exported_type_alias_0_has_or_is_using_private_name_1,
                errorNode: ts.isJSDocTypeAlias(node) ? ts.Debug.checkDefined(node.typeExpression) : node.type,
                typeName: ts.isJSDocTypeAlias(node) ? ts.getNameOfDeclaration(node) : node.name,
            };
        }
    }
    ts.createGetSymbolAccessibilityDiagnosticForNode = createGetSymbolAccessibilityDiagnosticForNode;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function getDeclarationDiagnostics(host, resolver, file) {
        var compilerOptions = host.getCompilerOptions();
        var result = ts.transformNodes(resolver, host, ts.factory, compilerOptions, file ? [file] : ts.filter(host.getSourceFiles(), ts.isSourceFileNotJson), [transformDeclarations], false);
        return result.diagnostics;
    }
    ts.getDeclarationDiagnostics = getDeclarationDiagnostics;
    function hasInternalAnnotation(range, currentSourceFile) {
        var comment = currentSourceFile.text.substring(range.pos, range.end);
        return ts.stringContains(comment, "@internal");
    }
    function isInternalDeclaration(node, currentSourceFile) {
        var parseTreeNode = ts.getParseTreeNode(node);
        if (parseTreeNode && parseTreeNode.kind === 166) {
            var paramIdx = parseTreeNode.parent.parameters.indexOf(parseTreeNode);
            var previousSibling = paramIdx > 0 ? parseTreeNode.parent.parameters[paramIdx - 1] : undefined;
            var text = currentSourceFile.text;
            var commentRanges = previousSibling
                ? ts.concatenate(ts.getTrailingCommentRanges(text, ts.skipTrivia(text, previousSibling.end + 1, false, true)), ts.getLeadingCommentRanges(text, node.pos))
                : ts.getTrailingCommentRanges(text, ts.skipTrivia(text, node.pos, false, true));
            return commentRanges && commentRanges.length && hasInternalAnnotation(ts.last(commentRanges), currentSourceFile);
        }
        var leadingCommentRanges = parseTreeNode && ts.getLeadingCommentRangesOfNode(parseTreeNode, currentSourceFile);
        return !!ts.forEach(leadingCommentRanges, function (range) {
            return hasInternalAnnotation(range, currentSourceFile);
        });
    }
    ts.isInternalDeclaration = isInternalDeclaration;
    var declarationEmitNodeBuilderFlags = 1024 |
        2048 |
        4096 |
        8 |
        524288 |
        4 |
        1;
    function transformDeclarations(context) {
        var throwDiagnostic = function () { return ts.Debug.fail("Diagnostic emitted without context"); };
        var getSymbolAccessibilityDiagnostic = throwDiagnostic;
        var needsDeclare = true;
        var isBundledEmit = false;
        var resultHasExternalModuleIndicator = false;
        var needsScopeFixMarker = false;
        var resultHasScopeMarker = false;
        var enclosingDeclaration;
        var necessaryTypeReferences;
        var lateMarkedStatements;
        var lateStatementReplacementMap;
        var suppressNewDiagnosticContexts;
        var exportedModulesFromDeclarationEmit;
        var factory = context.factory;
        var host = context.getEmitHost();
        var symbolTracker = {
            trackSymbol: trackSymbol,
            reportInaccessibleThisError: reportInaccessibleThisError,
            reportInaccessibleUniqueSymbolError: reportInaccessibleUniqueSymbolError,
            reportCyclicStructureError: reportCyclicStructureError,
            reportPrivateInBaseOfClassExpression: reportPrivateInBaseOfClassExpression,
            reportLikelyUnsafeImportRequiredError: reportLikelyUnsafeImportRequiredError,
            reportTruncationError: reportTruncationError,
            moduleResolverHost: host,
            trackReferencedAmbientModule: trackReferencedAmbientModule,
            trackExternalModuleSymbolOfImportTypeNode: trackExternalModuleSymbolOfImportTypeNode,
            reportNonlocalAugmentation: reportNonlocalAugmentation,
            reportNonSerializableProperty: reportNonSerializableProperty,
            reportImportTypeNodeResolutionModeOverride: reportImportTypeNodeResolutionModeOverride,
        };
        var errorNameNode;
        var errorFallbackNode;
        var currentSourceFile;
        var refs;
        var libs;
        var emittedImports;
        var resolver = context.getEmitResolver();
        var options = context.getCompilerOptions();
        var noResolve = options.noResolve, stripInternal = options.stripInternal;
        return transformRoot;
        function recordTypeReferenceDirectivesIfNecessary(typeReferenceDirectives) {
            if (!typeReferenceDirectives) {
                return;
            }
            necessaryTypeReferences = necessaryTypeReferences || new ts.Set();
            for (var _i = 0, typeReferenceDirectives_2 = typeReferenceDirectives; _i < typeReferenceDirectives_2.length; _i++) {
                var ref = typeReferenceDirectives_2[_i];
                necessaryTypeReferences.add(ref);
            }
        }
        function trackReferencedAmbientModule(node, symbol) {
            var directives = resolver.getTypeReferenceDirectivesForSymbol(symbol, 67108863);
            if (ts.length(directives)) {
                return recordTypeReferenceDirectivesIfNecessary(directives);
            }
            var container = ts.getSourceFileOfNode(node);
            refs.set(ts.getOriginalNodeId(container), container);
        }
        function handleSymbolAccessibilityError(symbolAccessibilityResult) {
            if (symbolAccessibilityResult.accessibility === 0) {
                if (symbolAccessibilityResult && symbolAccessibilityResult.aliasesToMakeVisible) {
                    if (!lateMarkedStatements) {
                        lateMarkedStatements = symbolAccessibilityResult.aliasesToMakeVisible;
                    }
                    else {
                        for (var _i = 0, _a = symbolAccessibilityResult.aliasesToMakeVisible; _i < _a.length; _i++) {
                            var ref = _a[_i];
                            ts.pushIfUnique(lateMarkedStatements, ref);
                        }
                    }
                }
            }
            else {
                var errorInfo = getSymbolAccessibilityDiagnostic(symbolAccessibilityResult);
                if (errorInfo) {
                    if (errorInfo.typeName) {
                        context.addDiagnostic(ts.createDiagnosticForNode(symbolAccessibilityResult.errorNode || errorInfo.errorNode, errorInfo.diagnosticMessage, ts.getTextOfNode(errorInfo.typeName), symbolAccessibilityResult.errorSymbolName, symbolAccessibilityResult.errorModuleName));
                    }
                    else {
                        context.addDiagnostic(ts.createDiagnosticForNode(symbolAccessibilityResult.errorNode || errorInfo.errorNode, errorInfo.diagnosticMessage, symbolAccessibilityResult.errorSymbolName, symbolAccessibilityResult.errorModuleName));
                    }
                    return true;
                }
            }
            return false;
        }
        function trackExternalModuleSymbolOfImportTypeNode(symbol) {
            if (!isBundledEmit) {
                (exportedModulesFromDeclarationEmit || (exportedModulesFromDeclarationEmit = [])).push(symbol);
            }
        }
        function trackSymbol(symbol, enclosingDeclaration, meaning) {
            if (symbol.flags & 262144)
                return false;
            var issuedDiagnostic = handleSymbolAccessibilityError(resolver.isSymbolAccessible(symbol, enclosingDeclaration, meaning, true));
            recordTypeReferenceDirectivesIfNecessary(resolver.getTypeReferenceDirectivesForSymbol(symbol, meaning));
            return issuedDiagnostic;
        }
        function reportPrivateInBaseOfClassExpression(propertyName) {
            if (errorNameNode || errorFallbackNode) {
                context.addDiagnostic(ts.createDiagnosticForNode((errorNameNode || errorFallbackNode), ts.Diagnostics.Property_0_of_exported_class_expression_may_not_be_private_or_protected, propertyName));
            }
        }
        function errorDeclarationNameWithFallback() {
            return errorNameNode ? ts.declarationNameToString(errorNameNode) :
                errorFallbackNode && ts.getNameOfDeclaration(errorFallbackNode) ? ts.declarationNameToString(ts.getNameOfDeclaration(errorFallbackNode)) :
                    errorFallbackNode && ts.isExportAssignment(errorFallbackNode) ? errorFallbackNode.isExportEquals ? "export=" : "default" :
                        "(Missing)";
        }
        function reportInaccessibleUniqueSymbolError() {
            if (errorNameNode || errorFallbackNode) {
                context.addDiagnostic(ts.createDiagnosticForNode((errorNameNode || errorFallbackNode), ts.Diagnostics.The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary, errorDeclarationNameWithFallback(), "unique symbol"));
            }
        }
        function reportCyclicStructureError() {
            if (errorNameNode || errorFallbackNode) {
                context.addDiagnostic(ts.createDiagnosticForNode((errorNameNode || errorFallbackNode), ts.Diagnostics.The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialized_A_type_annotation_is_necessary, errorDeclarationNameWithFallback()));
            }
        }
        function reportInaccessibleThisError() {
            if (errorNameNode || errorFallbackNode) {
                context.addDiagnostic(ts.createDiagnosticForNode((errorNameNode || errorFallbackNode), ts.Diagnostics.The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary, errorDeclarationNameWithFallback(), "this"));
            }
        }
        function reportLikelyUnsafeImportRequiredError(specifier) {
            if (errorNameNode || errorFallbackNode) {
                context.addDiagnostic(ts.createDiagnosticForNode((errorNameNode || errorFallbackNode), ts.Diagnostics.The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_annotation_is_necessary, errorDeclarationNameWithFallback(), specifier));
            }
        }
        function reportTruncationError() {
            if (errorNameNode || errorFallbackNode) {
                context.addDiagnostic(ts.createDiagnosticForNode((errorNameNode || errorFallbackNode), ts.Diagnostics.The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_type_annotation_is_needed));
            }
        }
        function reportNonlocalAugmentation(containingFile, parentSymbol, symbol) {
            var _a;
            var primaryDeclaration = (_a = parentSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(function (d) { return ts.getSourceFileOfNode(d) === containingFile; });
            var augmentingDeclarations = ts.filter(symbol.declarations, function (d) { return ts.getSourceFileOfNode(d) !== containingFile; });
            if (primaryDeclaration && augmentingDeclarations) {
                for (var _i = 0, augmentingDeclarations_1 = augmentingDeclarations; _i < augmentingDeclarations_1.length; _i++) {
                    var augmentations = augmentingDeclarations_1[_i];
                    context.addDiagnostic(ts.addRelatedInfo(ts.createDiagnosticForNode(augmentations, ts.Diagnostics.Declaration_augments_declaration_in_another_file_This_cannot_be_serialized), ts.createDiagnosticForNode(primaryDeclaration, ts.Diagnostics.This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_file)));
                }
            }
        }
        function reportNonSerializableProperty(propertyName) {
            if (errorNameNode || errorFallbackNode) {
                context.addDiagnostic(ts.createDiagnosticForNode((errorNameNode || errorFallbackNode), ts.Diagnostics.The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized, propertyName));
            }
        }
        function reportImportTypeNodeResolutionModeOverride() {
            if (!ts.isNightly() && (errorNameNode || errorFallbackNode)) {
                context.addDiagnostic(ts.createDiagnosticForNode((errorNameNode || errorFallbackNode), ts.Diagnostics.The_type_of_this_expression_cannot_be_named_without_a_resolution_mode_assertion_which_is_an_unstable_feature_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next));
            }
        }
        function transformDeclarationsForJS(sourceFile, bundled) {
            var oldDiag = getSymbolAccessibilityDiagnostic;
            getSymbolAccessibilityDiagnostic = function (s) { return (s.errorNode && ts.canProduceDiagnostics(s.errorNode) ? ts.createGetSymbolAccessibilityDiagnosticForNode(s.errorNode)(s) : ({
                diagnosticMessage: s.errorModuleName
                    ? ts.Diagnostics.Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotation_may_unblock_declaration_emit
                    : ts.Diagnostics.Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_declaration_emit,
                errorNode: s.errorNode || sourceFile
            })); };
            var result = resolver.getDeclarationStatementsForSourceFile(sourceFile, declarationEmitNodeBuilderFlags, symbolTracker, bundled);
            getSymbolAccessibilityDiagnostic = oldDiag;
            return result;
        }
        function transformRoot(node) {
            if (node.kind === 308 && node.isDeclarationFile) {
                return node;
            }
            if (node.kind === 309) {
                isBundledEmit = true;
                refs = new ts.Map();
                libs = new ts.Map();
                var hasNoDefaultLib_1 = false;
                var bundle = factory.createBundle(ts.map(node.sourceFiles, function (sourceFile) {
                    if (sourceFile.isDeclarationFile)
                        return undefined;
                    hasNoDefaultLib_1 = hasNoDefaultLib_1 || sourceFile.hasNoDefaultLib;
                    currentSourceFile = sourceFile;
                    enclosingDeclaration = sourceFile;
                    lateMarkedStatements = undefined;
                    suppressNewDiagnosticContexts = false;
                    lateStatementReplacementMap = new ts.Map();
                    getSymbolAccessibilityDiagnostic = throwDiagnostic;
                    needsScopeFixMarker = false;
                    resultHasScopeMarker = false;
                    collectReferences(sourceFile, refs);
                    collectLibs(sourceFile, libs);
                    if (ts.isExternalOrCommonJsModule(sourceFile) || ts.isJsonSourceFile(sourceFile)) {
                        resultHasExternalModuleIndicator = false;
                        needsDeclare = false;
                        var statements = ts.isSourceFileJS(sourceFile) ? factory.createNodeArray(transformDeclarationsForJS(sourceFile, true)) : ts.visitNodes(sourceFile.statements, visitDeclarationStatements);
                        var newFile = factory.updateSourceFile(sourceFile, [factory.createModuleDeclaration([factory.createModifier(136)], factory.createStringLiteral(ts.getResolvedExternalModuleName(context.getEmitHost(), sourceFile)), factory.createModuleBlock(ts.setTextRange(factory.createNodeArray(transformAndReplaceLatePaintedStatements(statements)), sourceFile.statements)))], true, [], [], false, []);
                        return newFile;
                    }
                    needsDeclare = true;
                    var updated = ts.isSourceFileJS(sourceFile) ? factory.createNodeArray(transformDeclarationsForJS(sourceFile)) : ts.visitNodes(sourceFile.statements, visitDeclarationStatements);
                    return factory.updateSourceFile(sourceFile, transformAndReplaceLatePaintedStatements(updated), true, [], [], false, []);
                }), ts.mapDefined(node.prepends, function (prepend) {
                    if (prepend.kind === 311) {
                        var sourceFile = ts.createUnparsedSourceFile(prepend, "dts", stripInternal);
                        hasNoDefaultLib_1 = hasNoDefaultLib_1 || !!sourceFile.hasNoDefaultLib;
                        collectReferences(sourceFile, refs);
                        recordTypeReferenceDirectivesIfNecessary(ts.map(sourceFile.typeReferenceDirectives, function (ref) { return [ref.fileName, ref.resolutionMode]; }));
                        collectLibs(sourceFile, libs);
                        return sourceFile;
                    }
                    return prepend;
                }));
                bundle.syntheticFileReferences = [];
                bundle.syntheticTypeReferences = getFileReferencesForUsedTypeReferences();
                bundle.syntheticLibReferences = getLibReferences();
                bundle.hasNoDefaultLib = hasNoDefaultLib_1;
                var outputFilePath_1 = ts.getDirectoryPath(ts.normalizeSlashes(ts.getOutputPathsFor(node, host, true).declarationFilePath));
                var referenceVisitor_1 = mapReferencesIntoArray(bundle.syntheticFileReferences, outputFilePath_1);
                refs.forEach(referenceVisitor_1);
                return bundle;
            }
            needsDeclare = true;
            needsScopeFixMarker = false;
            resultHasScopeMarker = false;
            enclosingDeclaration = node;
            currentSourceFile = node;
            getSymbolAccessibilityDiagnostic = throwDiagnostic;
            isBundledEmit = false;
            resultHasExternalModuleIndicator = false;
            suppressNewDiagnosticContexts = false;
            lateMarkedStatements = undefined;
            lateStatementReplacementMap = new ts.Map();
            necessaryTypeReferences = undefined;
            refs = collectReferences(currentSourceFile, new ts.Map());
            libs = collectLibs(currentSourceFile, new ts.Map());
            var references = [];
            var outputFilePath = ts.getDirectoryPath(ts.normalizeSlashes(ts.getOutputPathsFor(node, host, true).declarationFilePath));
            var referenceVisitor = mapReferencesIntoArray(references, outputFilePath);
            var combinedStatements;
            if (ts.isSourceFileJS(currentSourceFile)) {
                combinedStatements = factory.createNodeArray(transformDeclarationsForJS(node));
                refs.forEach(referenceVisitor);
                emittedImports = ts.filter(combinedStatements, ts.isAnyImportSyntax);
            }
            else {
                var statements = ts.visitNodes(node.statements, visitDeclarationStatements);
                combinedStatements = ts.setTextRange(factory.createNodeArray(transformAndReplaceLatePaintedStatements(statements)), node.statements);
                refs.forEach(referenceVisitor);
                emittedImports = ts.filter(combinedStatements, ts.isAnyImportSyntax);
                if (ts.isExternalModule(node) && (!resultHasExternalModuleIndicator || (needsScopeFixMarker && !resultHasScopeMarker))) {
                    combinedStatements = ts.setTextRange(factory.createNodeArray(__spreadArray(__spreadArray([], combinedStatements, true), [ts.createEmptyExports(factory)], false)), combinedStatements);
                }
            }
            var updated = factory.updateSourceFile(node, combinedStatements, true, references, getFileReferencesForUsedTypeReferences(), node.hasNoDefaultLib, getLibReferences());
            updated.exportedModulesFromDeclarationEmit = exportedModulesFromDeclarationEmit;
            return updated;
            function getLibReferences() {
                return ts.map(ts.arrayFrom(libs.keys()), function (lib) { return ({ fileName: lib, pos: -1, end: -1 }); });
            }
            function getFileReferencesForUsedTypeReferences() {
                return necessaryTypeReferences ? ts.mapDefined(ts.arrayFrom(necessaryTypeReferences.keys()), getFileReferenceForSpecifierModeTuple) : [];
            }
            function getFileReferenceForSpecifierModeTuple(_a) {
                var typeName = _a[0], mode = _a[1];
                if (emittedImports) {
                    for (var _i = 0, emittedImports_1 = emittedImports; _i < emittedImports_1.length; _i++) {
                        var importStatement = emittedImports_1[_i];
                        if (ts.isImportEqualsDeclaration(importStatement) && ts.isExternalModuleReference(importStatement.moduleReference)) {
                            var expr = importStatement.moduleReference.expression;
                            if (ts.isStringLiteralLike(expr) && expr.text === typeName) {
                                return undefined;
                            }
                        }
                        else if (ts.isImportDeclaration(importStatement) && ts.isStringLiteral(importStatement.moduleSpecifier) && importStatement.moduleSpecifier.text === typeName) {
                            return undefined;
                        }
                    }
                }
                return __assign({ fileName: typeName, pos: -1, end: -1 }, (mode ? { resolutionMode: mode } : undefined));
            }
            function mapReferencesIntoArray(references, outputFilePath) {
                return function (file) {
                    var declFileName;
                    if (file.isDeclarationFile) {
                        declFileName = file.fileName;
                    }
                    else {
                        if (isBundledEmit && ts.contains(node.sourceFiles, file))
                            return;
                        var paths = ts.getOutputPathsFor(file, host, true);
                        declFileName = paths.declarationFilePath || paths.jsFilePath || file.fileName;
                    }
                    if (declFileName) {
                        var specifier = ts.moduleSpecifiers.getModuleSpecifier(options, currentSourceFile, ts.toPath(outputFilePath, host.getCurrentDirectory(), host.getCanonicalFileName), ts.toPath(declFileName, host.getCurrentDirectory(), host.getCanonicalFileName), host);
                        if (!ts.pathIsRelative(specifier)) {
                            recordTypeReferenceDirectivesIfNecessary([[specifier, undefined]]);
                            return;
                        }
                        var fileName = ts.getRelativePathToDirectoryOrUrl(outputFilePath, declFileName, host.getCurrentDirectory(), host.getCanonicalFileName, false);
                        if (ts.startsWith(fileName, "./") && ts.hasExtension(fileName)) {
                            fileName = fileName.substring(2);
                        }
                        if (ts.startsWith(fileName, "node_modules/") || ts.pathContainsNodeModules(fileName)) {
                            return;
                        }
                        references.push({ pos: -1, end: -1, fileName: fileName });
                    }
                };
            }
        }
        function collectReferences(sourceFile, ret) {
            if (noResolve || (!ts.isUnparsedSource(sourceFile) && ts.isSourceFileJS(sourceFile)))
                return ret;
            ts.forEach(sourceFile.referencedFiles, function (f) {
                var elem = host.getSourceFileFromReference(sourceFile, f);
                if (elem) {
                    ret.set(ts.getOriginalNodeId(elem), elem);
                }
            });
            return ret;
        }
        function collectLibs(sourceFile, ret) {
            ts.forEach(sourceFile.libReferenceDirectives, function (ref) {
                var lib = host.getLibFileFromReference(ref);
                if (lib) {
                    ret.set(ts.toFileNameLowerCase(ref.fileName), true);
                }
            });
            return ret;
        }
        function filterBindingPatternInitializersAndRenamings(name) {
            if (name.kind === 79) {
                return name;
            }
            else {
                if (name.kind === 204) {
                    return factory.updateArrayBindingPattern(name, ts.visitNodes(name.elements, visitBindingElement));
                }
                else {
                    return factory.updateObjectBindingPattern(name, ts.visitNodes(name.elements, visitBindingElement));
                }
            }
            function visitBindingElement(elem) {
                if (elem.kind === 229) {
                    return elem;
                }
                if (elem.propertyName && ts.isIdentifier(elem.propertyName) && ts.isIdentifier(elem.name) && !elem.symbol.isReferenced) {
                    return factory.updateBindingElement(elem, elem.dotDotDotToken, undefined, elem.propertyName, shouldPrintWithInitializer(elem) ? elem.initializer : undefined);
                }
                return factory.updateBindingElement(elem, elem.dotDotDotToken, elem.propertyName, filterBindingPatternInitializersAndRenamings(elem.name), shouldPrintWithInitializer(elem) ? elem.initializer : undefined);
            }
        }
        function ensureParameter(p, modifierMask, type) {
            var oldDiag;
            if (!suppressNewDiagnosticContexts) {
                oldDiag = getSymbolAccessibilityDiagnostic;
                getSymbolAccessibilityDiagnostic = ts.createGetSymbolAccessibilityDiagnosticForNode(p);
            }
            var newParam = factory.updateParameterDeclaration(p, maskModifiers(p, modifierMask), p.dotDotDotToken, filterBindingPatternInitializersAndRenamings(p.name), resolver.isOptionalParameter(p) ? (p.questionToken || factory.createToken(57)) : undefined, ensureType(p, type || p.type, true), ensureNoInitializer(p));
            if (!suppressNewDiagnosticContexts) {
                getSymbolAccessibilityDiagnostic = oldDiag;
            }
            return newParam;
        }
        function shouldPrintWithInitializer(node) {
            return canHaveLiteralInitializer(node) && resolver.isLiteralConstDeclaration(ts.getParseTreeNode(node));
        }
        function ensureNoInitializer(node) {
            if (shouldPrintWithInitializer(node)) {
                return resolver.createLiteralConstValue(ts.getParseTreeNode(node), symbolTracker);
            }
            return undefined;
        }
        function ensureType(node, type, ignorePrivate) {
            if (!ignorePrivate && ts.hasEffectiveModifier(node, 8)) {
                return;
            }
            if (shouldPrintWithInitializer(node)) {
                return;
            }
            var shouldUseResolverType = node.kind === 166 &&
                (resolver.isRequiredInitializedParameter(node) ||
                    resolver.isOptionalUninitializedParameterProperty(node));
            if (type && !shouldUseResolverType) {
                return ts.visitNode(type, visitDeclarationSubtree);
            }
            if (!ts.getParseTreeNode(node)) {
                return type ? ts.visitNode(type, visitDeclarationSubtree) : factory.createKeywordTypeNode(131);
            }
            if (node.kind === 175) {
                return factory.createKeywordTypeNode(131);
            }
            errorNameNode = node.name;
            var oldDiag;
            if (!suppressNewDiagnosticContexts) {
                oldDiag = getSymbolAccessibilityDiagnostic;
                getSymbolAccessibilityDiagnostic = ts.createGetSymbolAccessibilityDiagnosticForNode(node);
            }
            if (node.kind === 257 || node.kind === 205) {
                return cleanup(resolver.createTypeOfDeclaration(node, enclosingDeclaration, declarationEmitNodeBuilderFlags, symbolTracker));
            }
            if (node.kind === 166
                || node.kind === 169
                || node.kind === 168) {
                if (ts.isPropertySignature(node) || !node.initializer)
                    return cleanup(resolver.createTypeOfDeclaration(node, enclosingDeclaration, declarationEmitNodeBuilderFlags, symbolTracker, shouldUseResolverType));
                return cleanup(resolver.createTypeOfDeclaration(node, enclosingDeclaration, declarationEmitNodeBuilderFlags, symbolTracker, shouldUseResolverType) || resolver.createTypeOfExpression(node.initializer, enclosingDeclaration, declarationEmitNodeBuilderFlags, symbolTracker));
            }
            return cleanup(resolver.createReturnTypeOfSignatureDeclaration(node, enclosingDeclaration, declarationEmitNodeBuilderFlags, symbolTracker));
            function cleanup(returnValue) {
                errorNameNode = undefined;
                if (!suppressNewDiagnosticContexts) {
                    getSymbolAccessibilityDiagnostic = oldDiag;
                }
                return returnValue || factory.createKeywordTypeNode(131);
            }
        }
        function isDeclarationAndNotVisible(node) {
            node = ts.getParseTreeNode(node);
            switch (node.kind) {
                case 259:
                case 264:
                case 261:
                case 260:
                case 262:
                case 263:
                    return !resolver.isDeclarationVisible(node);
                case 257:
                    return !getBindingNameVisible(node);
                case 268:
                case 269:
                case 275:
                case 274:
                    return false;
                case 172:
                    return true;
            }
            return false;
        }
        function shouldEmitFunctionProperties(input) {
            var _a;
            if (input.body) {
                return true;
            }
            var overloadSignatures = (_a = input.symbol.declarations) === null || _a === void 0 ? void 0 : _a.filter(function (decl) { return ts.isFunctionDeclaration(decl) && !decl.body; });
            return !overloadSignatures || overloadSignatures.indexOf(input) === overloadSignatures.length - 1;
        }
        function getBindingNameVisible(elem) {
            if (ts.isOmittedExpression(elem)) {
                return false;
            }
            if (ts.isBindingPattern(elem.name)) {
                return ts.some(elem.name.elements, getBindingNameVisible);
            }
            else {
                return resolver.isDeclarationVisible(elem);
            }
        }
        function updateParamsList(node, params, modifierMask) {
            if (ts.hasEffectiveModifier(node, 8)) {
                return undefined;
            }
            var newParams = ts.map(params, function (p) { return ensureParameter(p, modifierMask); });
            if (!newParams) {
                return undefined;
            }
            return factory.createNodeArray(newParams, params.hasTrailingComma);
        }
        function updateAccessorParamsList(input, isPrivate) {
            var newParams;
            if (!isPrivate) {
                var thisParameter = ts.getThisParameter(input);
                if (thisParameter) {
                    newParams = [ensureParameter(thisParameter)];
                }
            }
            if (ts.isSetAccessorDeclaration(input)) {
                var newValueParameter = void 0;
                if (!isPrivate) {
                    var valueParameter = ts.getSetAccessorValueParameter(input);
                    if (valueParameter) {
                        var accessorType = getTypeAnnotationFromAllAccessorDeclarations(input, resolver.getAllAccessorDeclarations(input));
                        newValueParameter = ensureParameter(valueParameter, undefined, accessorType);
                    }
                }
                if (!newValueParameter) {
                    newValueParameter = factory.createParameterDeclaration(undefined, undefined, "value");
                }
                newParams = ts.append(newParams, newValueParameter);
            }
            return factory.createNodeArray(newParams || ts.emptyArray);
        }
        function ensureTypeParams(node, params) {
            return ts.hasEffectiveModifier(node, 8) ? undefined : ts.visitNodes(params, visitDeclarationSubtree);
        }
        function isEnclosingDeclaration(node) {
            return ts.isSourceFile(node)
                || ts.isTypeAliasDeclaration(node)
                || ts.isModuleDeclaration(node)
                || ts.isClassDeclaration(node)
                || ts.isInterfaceDeclaration(node)
                || ts.isFunctionLike(node)
                || ts.isIndexSignatureDeclaration(node)
                || ts.isMappedTypeNode(node);
        }
        function checkEntityNameVisibility(entityName, enclosingDeclaration) {
            var visibilityResult = resolver.isEntityNameVisible(entityName, enclosingDeclaration);
            handleSymbolAccessibilityError(visibilityResult);
            recordTypeReferenceDirectivesIfNecessary(resolver.getTypeReferenceDirectivesForEntityName(entityName));
        }
        function preserveJsDoc(updated, original) {
            if (ts.hasJSDocNodes(updated) && ts.hasJSDocNodes(original)) {
                updated.jsDoc = original.jsDoc;
            }
            return ts.setCommentRange(updated, ts.getCommentRange(original));
        }
        function rewriteModuleSpecifier(parent, input) {
            if (!input)
                return undefined;
            resultHasExternalModuleIndicator = resultHasExternalModuleIndicator || (parent.kind !== 264 && parent.kind !== 202);
            if (ts.isStringLiteralLike(input)) {
                if (isBundledEmit) {
                    var newName = ts.getExternalModuleNameFromDeclaration(context.getEmitHost(), resolver, parent);
                    if (newName) {
                        return factory.createStringLiteral(newName);
                    }
                }
                else {
                    var symbol = resolver.getSymbolOfExternalModuleSpecifier(input);
                    if (symbol) {
                        (exportedModulesFromDeclarationEmit || (exportedModulesFromDeclarationEmit = [])).push(symbol);
                    }
                }
            }
            return input;
        }
        function transformImportEqualsDeclaration(decl) {
            if (!resolver.isDeclarationVisible(decl))
                return;
            if (decl.moduleReference.kind === 280) {
                var specifier = ts.getExternalModuleImportEqualsDeclarationExpression(decl);
                return factory.updateImportEqualsDeclaration(decl, decl.modifiers, decl.isTypeOnly, decl.name, factory.updateExternalModuleReference(decl.moduleReference, rewriteModuleSpecifier(decl, specifier)));
            }
            else {
                var oldDiag = getSymbolAccessibilityDiagnostic;
                getSymbolAccessibilityDiagnostic = ts.createGetSymbolAccessibilityDiagnosticForNode(decl);
                checkEntityNameVisibility(decl.moduleReference, enclosingDeclaration);
                getSymbolAccessibilityDiagnostic = oldDiag;
                return decl;
            }
        }
        function transformImportDeclaration(decl) {
            if (!decl.importClause) {
                return factory.updateImportDeclaration(decl, decl.modifiers, decl.importClause, rewriteModuleSpecifier(decl, decl.moduleSpecifier), getResolutionModeOverrideForClauseInNightly(decl.assertClause));
            }
            var visibleDefaultBinding = decl.importClause && decl.importClause.name && resolver.isDeclarationVisible(decl.importClause) ? decl.importClause.name : undefined;
            if (!decl.importClause.namedBindings) {
                return visibleDefaultBinding && factory.updateImportDeclaration(decl, decl.modifiers, factory.updateImportClause(decl.importClause, decl.importClause.isTypeOnly, visibleDefaultBinding, undefined), rewriteModuleSpecifier(decl, decl.moduleSpecifier), getResolutionModeOverrideForClauseInNightly(decl.assertClause));
            }
            if (decl.importClause.namedBindings.kind === 271) {
                var namedBindings = resolver.isDeclarationVisible(decl.importClause.namedBindings) ? decl.importClause.namedBindings : undefined;
                return visibleDefaultBinding || namedBindings ? factory.updateImportDeclaration(decl, decl.modifiers, factory.updateImportClause(decl.importClause, decl.importClause.isTypeOnly, visibleDefaultBinding, namedBindings), rewriteModuleSpecifier(decl, decl.moduleSpecifier), getResolutionModeOverrideForClauseInNightly(decl.assertClause)) : undefined;
            }
            var bindingList = ts.mapDefined(decl.importClause.namedBindings.elements, function (b) { return resolver.isDeclarationVisible(b) ? b : undefined; });
            if ((bindingList && bindingList.length) || visibleDefaultBinding) {
                return factory.updateImportDeclaration(decl, decl.modifiers, factory.updateImportClause(decl.importClause, decl.importClause.isTypeOnly, visibleDefaultBinding, bindingList && bindingList.length ? factory.updateNamedImports(decl.importClause.namedBindings, bindingList) : undefined), rewriteModuleSpecifier(decl, decl.moduleSpecifier), getResolutionModeOverrideForClauseInNightly(decl.assertClause));
            }
            if (resolver.isImportRequiredByAugmentation(decl)) {
                return factory.updateImportDeclaration(decl, decl.modifiers, undefined, rewriteModuleSpecifier(decl, decl.moduleSpecifier), getResolutionModeOverrideForClauseInNightly(decl.assertClause));
            }
        }
        function getResolutionModeOverrideForClauseInNightly(assertClause) {
            var mode = ts.getResolutionModeOverrideForClause(assertClause);
            if (mode !== undefined) {
                if (!ts.isNightly()) {
                    context.addDiagnostic(ts.createDiagnosticForNode(assertClause, ts.Diagnostics.resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next));
                }
                return assertClause;
            }
            return undefined;
        }
        function transformAndReplaceLatePaintedStatements(statements) {
            while (ts.length(lateMarkedStatements)) {
                var i = lateMarkedStatements.shift();
                if (!ts.isLateVisibilityPaintedStatement(i)) {
                    return ts.Debug.fail("Late replaced statement was found which is not handled by the declaration transformer!: ".concat(ts.Debug.formatSyntaxKind(i.kind)));
                }
                var priorNeedsDeclare = needsDeclare;
                needsDeclare = i.parent && ts.isSourceFile(i.parent) && !(ts.isExternalModule(i.parent) && isBundledEmit);
                var result = transformTopLevelDeclaration(i);
                needsDeclare = priorNeedsDeclare;
                lateStatementReplacementMap.set(ts.getOriginalNodeId(i), result);
            }
            return ts.visitNodes(statements, visitLateVisibilityMarkedStatements);
            function visitLateVisibilityMarkedStatements(statement) {
                if (ts.isLateVisibilityPaintedStatement(statement)) {
                    var key = ts.getOriginalNodeId(statement);
                    if (lateStatementReplacementMap.has(key)) {
                        var result = lateStatementReplacementMap.get(key);
                        lateStatementReplacementMap.delete(key);
                        if (result) {
                            if (ts.isArray(result) ? ts.some(result, ts.needsScopeMarker) : ts.needsScopeMarker(result)) {
                                needsScopeFixMarker = true;
                            }
                            if (ts.isSourceFile(statement.parent) && (ts.isArray(result) ? ts.some(result, ts.isExternalModuleIndicator) : ts.isExternalModuleIndicator(result))) {
                                resultHasExternalModuleIndicator = true;
                            }
                        }
                        return result;
                    }
                }
                return statement;
            }
        }
        function visitDeclarationSubtree(input) {
            if (shouldStripInternal(input))
                return;
            if (ts.isDeclaration(input)) {
                if (isDeclarationAndNotVisible(input))
                    return;
                if (ts.hasDynamicName(input) && !resolver.isLateBound(ts.getParseTreeNode(input))) {
                    return;
                }
            }
            if (ts.isFunctionLike(input) && resolver.isImplementationOfOverload(input))
                return;
            if (ts.isSemicolonClassElement(input))
                return;
            var previousEnclosingDeclaration;
            if (isEnclosingDeclaration(input)) {
                previousEnclosingDeclaration = enclosingDeclaration;
                enclosingDeclaration = input;
            }
            var oldDiag = getSymbolAccessibilityDiagnostic;
            var canProduceDiagnostic = ts.canProduceDiagnostics(input);
            var oldWithinObjectLiteralType = suppressNewDiagnosticContexts;
            var shouldEnterSuppressNewDiagnosticsContextContext = ((input.kind === 184 || input.kind === 197) && input.parent.kind !== 262);
            if (ts.isMethodDeclaration(input) || ts.isMethodSignature(input)) {
                if (ts.hasEffectiveModifier(input, 8)) {
                    if (input.symbol && input.symbol.declarations && input.symbol.declarations[0] !== input)
                        return;
                    return cleanup(factory.createPropertyDeclaration(ensureModifiers(input), input.name, undefined, undefined, undefined));
                }
            }
            if (canProduceDiagnostic && !suppressNewDiagnosticContexts) {
                getSymbolAccessibilityDiagnostic = ts.createGetSymbolAccessibilityDiagnosticForNode(input);
            }
            if (ts.isTypeQueryNode(input)) {
                checkEntityNameVisibility(input.exprName, enclosingDeclaration);
            }
            if (shouldEnterSuppressNewDiagnosticsContextContext) {
                suppressNewDiagnosticContexts = true;
            }
            if (isProcessedComponent(input)) {
                switch (input.kind) {
                    case 230: {
                        if ((ts.isEntityName(input.expression) || ts.isEntityNameExpression(input.expression))) {
                            checkEntityNameVisibility(input.expression, enclosingDeclaration);
                        }
                        var node = ts.visitEachChild(input, visitDeclarationSubtree, context);
                        return cleanup(factory.updateExpressionWithTypeArguments(node, node.expression, node.typeArguments));
                    }
                    case 180: {
                        checkEntityNameVisibility(input.typeName, enclosingDeclaration);
                        var node = ts.visitEachChild(input, visitDeclarationSubtree, context);
                        return cleanup(factory.updateTypeReferenceNode(node, node.typeName, node.typeArguments));
                    }
                    case 177:
                        return cleanup(factory.updateConstructSignature(input, ensureTypeParams(input, input.typeParameters), updateParamsList(input, input.parameters), ensureType(input, input.type)));
                    case 173: {
                        var ctor = factory.createConstructorDeclaration(ensureModifiers(input), updateParamsList(input, input.parameters, 0), undefined);
                        return cleanup(ctor);
                    }
                    case 171: {
                        if (ts.isPrivateIdentifier(input.name)) {
                            return cleanup(undefined);
                        }
                        var sig = factory.createMethodDeclaration(ensureModifiers(input), undefined, input.name, input.questionToken, ensureTypeParams(input, input.typeParameters), updateParamsList(input, input.parameters), ensureType(input, input.type), undefined);
                        return cleanup(sig);
                    }
                    case 174: {
                        if (ts.isPrivateIdentifier(input.name)) {
                            return cleanup(undefined);
                        }
                        var accessorType = getTypeAnnotationFromAllAccessorDeclarations(input, resolver.getAllAccessorDeclarations(input));
                        return cleanup(factory.updateGetAccessorDeclaration(input, ensureModifiers(input), input.name, updateAccessorParamsList(input, ts.hasEffectiveModifier(input, 8)), ensureType(input, accessorType), undefined));
                    }
                    case 175: {
                        if (ts.isPrivateIdentifier(input.name)) {
                            return cleanup(undefined);
                        }
                        return cleanup(factory.updateSetAccessorDeclaration(input, ensureModifiers(input), input.name, updateAccessorParamsList(input, ts.hasEffectiveModifier(input, 8)), undefined));
                    }
                    case 169:
                        if (ts.isPrivateIdentifier(input.name)) {
                            return cleanup(undefined);
                        }
                        return cleanup(factory.updatePropertyDeclaration(input, ensureModifiers(input), input.name, input.questionToken, ensureType(input, input.type), ensureNoInitializer(input)));
                    case 168:
                        if (ts.isPrivateIdentifier(input.name)) {
                            return cleanup(undefined);
                        }
                        return cleanup(factory.updatePropertySignature(input, ensureModifiers(input), input.name, input.questionToken, ensureType(input, input.type)));
                    case 170: {
                        if (ts.isPrivateIdentifier(input.name)) {
                            return cleanup(undefined);
                        }
                        return cleanup(factory.updateMethodSignature(input, ensureModifiers(input), input.name, input.questionToken, ensureTypeParams(input, input.typeParameters), updateParamsList(input, input.parameters), ensureType(input, input.type)));
                    }
                    case 176: {
                        return cleanup(factory.updateCallSignature(input, ensureTypeParams(input, input.typeParameters), updateParamsList(input, input.parameters), ensureType(input, input.type)));
                    }
                    case 178: {
                        return cleanup(factory.updateIndexSignature(input, ensureModifiers(input), updateParamsList(input, input.parameters), ts.visitNode(input.type, visitDeclarationSubtree) || factory.createKeywordTypeNode(131)));
                    }
                    case 257: {
                        if (ts.isBindingPattern(input.name)) {
                            return recreateBindingPattern(input.name);
                        }
                        shouldEnterSuppressNewDiagnosticsContextContext = true;
                        suppressNewDiagnosticContexts = true;
                        return cleanup(factory.updateVariableDeclaration(input, input.name, undefined, ensureType(input, input.type), ensureNoInitializer(input)));
                    }
                    case 165: {
                        if (isPrivateMethodTypeParameter(input) && (input.default || input.constraint)) {
                            return cleanup(factory.updateTypeParameterDeclaration(input, input.modifiers, input.name, undefined, undefined));
                        }
                        return cleanup(ts.visitEachChild(input, visitDeclarationSubtree, context));
                    }
                    case 191: {
                        var checkType = ts.visitNode(input.checkType, visitDeclarationSubtree);
                        var extendsType = ts.visitNode(input.extendsType, visitDeclarationSubtree);
                        var oldEnclosingDecl = enclosingDeclaration;
                        enclosingDeclaration = input.trueType;
                        var trueType = ts.visitNode(input.trueType, visitDeclarationSubtree);
                        enclosingDeclaration = oldEnclosingDecl;
                        var falseType = ts.visitNode(input.falseType, visitDeclarationSubtree);
                        return cleanup(factory.updateConditionalTypeNode(input, checkType, extendsType, trueType, falseType));
                    }
                    case 181: {
                        return cleanup(factory.updateFunctionTypeNode(input, ts.visitNodes(input.typeParameters, visitDeclarationSubtree), updateParamsList(input, input.parameters), ts.visitNode(input.type, visitDeclarationSubtree)));
                    }
                    case 182: {
                        return cleanup(factory.updateConstructorTypeNode(input, ensureModifiers(input), ts.visitNodes(input.typeParameters, visitDeclarationSubtree), updateParamsList(input, input.parameters), ts.visitNode(input.type, visitDeclarationSubtree)));
                    }
                    case 202: {
                        if (!ts.isLiteralImportTypeNode(input))
                            return cleanup(input);
                        return cleanup(factory.updateImportTypeNode(input, factory.updateLiteralTypeNode(input.argument, rewriteModuleSpecifier(input, input.argument.literal)), input.assertions, input.qualifier, ts.visitNodes(input.typeArguments, visitDeclarationSubtree, ts.isTypeNode), input.isTypeOf));
                    }
                    default: ts.Debug.assertNever(input, "Attempted to process unhandled node kind: ".concat(ts.Debug.formatSyntaxKind(input.kind)));
                }
            }
            if (ts.isTupleTypeNode(input) && (ts.getLineAndCharacterOfPosition(currentSourceFile, input.pos).line === ts.getLineAndCharacterOfPosition(currentSourceFile, input.end).line)) {
                ts.setEmitFlags(input, 1);
            }
            return cleanup(ts.visitEachChild(input, visitDeclarationSubtree, context));
            function cleanup(returnValue) {
                if (returnValue && canProduceDiagnostic && ts.hasDynamicName(input)) {
                    checkName(input);
                }
                if (isEnclosingDeclaration(input)) {
                    enclosingDeclaration = previousEnclosingDeclaration;
                }
                if (canProduceDiagnostic && !suppressNewDiagnosticContexts) {
                    getSymbolAccessibilityDiagnostic = oldDiag;
                }
                if (shouldEnterSuppressNewDiagnosticsContextContext) {
                    suppressNewDiagnosticContexts = oldWithinObjectLiteralType;
                }
                if (returnValue === input) {
                    return returnValue;
                }
                return returnValue && ts.setOriginalNode(preserveJsDoc(returnValue, input), input);
            }
        }
        function isPrivateMethodTypeParameter(node) {
            return node.parent.kind === 171 && ts.hasEffectiveModifier(node.parent, 8);
        }
        function visitDeclarationStatements(input) {
            if (!isPreservedDeclarationStatement(input)) {
                return;
            }
            if (shouldStripInternal(input))
                return;
            switch (input.kind) {
                case 275: {
                    if (ts.isSourceFile(input.parent)) {
                        resultHasExternalModuleIndicator = true;
                    }
                    resultHasScopeMarker = true;
                    return factory.updateExportDeclaration(input, input.modifiers, input.isTypeOnly, input.exportClause, rewriteModuleSpecifier(input, input.moduleSpecifier), ts.getResolutionModeOverrideForClause(input.assertClause) ? input.assertClause : undefined);
                }
                case 274: {
                    if (ts.isSourceFile(input.parent)) {
                        resultHasExternalModuleIndicator = true;
                    }
                    resultHasScopeMarker = true;
                    if (input.expression.kind === 79) {
                        return input;
                    }
                    else {
                        var newId = factory.createUniqueName("_default", 16);
                        getSymbolAccessibilityDiagnostic = function () { return ({
                            diagnosticMessage: ts.Diagnostics.Default_export_of_the_module_has_or_is_using_private_name_0,
                            errorNode: input
                        }); };
                        errorFallbackNode = input;
                        var varDecl = factory.createVariableDeclaration(newId, undefined, resolver.createTypeOfExpression(input.expression, input, declarationEmitNodeBuilderFlags, symbolTracker), undefined);
                        errorFallbackNode = undefined;
                        var statement = factory.createVariableStatement(needsDeclare ? [factory.createModifier(136)] : [], factory.createVariableDeclarationList([varDecl], 2));
                        preserveJsDoc(statement, input);
                        ts.removeAllComments(input);
                        return [statement, factory.updateExportAssignment(input, input.modifiers, newId)];
                    }
                }
            }
            var result = transformTopLevelDeclaration(input);
            lateStatementReplacementMap.set(ts.getOriginalNodeId(input), result);
            return input;
        }
        function stripExportModifiers(statement) {
            if (ts.isImportEqualsDeclaration(statement) || ts.hasEffectiveModifier(statement, 1024) || !ts.canHaveModifiers(statement)) {
                return statement;
            }
            var modifiers = factory.createModifiersFromModifierFlags(ts.getEffectiveModifierFlags(statement) & (258047 ^ 1));
            return factory.updateModifiers(statement, modifiers);
        }
        function transformTopLevelDeclaration(input) {
            if (lateMarkedStatements) {
                while (ts.orderedRemoveItem(lateMarkedStatements, input))
                    ;
            }
            if (shouldStripInternal(input))
                return;
            switch (input.kind) {
                case 268: {
                    return transformImportEqualsDeclaration(input);
                }
                case 269: {
                    return transformImportDeclaration(input);
                }
            }
            if (ts.isDeclaration(input) && isDeclarationAndNotVisible(input))
                return;
            if (ts.isFunctionLike(input) && resolver.isImplementationOfOverload(input))
                return;
            var previousEnclosingDeclaration;
            if (isEnclosingDeclaration(input)) {
                previousEnclosingDeclaration = enclosingDeclaration;
                enclosingDeclaration = input;
            }
            var canProdiceDiagnostic = ts.canProduceDiagnostics(input);
            var oldDiag = getSymbolAccessibilityDiagnostic;
            if (canProdiceDiagnostic) {
                getSymbolAccessibilityDiagnostic = ts.createGetSymbolAccessibilityDiagnosticForNode(input);
            }
            var previousNeedsDeclare = needsDeclare;
            switch (input.kind) {
                case 262: {
                    needsDeclare = false;
                    var clean = cleanup(factory.updateTypeAliasDeclaration(input, ensureModifiers(input), input.name, ts.visitNodes(input.typeParameters, visitDeclarationSubtree, ts.isTypeParameterDeclaration), ts.visitNode(input.type, visitDeclarationSubtree, ts.isTypeNode)));
                    needsDeclare = previousNeedsDeclare;
                    return clean;
                }
                case 261: {
                    return cleanup(factory.updateInterfaceDeclaration(input, ensureModifiers(input), input.name, ensureTypeParams(input, input.typeParameters), transformHeritageClauses(input.heritageClauses), ts.visitNodes(input.members, visitDeclarationSubtree)));
                }
                case 259: {
                    var clean = cleanup(factory.updateFunctionDeclaration(input, ensureModifiers(input), undefined, input.name, ensureTypeParams(input, input.typeParameters), updateParamsList(input, input.parameters), ensureType(input, input.type), undefined));
                    if (clean && resolver.isExpandoFunctionDeclaration(input) && shouldEmitFunctionProperties(input)) {
                        var props = resolver.getPropertiesOfContainerFunction(input);
                        var fakespace_1 = ts.parseNodeFactory.createModuleDeclaration(undefined, clean.name || factory.createIdentifier("_default"), factory.createModuleBlock([]), 16);
                        ts.setParent(fakespace_1, enclosingDeclaration);
                        fakespace_1.locals = ts.createSymbolTable(props);
                        fakespace_1.symbol = props[0].parent;
                        var exportMappings_1 = [];
                        var declarations = ts.mapDefined(props, function (p) {
                            if (!p.valueDeclaration || !ts.isPropertyAccessExpression(p.valueDeclaration)) {
                                return undefined;
                            }
                            getSymbolAccessibilityDiagnostic = ts.createGetSymbolAccessibilityDiagnosticForNode(p.valueDeclaration);
                            var type = resolver.createTypeOfDeclaration(p.valueDeclaration, fakespace_1, declarationEmitNodeBuilderFlags, symbolTracker);
                            getSymbolAccessibilityDiagnostic = oldDiag;
                            var nameStr = ts.unescapeLeadingUnderscores(p.escapedName);
                            var isNonContextualKeywordName = ts.isStringANonContextualKeyword(nameStr);
                            var name = isNonContextualKeywordName ? factory.getGeneratedNameForNode(p.valueDeclaration) : factory.createIdentifier(nameStr);
                            if (isNonContextualKeywordName) {
                                exportMappings_1.push([name, nameStr]);
                            }
                            var varDecl = factory.createVariableDeclaration(name, undefined, type, undefined);
                            return factory.createVariableStatement(isNonContextualKeywordName ? undefined : [factory.createToken(93)], factory.createVariableDeclarationList([varDecl]));
                        });
                        if (!exportMappings_1.length) {
                            declarations = ts.mapDefined(declarations, function (declaration) { return factory.updateModifiers(declaration, 0); });
                        }
                        else {
                            declarations.push(factory.createExportDeclaration(undefined, false, factory.createNamedExports(ts.map(exportMappings_1, function (_a) {
                                var gen = _a[0], exp = _a[1];
                                return factory.createExportSpecifier(false, gen, exp);
                            }))));
                        }
                        var namespaceDecl = factory.createModuleDeclaration(ensureModifiers(input), input.name, factory.createModuleBlock(declarations), 16);
                        if (!ts.hasEffectiveModifier(clean, 1024)) {
                            return [clean, namespaceDecl];
                        }
                        var modifiers = factory.createModifiersFromModifierFlags((ts.getEffectiveModifierFlags(clean) & ~1025) | 2);
                        var cleanDeclaration = factory.updateFunctionDeclaration(clean, modifiers, undefined, clean.name, clean.typeParameters, clean.parameters, clean.type, undefined);
                        var namespaceDeclaration = factory.updateModuleDeclaration(namespaceDecl, modifiers, namespaceDecl.name, namespaceDecl.body);
                        var exportDefaultDeclaration = factory.createExportAssignment(undefined, false, namespaceDecl.name);
                        if (ts.isSourceFile(input.parent)) {
                            resultHasExternalModuleIndicator = true;
                        }
                        resultHasScopeMarker = true;
                        return [cleanDeclaration, namespaceDeclaration, exportDefaultDeclaration];
                    }
                    else {
                        return clean;
                    }
                }
                case 264: {
                    needsDeclare = false;
                    var inner = input.body;
                    if (inner && inner.kind === 265) {
                        var oldNeedsScopeFix = needsScopeFixMarker;
                        var oldHasScopeFix = resultHasScopeMarker;
                        resultHasScopeMarker = false;
                        needsScopeFixMarker = false;
                        var statements = ts.visitNodes(inner.statements, visitDeclarationStatements);
                        var lateStatements = transformAndReplaceLatePaintedStatements(statements);
                        if (input.flags & 16777216) {
                            needsScopeFixMarker = false;
                        }
                        if (!ts.isGlobalScopeAugmentation(input) && !hasScopeMarker(lateStatements) && !resultHasScopeMarker) {
                            if (needsScopeFixMarker) {
                                lateStatements = factory.createNodeArray(__spreadArray(__spreadArray([], lateStatements, true), [ts.createEmptyExports(factory)], false));
                            }
                            else {
                                lateStatements = ts.visitNodes(lateStatements, stripExportModifiers);
                            }
                        }
                        var body = factory.updateModuleBlock(inner, lateStatements);
                        needsDeclare = previousNeedsDeclare;
                        needsScopeFixMarker = oldNeedsScopeFix;
                        resultHasScopeMarker = oldHasScopeFix;
                        var mods = ensureModifiers(input);
                        return cleanup(factory.updateModuleDeclaration(input, mods, ts.isExternalModuleAugmentation(input) ? rewriteModuleSpecifier(input, input.name) : input.name, body));
                    }
                    else {
                        needsDeclare = previousNeedsDeclare;
                        var mods = ensureModifiers(input);
                        needsDeclare = false;
                        ts.visitNode(inner, visitDeclarationStatements);
                        var id = ts.getOriginalNodeId(inner);
                        var body = lateStatementReplacementMap.get(id);
                        lateStatementReplacementMap.delete(id);
                        return cleanup(factory.updateModuleDeclaration(input, mods, input.name, body));
                    }
                }
                case 260: {
                    errorNameNode = input.name;
                    errorFallbackNode = input;
                    var modifiers = factory.createNodeArray(ensureModifiers(input));
                    var typeParameters = ensureTypeParams(input, input.typeParameters);
                    var ctor = ts.getFirstConstructorWithBody(input);
                    var parameterProperties = void 0;
                    if (ctor) {
                        var oldDiag_1 = getSymbolAccessibilityDiagnostic;
                        parameterProperties = ts.compact(ts.flatMap(ctor.parameters, function (param) {
                            if (!ts.hasSyntacticModifier(param, 16476) || shouldStripInternal(param))
                                return;
                            getSymbolAccessibilityDiagnostic = ts.createGetSymbolAccessibilityDiagnosticForNode(param);
                            if (param.name.kind === 79) {
                                return preserveJsDoc(factory.createPropertyDeclaration(ensureModifiers(param), param.name, param.questionToken, ensureType(param, param.type), ensureNoInitializer(param)), param);
                            }
                            else {
                                return walkBindingPattern(param.name);
                            }
                            function walkBindingPattern(pattern) {
                                var elems;
                                for (var _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
                                    var elem = _a[_i];
                                    if (ts.isOmittedExpression(elem))
                                        continue;
                                    if (ts.isBindingPattern(elem.name)) {
                                        elems = ts.concatenate(elems, walkBindingPattern(elem.name));
                                    }
                                    elems = elems || [];
                                    elems.push(factory.createPropertyDeclaration(ensureModifiers(param), elem.name, undefined, ensureType(elem, undefined), undefined));
                                }
                                return elems;
                            }
                        }));
                        getSymbolAccessibilityDiagnostic = oldDiag_1;
                    }
                    var hasPrivateIdentifier = ts.some(input.members, function (member) { return !!member.name && ts.isPrivateIdentifier(member.name); });
                    var privateIdentifier = hasPrivateIdentifier ? [
                        factory.createPropertyDeclaration(undefined, factory.createPrivateIdentifier("#private"), undefined, undefined, undefined)
                    ] : undefined;
                    var memberNodes = ts.concatenate(ts.concatenate(privateIdentifier, parameterProperties), ts.visitNodes(input.members, visitDeclarationSubtree));
                    var members = factory.createNodeArray(memberNodes);
                    var extendsClause_1 = ts.getEffectiveBaseTypeNode(input);
                    if (extendsClause_1 && !ts.isEntityNameExpression(extendsClause_1.expression) && extendsClause_1.expression.kind !== 104) {
                        var oldId = input.name ? ts.unescapeLeadingUnderscores(input.name.escapedText) : "default";
                        var newId_1 = factory.createUniqueName("".concat(oldId, "_base"), 16);
                        getSymbolAccessibilityDiagnostic = function () { return ({
                            diagnosticMessage: ts.Diagnostics.extends_clause_of_exported_class_0_has_or_is_using_private_name_1,
                            errorNode: extendsClause_1,
                            typeName: input.name
                        }); };
                        var varDecl = factory.createVariableDeclaration(newId_1, undefined, resolver.createTypeOfExpression(extendsClause_1.expression, input, declarationEmitNodeBuilderFlags, symbolTracker), undefined);
                        var statement = factory.createVariableStatement(needsDeclare ? [factory.createModifier(136)] : [], factory.createVariableDeclarationList([varDecl], 2));
                        var heritageClauses = factory.createNodeArray(ts.map(input.heritageClauses, function (clause) {
                            if (clause.token === 94) {
                                var oldDiag_2 = getSymbolAccessibilityDiagnostic;
                                getSymbolAccessibilityDiagnostic = ts.createGetSymbolAccessibilityDiagnosticForNode(clause.types[0]);
                                var newClause = factory.updateHeritageClause(clause, ts.map(clause.types, function (t) { return factory.updateExpressionWithTypeArguments(t, newId_1, ts.visitNodes(t.typeArguments, visitDeclarationSubtree)); }));
                                getSymbolAccessibilityDiagnostic = oldDiag_2;
                                return newClause;
                            }
                            return factory.updateHeritageClause(clause, ts.visitNodes(factory.createNodeArray(ts.filter(clause.types, function (t) { return ts.isEntityNameExpression(t.expression) || t.expression.kind === 104; })), visitDeclarationSubtree));
                        }));
                        return [statement, cleanup(factory.updateClassDeclaration(input, modifiers, input.name, typeParameters, heritageClauses, members))];
                    }
                    else {
                        var heritageClauses = transformHeritageClauses(input.heritageClauses);
                        return cleanup(factory.updateClassDeclaration(input, modifiers, input.name, typeParameters, heritageClauses, members));
                    }
                }
                case 240: {
                    return cleanup(transformVariableStatement(input));
                }
                case 263: {
                    return cleanup(factory.updateEnumDeclaration(input, factory.createNodeArray(ensureModifiers(input)), input.name, factory.createNodeArray(ts.mapDefined(input.members, function (m) {
                        if (shouldStripInternal(m))
                            return;
                        var constValue = resolver.getConstantValue(m);
                        return preserveJsDoc(factory.updateEnumMember(m, m.name, constValue !== undefined ? typeof constValue === "string" ? factory.createStringLiteral(constValue) : factory.createNumericLiteral(constValue) : undefined), m);
                    }))));
                }
            }
            return ts.Debug.assertNever(input, "Unhandled top-level node in declaration emit: ".concat(ts.Debug.formatSyntaxKind(input.kind)));
            function cleanup(node) {
                if (isEnclosingDeclaration(input)) {
                    enclosingDeclaration = previousEnclosingDeclaration;
                }
                if (canProdiceDiagnostic) {
                    getSymbolAccessibilityDiagnostic = oldDiag;
                }
                if (input.kind === 264) {
                    needsDeclare = previousNeedsDeclare;
                }
                if (node === input) {
                    return node;
                }
                errorFallbackNode = undefined;
                errorNameNode = undefined;
                return node && ts.setOriginalNode(preserveJsDoc(node, input), input);
            }
        }
        function transformVariableStatement(input) {
            if (!ts.forEach(input.declarationList.declarations, getBindingNameVisible))
                return;
            var nodes = ts.visitNodes(input.declarationList.declarations, visitDeclarationSubtree);
            if (!ts.length(nodes))
                return;
            return factory.updateVariableStatement(input, factory.createNodeArray(ensureModifiers(input)), factory.updateVariableDeclarationList(input.declarationList, nodes));
        }
        function recreateBindingPattern(d) {
            return ts.flatten(ts.mapDefined(d.elements, function (e) { return recreateBindingElement(e); }));
        }
        function recreateBindingElement(e) {
            if (e.kind === 229) {
                return;
            }
            if (e.name) {
                if (!getBindingNameVisible(e))
                    return;
                if (ts.isBindingPattern(e.name)) {
                    return recreateBindingPattern(e.name);
                }
                else {
                    return factory.createVariableDeclaration(e.name, undefined, ensureType(e, undefined), undefined);
                }
            }
        }
        function checkName(node) {
            var oldDiag;
            if (!suppressNewDiagnosticContexts) {
                oldDiag = getSymbolAccessibilityDiagnostic;
                getSymbolAccessibilityDiagnostic = ts.createGetSymbolAccessibilityDiagnosticForNodeName(node);
            }
            errorNameNode = node.name;
            ts.Debug.assert(resolver.isLateBound(ts.getParseTreeNode(node)));
            var decl = node;
            var entityName = decl.name.expression;
            checkEntityNameVisibility(entityName, enclosingDeclaration);
            if (!suppressNewDiagnosticContexts) {
                getSymbolAccessibilityDiagnostic = oldDiag;
            }
            errorNameNode = undefined;
        }
        function shouldStripInternal(node) {
            return !!stripInternal && !!node && isInternalDeclaration(node, currentSourceFile);
        }
        function isScopeMarker(node) {
            return ts.isExportAssignment(node) || ts.isExportDeclaration(node);
        }
        function hasScopeMarker(statements) {
            return ts.some(statements, isScopeMarker);
        }
        function ensureModifiers(node) {
            var currentFlags = ts.getEffectiveModifierFlags(node);
            var newFlags = ensureModifierFlags(node);
            if (currentFlags === newFlags) {
                return ts.visitArray(node.modifiers, function (n) { return ts.tryCast(n, ts.isModifier); }, ts.isModifier);
            }
            return factory.createModifiersFromModifierFlags(newFlags);
        }
        function ensureModifierFlags(node) {
            var mask = 258047 ^ (4 | 512 | 16384);
            var additions = (needsDeclare && !isAlwaysType(node)) ? 2 : 0;
            var parentIsFile = node.parent.kind === 308;
            if (!parentIsFile || (isBundledEmit && parentIsFile && ts.isExternalModule(node.parent))) {
                mask ^= 2;
                additions = 0;
            }
            return maskModifierFlags(node, mask, additions);
        }
        function getTypeAnnotationFromAllAccessorDeclarations(node, accessors) {
            var accessorType = getTypeAnnotationFromAccessor(node);
            if (!accessorType && node !== accessors.firstAccessor) {
                accessorType = getTypeAnnotationFromAccessor(accessors.firstAccessor);
                getSymbolAccessibilityDiagnostic = ts.createGetSymbolAccessibilityDiagnosticForNode(accessors.firstAccessor);
            }
            if (!accessorType && accessors.secondAccessor && node !== accessors.secondAccessor) {
                accessorType = getTypeAnnotationFromAccessor(accessors.secondAccessor);
                getSymbolAccessibilityDiagnostic = ts.createGetSymbolAccessibilityDiagnosticForNode(accessors.secondAccessor);
            }
            return accessorType;
        }
        function transformHeritageClauses(nodes) {
            return factory.createNodeArray(ts.filter(ts.map(nodes, function (clause) { return factory.updateHeritageClause(clause, ts.visitNodes(factory.createNodeArray(ts.filter(clause.types, function (t) {
                return ts.isEntityNameExpression(t.expression) || (clause.token === 94 && t.expression.kind === 104);
            })), visitDeclarationSubtree)); }), function (clause) { return clause.types && !!clause.types.length; }));
        }
    }
    ts.transformDeclarations = transformDeclarations;
    function isAlwaysType(node) {
        if (node.kind === 261) {
            return true;
        }
        return false;
    }
    function maskModifiers(node, modifierMask, modifierAdditions) {
        return ts.factory.createModifiersFromModifierFlags(maskModifierFlags(node, modifierMask, modifierAdditions));
    }
    function maskModifierFlags(node, modifierMask, modifierAdditions) {
        if (modifierMask === void 0) { modifierMask = 258047 ^ 4; }
        if (modifierAdditions === void 0) { modifierAdditions = 0; }
        var flags = (ts.getEffectiveModifierFlags(node) & modifierMask) | modifierAdditions;
        if (flags & 1024 && !(flags & 1)) {
            flags ^= 1;
        }
        if (flags & 1024 && flags & 2) {
            flags ^= 2;
        }
        return flags;
    }
    function getTypeAnnotationFromAccessor(accessor) {
        if (accessor) {
            return accessor.kind === 174
                ? accessor.type
                : accessor.parameters.length > 0
                    ? accessor.parameters[0].type
                    : undefined;
        }
    }
    function canHaveLiteralInitializer(node) {
        switch (node.kind) {
            case 169:
            case 168:
                return !ts.hasEffectiveModifier(node, 8);
            case 166:
            case 257:
                return true;
        }
        return false;
    }
    function isPreservedDeclarationStatement(node) {
        switch (node.kind) {
            case 259:
            case 264:
            case 268:
            case 261:
            case 260:
            case 262:
            case 263:
            case 240:
            case 269:
            case 275:
            case 274:
                return true;
        }
        return false;
    }
    function isProcessedComponent(node) {
        switch (node.kind) {
            case 177:
            case 173:
            case 171:
            case 174:
            case 175:
            case 169:
            case 168:
            case 170:
            case 176:
            case 178:
            case 257:
            case 165:
            case 230:
            case 180:
            case 191:
            case 181:
            case 182:
            case 202:
                return true;
        }
        return false;
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function getModuleTransformer(moduleKind) {
        switch (moduleKind) {
            case ts.ModuleKind.ESNext:
            case ts.ModuleKind.ES2022:
            case ts.ModuleKind.ES2020:
            case ts.ModuleKind.ES2015:
                return ts.transformECMAScriptModule;
            case ts.ModuleKind.System:
                return ts.transformSystemModule;
            case ts.ModuleKind.Node16:
            case ts.ModuleKind.NodeNext:
                return ts.transformNodeModule;
            default:
                return ts.transformModule;
        }
    }
    ts.noTransformers = { scriptTransformers: ts.emptyArray, declarationTransformers: ts.emptyArray };
    function getTransformers(compilerOptions, customTransformers, emitOnlyDtsFiles) {
        return {
            scriptTransformers: getScriptTransformers(compilerOptions, customTransformers, emitOnlyDtsFiles),
            declarationTransformers: getDeclarationTransformers(customTransformers),
        };
    }
    ts.getTransformers = getTransformers;
    function getScriptTransformers(compilerOptions, customTransformers, emitOnlyDtsFiles) {
        if (emitOnlyDtsFiles)
            return ts.emptyArray;
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var moduleKind = ts.getEmitModuleKind(compilerOptions);
        var transformers = [];
        ts.addRange(transformers, customTransformers && ts.map(customTransformers.before, wrapScriptTransformerFactory));
        transformers.push(ts.transformTypeScript);
        transformers.push(ts.transformLegacyDecorators);
        transformers.push(ts.transformClassFields);
        if (ts.getJSXTransformEnabled(compilerOptions)) {
            transformers.push(ts.transformJsx);
        }
        if (languageVersion < 99) {
            transformers.push(ts.transformESNext);
        }
        if (languageVersion < 8) {
            transformers.push(ts.transformES2021);
        }
        if (languageVersion < 7) {
            transformers.push(ts.transformES2020);
        }
        if (languageVersion < 6) {
            transformers.push(ts.transformES2019);
        }
        if (languageVersion < 5) {
            transformers.push(ts.transformES2018);
        }
        if (languageVersion < 4) {
            transformers.push(ts.transformES2017);
        }
        if (languageVersion < 3) {
            transformers.push(ts.transformES2016);
        }
        if (languageVersion < 2) {
            transformers.push(ts.transformES2015);
            transformers.push(ts.transformGenerators);
        }
        transformers.push(getModuleTransformer(moduleKind));
        if (languageVersion < 1) {
            transformers.push(ts.transformES5);
        }
        ts.addRange(transformers, customTransformers && ts.map(customTransformers.after, wrapScriptTransformerFactory));
        return transformers;
    }
    function getDeclarationTransformers(customTransformers) {
        var transformers = [];
        transformers.push(ts.transformDeclarations);
        ts.addRange(transformers, customTransformers && ts.map(customTransformers.afterDeclarations, wrapDeclarationTransformerFactory));
        return transformers;
    }
    function wrapCustomTransformer(transformer) {
        return function (node) { return ts.isBundle(node) ? transformer.transformBundle(node) : transformer.transformSourceFile(node); };
    }
    function wrapCustomTransformerFactory(transformer, handleDefault) {
        return function (context) {
            var customTransformer = transformer(context);
            return typeof customTransformer === "function"
                ? handleDefault(context, customTransformer)
                : wrapCustomTransformer(customTransformer);
        };
    }
    function wrapScriptTransformerFactory(transformer) {
        return wrapCustomTransformerFactory(transformer, ts.chainBundle);
    }
    function wrapDeclarationTransformerFactory(transformer) {
        return wrapCustomTransformerFactory(transformer, function (_, node) { return node; });
    }
    function noEmitSubstitution(_hint, node) {
        return node;
    }
    ts.noEmitSubstitution = noEmitSubstitution;
    function noEmitNotification(hint, node, callback) {
        callback(hint, node);
    }
    ts.noEmitNotification = noEmitNotification;
    function transformNodes(resolver, host, factory, options, nodes, transformers, allowDtsFiles) {
        var enabledSyntaxKindFeatures = new Array(358);
        var lexicalEnvironmentVariableDeclarations;
        var lexicalEnvironmentFunctionDeclarations;
        var lexicalEnvironmentStatements;
        var lexicalEnvironmentFlags = 0;
        var lexicalEnvironmentVariableDeclarationsStack = [];
        var lexicalEnvironmentFunctionDeclarationsStack = [];
        var lexicalEnvironmentStatementsStack = [];
        var lexicalEnvironmentFlagsStack = [];
        var lexicalEnvironmentStackOffset = 0;
        var lexicalEnvironmentSuspended = false;
        var blockScopedVariableDeclarationsStack = [];
        var blockScopeStackOffset = 0;
        var blockScopedVariableDeclarations;
        var emitHelpers;
        var onSubstituteNode = noEmitSubstitution;
        var onEmitNode = noEmitNotification;
        var state = 0;
        var diagnostics = [];
        var context = {
            factory: factory,
            getCompilerOptions: function () { return options; },
            getEmitResolver: function () { return resolver; },
            getEmitHost: function () { return host; },
            getEmitHelperFactory: ts.memoize(function () { return ts.createEmitHelperFactory(context); }),
            startLexicalEnvironment: startLexicalEnvironment,
            suspendLexicalEnvironment: suspendLexicalEnvironment,
            resumeLexicalEnvironment: resumeLexicalEnvironment,
            endLexicalEnvironment: endLexicalEnvironment,
            setLexicalEnvironmentFlags: setLexicalEnvironmentFlags,
            getLexicalEnvironmentFlags: getLexicalEnvironmentFlags,
            hoistVariableDeclaration: hoistVariableDeclaration,
            hoistFunctionDeclaration: hoistFunctionDeclaration,
            addInitializationStatement: addInitializationStatement,
            startBlockScope: startBlockScope,
            endBlockScope: endBlockScope,
            addBlockScopedVariable: addBlockScopedVariable,
            requestEmitHelper: requestEmitHelper,
            readEmitHelpers: readEmitHelpers,
            enableSubstitution: enableSubstitution,
            enableEmitNotification: enableEmitNotification,
            isSubstitutionEnabled: isSubstitutionEnabled,
            isEmitNotificationEnabled: isEmitNotificationEnabled,
            get onSubstituteNode() { return onSubstituteNode; },
            set onSubstituteNode(value) {
                ts.Debug.assert(state < 1, "Cannot modify transformation hooks after initialization has completed.");
                ts.Debug.assert(value !== undefined, "Value must not be 'undefined'");
                onSubstituteNode = value;
            },
            get onEmitNode() { return onEmitNode; },
            set onEmitNode(value) {
                ts.Debug.assert(state < 1, "Cannot modify transformation hooks after initialization has completed.");
                ts.Debug.assert(value !== undefined, "Value must not be 'undefined'");
                onEmitNode = value;
            },
            addDiagnostic: function (diag) {
                diagnostics.push(diag);
            }
        };
        for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
            var node = nodes_2[_i];
            ts.disposeEmitNodes(ts.getSourceFileOfNode(ts.getParseTreeNode(node)));
        }
        ts.performance.mark("beforeTransform");
        var transformersWithContext = transformers.map(function (t) { return t(context); });
        var transformation = function (node) {
            for (var _i = 0, transformersWithContext_1 = transformersWithContext; _i < transformersWithContext_1.length; _i++) {
                var transform = transformersWithContext_1[_i];
                node = transform(node);
            }
            return node;
        };
        state = 1;
        var transformed = [];
        for (var _a = 0, nodes_3 = nodes; _a < nodes_3.length; _a++) {
            var node = nodes_3[_a];
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("emit", "transformNodes", node.kind === 308 ? { path: node.path } : { kind: node.kind, pos: node.pos, end: node.end });
            transformed.push((allowDtsFiles ? transformation : transformRoot)(node));
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        }
        state = 2;
        ts.performance.mark("afterTransform");
        ts.performance.measure("transformTime", "beforeTransform", "afterTransform");
        return {
            transformed: transformed,
            substituteNode: substituteNode,
            emitNodeWithNotification: emitNodeWithNotification,
            isEmitNotificationEnabled: isEmitNotificationEnabled,
            dispose: dispose,
            diagnostics: diagnostics
        };
        function transformRoot(node) {
            return node && (!ts.isSourceFile(node) || !node.isDeclarationFile) ? transformation(node) : node;
        }
        function enableSubstitution(kind) {
            ts.Debug.assert(state < 2, "Cannot modify the transformation context after transformation has completed.");
            enabledSyntaxKindFeatures[kind] |= 1;
        }
        function isSubstitutionEnabled(node) {
            return (enabledSyntaxKindFeatures[node.kind] & 1) !== 0
                && (ts.getEmitFlags(node) & 4) === 0;
        }
        function substituteNode(hint, node) {
            ts.Debug.assert(state < 3, "Cannot substitute a node after the result is disposed.");
            return node && isSubstitutionEnabled(node) && onSubstituteNode(hint, node) || node;
        }
        function enableEmitNotification(kind) {
            ts.Debug.assert(state < 2, "Cannot modify the transformation context after transformation has completed.");
            enabledSyntaxKindFeatures[kind] |= 2;
        }
        function isEmitNotificationEnabled(node) {
            return (enabledSyntaxKindFeatures[node.kind] & 2) !== 0
                || (ts.getEmitFlags(node) & 2) !== 0;
        }
        function emitNodeWithNotification(hint, node, emitCallback) {
            ts.Debug.assert(state < 3, "Cannot invoke TransformationResult callbacks after the result is disposed.");
            if (node) {
                if (isEmitNotificationEnabled(node)) {
                    onEmitNode(hint, node, emitCallback);
                }
                else {
                    emitCallback(hint, node);
                }
            }
        }
        function hoistVariableDeclaration(name) {
            ts.Debug.assert(state > 0, "Cannot modify the lexical environment during initialization.");
            ts.Debug.assert(state < 2, "Cannot modify the lexical environment after transformation has completed.");
            var decl = ts.setEmitFlags(factory.createVariableDeclaration(name), 64);
            if (!lexicalEnvironmentVariableDeclarations) {
                lexicalEnvironmentVariableDeclarations = [decl];
            }
            else {
                lexicalEnvironmentVariableDeclarations.push(decl);
            }
            if (lexicalEnvironmentFlags & 1) {
                lexicalEnvironmentFlags |= 2;
            }
        }
        function hoistFunctionDeclaration(func) {
            ts.Debug.assert(state > 0, "Cannot modify the lexical environment during initialization.");
            ts.Debug.assert(state < 2, "Cannot modify the lexical environment after transformation has completed.");
            ts.setEmitFlags(func, 1048576);
            if (!lexicalEnvironmentFunctionDeclarations) {
                lexicalEnvironmentFunctionDeclarations = [func];
            }
            else {
                lexicalEnvironmentFunctionDeclarations.push(func);
            }
        }
        function addInitializationStatement(node) {
            ts.Debug.assert(state > 0, "Cannot modify the lexical environment during initialization.");
            ts.Debug.assert(state < 2, "Cannot modify the lexical environment after transformation has completed.");
            ts.setEmitFlags(node, 1048576);
            if (!lexicalEnvironmentStatements) {
                lexicalEnvironmentStatements = [node];
            }
            else {
                lexicalEnvironmentStatements.push(node);
            }
        }
        function startLexicalEnvironment() {
            ts.Debug.assert(state > 0, "Cannot modify the lexical environment during initialization.");
            ts.Debug.assert(state < 2, "Cannot modify the lexical environment after transformation has completed.");
            ts.Debug.assert(!lexicalEnvironmentSuspended, "Lexical environment is suspended.");
            lexicalEnvironmentVariableDeclarationsStack[lexicalEnvironmentStackOffset] = lexicalEnvironmentVariableDeclarations;
            lexicalEnvironmentFunctionDeclarationsStack[lexicalEnvironmentStackOffset] = lexicalEnvironmentFunctionDeclarations;
            lexicalEnvironmentStatementsStack[lexicalEnvironmentStackOffset] = lexicalEnvironmentStatements;
            lexicalEnvironmentFlagsStack[lexicalEnvironmentStackOffset] = lexicalEnvironmentFlags;
            lexicalEnvironmentStackOffset++;
            lexicalEnvironmentVariableDeclarations = undefined;
            lexicalEnvironmentFunctionDeclarations = undefined;
            lexicalEnvironmentStatements = undefined;
            lexicalEnvironmentFlags = 0;
        }
        function suspendLexicalEnvironment() {
            ts.Debug.assert(state > 0, "Cannot modify the lexical environment during initialization.");
            ts.Debug.assert(state < 2, "Cannot modify the lexical environment after transformation has completed.");
            ts.Debug.assert(!lexicalEnvironmentSuspended, "Lexical environment is already suspended.");
            lexicalEnvironmentSuspended = true;
        }
        function resumeLexicalEnvironment() {
            ts.Debug.assert(state > 0, "Cannot modify the lexical environment during initialization.");
            ts.Debug.assert(state < 2, "Cannot modify the lexical environment after transformation has completed.");
            ts.Debug.assert(lexicalEnvironmentSuspended, "Lexical environment is not suspended.");
            lexicalEnvironmentSuspended = false;
        }
        function endLexicalEnvironment() {
            ts.Debug.assert(state > 0, "Cannot modify the lexical environment during initialization.");
            ts.Debug.assert(state < 2, "Cannot modify the lexical environment after transformation has completed.");
            ts.Debug.assert(!lexicalEnvironmentSuspended, "Lexical environment is suspended.");
            var statements;
            if (lexicalEnvironmentVariableDeclarations ||
                lexicalEnvironmentFunctionDeclarations ||
                lexicalEnvironmentStatements) {
                if (lexicalEnvironmentFunctionDeclarations) {
                    statements = __spreadArray([], lexicalEnvironmentFunctionDeclarations, true);
                }
                if (lexicalEnvironmentVariableDeclarations) {
                    var statement = factory.createVariableStatement(undefined, factory.createVariableDeclarationList(lexicalEnvironmentVariableDeclarations));
                    ts.setEmitFlags(statement, 1048576);
                    if (!statements) {
                        statements = [statement];
                    }
                    else {
                        statements.push(statement);
                    }
                }
                if (lexicalEnvironmentStatements) {
                    if (!statements) {
                        statements = __spreadArray([], lexicalEnvironmentStatements, true);
                    }
                    else {
                        statements = __spreadArray(__spreadArray([], statements, true), lexicalEnvironmentStatements, true);
                    }
                }
            }
            lexicalEnvironmentStackOffset--;
            lexicalEnvironmentVariableDeclarations = lexicalEnvironmentVariableDeclarationsStack[lexicalEnvironmentStackOffset];
            lexicalEnvironmentFunctionDeclarations = lexicalEnvironmentFunctionDeclarationsStack[lexicalEnvironmentStackOffset];
            lexicalEnvironmentStatements = lexicalEnvironmentStatementsStack[lexicalEnvironmentStackOffset];
            lexicalEnvironmentFlags = lexicalEnvironmentFlagsStack[lexicalEnvironmentStackOffset];
            if (lexicalEnvironmentStackOffset === 0) {
                lexicalEnvironmentVariableDeclarationsStack = [];
                lexicalEnvironmentFunctionDeclarationsStack = [];
                lexicalEnvironmentStatementsStack = [];
                lexicalEnvironmentFlagsStack = [];
            }
            return statements;
        }
        function setLexicalEnvironmentFlags(flags, value) {
            lexicalEnvironmentFlags = value ?
                lexicalEnvironmentFlags | flags :
                lexicalEnvironmentFlags & ~flags;
        }
        function getLexicalEnvironmentFlags() {
            return lexicalEnvironmentFlags;
        }
        function startBlockScope() {
            ts.Debug.assert(state > 0, "Cannot start a block scope during initialization.");
            ts.Debug.assert(state < 2, "Cannot start a block scope after transformation has completed.");
            blockScopedVariableDeclarationsStack[blockScopeStackOffset] = blockScopedVariableDeclarations;
            blockScopeStackOffset++;
            blockScopedVariableDeclarations = undefined;
        }
        function endBlockScope() {
            ts.Debug.assert(state > 0, "Cannot end a block scope during initialization.");
            ts.Debug.assert(state < 2, "Cannot end a block scope after transformation has completed.");
            var statements = ts.some(blockScopedVariableDeclarations) ?
                [
                    factory.createVariableStatement(undefined, factory.createVariableDeclarationList(blockScopedVariableDeclarations.map(function (identifier) { return factory.createVariableDeclaration(identifier); }), 1))
                ] : undefined;
            blockScopeStackOffset--;
            blockScopedVariableDeclarations = blockScopedVariableDeclarationsStack[blockScopeStackOffset];
            if (blockScopeStackOffset === 0) {
                blockScopedVariableDeclarationsStack = [];
            }
            return statements;
        }
        function addBlockScopedVariable(name) {
            ts.Debug.assert(blockScopeStackOffset > 0, "Cannot add a block scoped variable outside of an iteration body.");
            (blockScopedVariableDeclarations || (blockScopedVariableDeclarations = [])).push(name);
        }
        function requestEmitHelper(helper) {
            ts.Debug.assert(state > 0, "Cannot modify the transformation context during initialization.");
            ts.Debug.assert(state < 2, "Cannot modify the transformation context after transformation has completed.");
            ts.Debug.assert(!helper.scoped, "Cannot request a scoped emit helper.");
            if (helper.dependencies) {
                for (var _i = 0, _a = helper.dependencies; _i < _a.length; _i++) {
                    var h = _a[_i];
                    requestEmitHelper(h);
                }
            }
            emitHelpers = ts.append(emitHelpers, helper);
        }
        function readEmitHelpers() {
            ts.Debug.assert(state > 0, "Cannot modify the transformation context during initialization.");
            ts.Debug.assert(state < 2, "Cannot modify the transformation context after transformation has completed.");
            var helpers = emitHelpers;
            emitHelpers = undefined;
            return helpers;
        }
        function dispose() {
            if (state < 3) {
                for (var _i = 0, nodes_4 = nodes; _i < nodes_4.length; _i++) {
                    var node = nodes_4[_i];
                    ts.disposeEmitNodes(ts.getSourceFileOfNode(ts.getParseTreeNode(node)));
                }
                lexicalEnvironmentVariableDeclarations = undefined;
                lexicalEnvironmentVariableDeclarationsStack = undefined;
                lexicalEnvironmentFunctionDeclarations = undefined;
                lexicalEnvironmentFunctionDeclarationsStack = undefined;
                onSubstituteNode = undefined;
                onEmitNode = undefined;
                emitHelpers = undefined;
                state = 3;
            }
        }
    }
    ts.transformNodes = transformNodes;
    ts.nullTransformationContext = {
        factory: ts.factory,
        getCompilerOptions: function () { return ({}); },
        getEmitResolver: ts.notImplemented,
        getEmitHost: ts.notImplemented,
        getEmitHelperFactory: ts.notImplemented,
        startLexicalEnvironment: ts.noop,
        resumeLexicalEnvironment: ts.noop,
        suspendLexicalEnvironment: ts.noop,
        endLexicalEnvironment: ts.returnUndefined,
        setLexicalEnvironmentFlags: ts.noop,
        getLexicalEnvironmentFlags: function () { return 0; },
        hoistVariableDeclaration: ts.noop,
        hoistFunctionDeclaration: ts.noop,
        addInitializationStatement: ts.noop,
        startBlockScope: ts.noop,
        endBlockScope: ts.returnUndefined,
        addBlockScopedVariable: ts.noop,
        requestEmitHelper: ts.noop,
        readEmitHelpers: ts.notImplemented,
        enableSubstitution: ts.noop,
        enableEmitNotification: ts.noop,
        isSubstitutionEnabled: ts.notImplemented,
        isEmitNotificationEnabled: ts.notImplemented,
        onSubstituteNode: noEmitSubstitution,
        onEmitNode: noEmitNotification,
        addDiagnostic: ts.noop,
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    var brackets = createBracketsMap();
    function isBuildInfoFile(file) {
        return ts.fileExtensionIs(file, ".tsbuildinfo");
    }
    ts.isBuildInfoFile = isBuildInfoFile;
    function forEachEmittedFile(host, action, sourceFilesOrTargetSourceFile, forceDtsEmit, onlyBuildInfo, includeBuildInfo) {
        if (forceDtsEmit === void 0) { forceDtsEmit = false; }
        var sourceFiles = ts.isArray(sourceFilesOrTargetSourceFile) ? sourceFilesOrTargetSourceFile : ts.getSourceFilesToEmit(host, sourceFilesOrTargetSourceFile, forceDtsEmit);
        var options = host.getCompilerOptions();
        if (ts.outFile(options)) {
            var prepends = host.getPrependNodes();
            if (sourceFiles.length || prepends.length) {
                var bundle = ts.factory.createBundle(sourceFiles, prepends);
                var result = action(getOutputPathsFor(bundle, host, forceDtsEmit), bundle);
                if (result) {
                    return result;
                }
            }
        }
        else {
            if (!onlyBuildInfo) {
                for (var _a = 0, sourceFiles_1 = sourceFiles; _a < sourceFiles_1.length; _a++) {
                    var sourceFile = sourceFiles_1[_a];
                    var result = action(getOutputPathsFor(sourceFile, host, forceDtsEmit), sourceFile);
                    if (result) {
                        return result;
                    }
                }
            }
            if (includeBuildInfo) {
                var buildInfoPath = getTsBuildInfoEmitOutputFilePath(options);
                if (buildInfoPath)
                    return action({ buildInfoPath: buildInfoPath }, undefined);
            }
        }
    }
    ts.forEachEmittedFile = forEachEmittedFile;
    function getTsBuildInfoEmitOutputFilePath(options) {
        var configFile = options.configFilePath;
        if (!ts.isIncrementalCompilation(options))
            return undefined;
        if (options.tsBuildInfoFile)
            return options.tsBuildInfoFile;
        var outPath = ts.outFile(options);
        var buildInfoExtensionLess;
        if (outPath) {
            buildInfoExtensionLess = ts.removeFileExtension(outPath);
        }
        else {
            if (!configFile)
                return undefined;
            var configFileExtensionLess = ts.removeFileExtension(configFile);
            buildInfoExtensionLess = options.outDir ?
                options.rootDir ?
                    ts.resolvePath(options.outDir, ts.getRelativePathFromDirectory(options.rootDir, configFileExtensionLess, true)) :
                    ts.combinePaths(options.outDir, ts.getBaseFileName(configFileExtensionLess)) :
                configFileExtensionLess;
        }
        return buildInfoExtensionLess + ".tsbuildinfo";
    }
    ts.getTsBuildInfoEmitOutputFilePath = getTsBuildInfoEmitOutputFilePath;
    function getOutputPathsForBundle(options, forceDtsPaths) {
        var outPath = ts.outFile(options);
        var jsFilePath = options.emitDeclarationOnly ? undefined : outPath;
        var sourceMapFilePath = jsFilePath && getSourceMapFilePath(jsFilePath, options);
        var declarationFilePath = (forceDtsPaths || ts.getEmitDeclarations(options)) ? ts.removeFileExtension(outPath) + ".d.ts" : undefined;
        var declarationMapPath = declarationFilePath && ts.getAreDeclarationMapsEnabled(options) ? declarationFilePath + ".map" : undefined;
        var buildInfoPath = getTsBuildInfoEmitOutputFilePath(options);
        return { jsFilePath: jsFilePath, sourceMapFilePath: sourceMapFilePath, declarationFilePath: declarationFilePath, declarationMapPath: declarationMapPath, buildInfoPath: buildInfoPath };
    }
    ts.getOutputPathsForBundle = getOutputPathsForBundle;
    function getOutputPathsFor(sourceFile, host, forceDtsPaths) {
        var options = host.getCompilerOptions();
        if (sourceFile.kind === 309) {
            return getOutputPathsForBundle(options, forceDtsPaths);
        }
        else {
            var ownOutputFilePath = ts.getOwnEmitOutputFilePath(sourceFile.fileName, host, getOutputExtension(sourceFile.fileName, options));
            var isJsonFile = ts.isJsonSourceFile(sourceFile);
            var isJsonEmittedToSameLocation = isJsonFile &&
                ts.comparePaths(sourceFile.fileName, ownOutputFilePath, host.getCurrentDirectory(), !host.useCaseSensitiveFileNames()) === 0;
            var jsFilePath = options.emitDeclarationOnly || isJsonEmittedToSameLocation ? undefined : ownOutputFilePath;
            var sourceMapFilePath = !jsFilePath || ts.isJsonSourceFile(sourceFile) ? undefined : getSourceMapFilePath(jsFilePath, options);
            var declarationFilePath = (forceDtsPaths || (ts.getEmitDeclarations(options) && !isJsonFile)) ? ts.getDeclarationEmitOutputFilePath(sourceFile.fileName, host) : undefined;
            var declarationMapPath = declarationFilePath && ts.getAreDeclarationMapsEnabled(options) ? declarationFilePath + ".map" : undefined;
            return { jsFilePath: jsFilePath, sourceMapFilePath: sourceMapFilePath, declarationFilePath: declarationFilePath, declarationMapPath: declarationMapPath, buildInfoPath: undefined };
        }
    }
    ts.getOutputPathsFor = getOutputPathsFor;
    function getSourceMapFilePath(jsFilePath, options) {
        return (options.sourceMap && !options.inlineSourceMap) ? jsFilePath + ".map" : undefined;
    }
    function getOutputExtension(fileName, options) {
        return ts.fileExtensionIs(fileName, ".json") ? ".json" :
            options.jsx === 1 && ts.fileExtensionIsOneOf(fileName, [".jsx", ".tsx"]) ? ".jsx" :
                ts.fileExtensionIsOneOf(fileName, [".mts", ".mjs"]) ? ".mjs" :
                    ts.fileExtensionIsOneOf(fileName, [".cts", ".cjs"]) ? ".cjs" :
                        ".js";
    }
    ts.getOutputExtension = getOutputExtension;
    function getOutputPathWithoutChangingExt(inputFileName, configFile, ignoreCase, outputDir, getCommonSourceDirectory) {
        return outputDir ?
            ts.resolvePath(outputDir, ts.getRelativePathFromDirectory(getCommonSourceDirectory ? getCommonSourceDirectory() : getCommonSourceDirectoryOfConfig(configFile, ignoreCase), inputFileName, ignoreCase)) :
            inputFileName;
    }
    function getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory) {
        return ts.changeExtension(getOutputPathWithoutChangingExt(inputFileName, configFile, ignoreCase, configFile.options.declarationDir || configFile.options.outDir, getCommonSourceDirectory), ts.getDeclarationEmitExtensionForPath(inputFileName));
    }
    ts.getOutputDeclarationFileName = getOutputDeclarationFileName;
    function getOutputJSFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory) {
        if (configFile.options.emitDeclarationOnly)
            return undefined;
        var isJsonFile = ts.fileExtensionIs(inputFileName, ".json");
        var outputFileName = ts.changeExtension(getOutputPathWithoutChangingExt(inputFileName, configFile, ignoreCase, configFile.options.outDir, getCommonSourceDirectory), getOutputExtension(inputFileName, configFile.options));
        return !isJsonFile || ts.comparePaths(inputFileName, outputFileName, ts.Debug.checkDefined(configFile.options.configFilePath), ignoreCase) !== 0 ?
            outputFileName :
            undefined;
    }
    function createAddOutput() {
        var outputs;
        return { addOutput: addOutput, getOutputs: getOutputs };
        function addOutput(path) {
            if (path) {
                (outputs || (outputs = [])).push(path);
            }
        }
        function getOutputs() {
            return outputs || ts.emptyArray;
        }
    }
    function getSingleOutputFileNames(configFile, addOutput) {
        var _a = getOutputPathsForBundle(configFile.options, false), jsFilePath = _a.jsFilePath, sourceMapFilePath = _a.sourceMapFilePath, declarationFilePath = _a.declarationFilePath, declarationMapPath = _a.declarationMapPath, buildInfoPath = _a.buildInfoPath;
        addOutput(jsFilePath);
        addOutput(sourceMapFilePath);
        addOutput(declarationFilePath);
        addOutput(declarationMapPath);
        addOutput(buildInfoPath);
    }
    function getOwnOutputFileNames(configFile, inputFileName, ignoreCase, addOutput, getCommonSourceDirectory) {
        if (ts.isDeclarationFileName(inputFileName))
            return;
        var js = getOutputJSFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory);
        addOutput(js);
        if (ts.fileExtensionIs(inputFileName, ".json"))
            return;
        if (js && configFile.options.sourceMap) {
            addOutput("".concat(js, ".map"));
        }
        if (ts.getEmitDeclarations(configFile.options)) {
            var dts = getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory);
            addOutput(dts);
            if (configFile.options.declarationMap) {
                addOutput("".concat(dts, ".map"));
            }
        }
    }
    function getCommonSourceDirectory(options, emittedFiles, currentDirectory, getCanonicalFileName, checkSourceFilesBelongToPath) {
        var commonSourceDirectory;
        if (options.rootDir) {
            commonSourceDirectory = ts.getNormalizedAbsolutePath(options.rootDir, currentDirectory);
            checkSourceFilesBelongToPath === null || checkSourceFilesBelongToPath === void 0 ? void 0 : checkSourceFilesBelongToPath(options.rootDir);
        }
        else if (options.composite && options.configFilePath) {
            commonSourceDirectory = ts.getDirectoryPath(ts.normalizeSlashes(options.configFilePath));
            checkSourceFilesBelongToPath === null || checkSourceFilesBelongToPath === void 0 ? void 0 : checkSourceFilesBelongToPath(commonSourceDirectory);
        }
        else {
            commonSourceDirectory = ts.computeCommonSourceDirectoryOfFilenames(emittedFiles(), currentDirectory, getCanonicalFileName);
        }
        if (commonSourceDirectory && commonSourceDirectory[commonSourceDirectory.length - 1] !== ts.directorySeparator) {
            commonSourceDirectory += ts.directorySeparator;
        }
        return commonSourceDirectory;
    }
    ts.getCommonSourceDirectory = getCommonSourceDirectory;
    function getCommonSourceDirectoryOfConfig(_a, ignoreCase) {
        var options = _a.options, fileNames = _a.fileNames;
        return getCommonSourceDirectory(options, function () { return ts.filter(fileNames, function (file) { return !(options.noEmitForJsFiles && ts.fileExtensionIsOneOf(file, ts.supportedJSExtensionsFlat)) && !ts.isDeclarationFileName(file); }); }, ts.getDirectoryPath(ts.normalizeSlashes(ts.Debug.checkDefined(options.configFilePath))), ts.createGetCanonicalFileName(!ignoreCase));
    }
    ts.getCommonSourceDirectoryOfConfig = getCommonSourceDirectoryOfConfig;
    function getAllProjectOutputs(configFile, ignoreCase) {
        var _a = createAddOutput(), addOutput = _a.addOutput, getOutputs = _a.getOutputs;
        if (ts.outFile(configFile.options)) {
            getSingleOutputFileNames(configFile, addOutput);
        }
        else {
            var getCommonSourceDirectory_1 = ts.memoize(function () { return getCommonSourceDirectoryOfConfig(configFile, ignoreCase); });
            for (var _b = 0, _c = configFile.fileNames; _b < _c.length; _b++) {
                var inputFileName = _c[_b];
                getOwnOutputFileNames(configFile, inputFileName, ignoreCase, addOutput, getCommonSourceDirectory_1);
            }
            addOutput(getTsBuildInfoEmitOutputFilePath(configFile.options));
        }
        return getOutputs();
    }
    ts.getAllProjectOutputs = getAllProjectOutputs;
    function getOutputFileNames(commandLine, inputFileName, ignoreCase) {
        inputFileName = ts.normalizePath(inputFileName);
        ts.Debug.assert(ts.contains(commandLine.fileNames, inputFileName), "Expected fileName to be present in command line");
        var _a = createAddOutput(), addOutput = _a.addOutput, getOutputs = _a.getOutputs;
        if (ts.outFile(commandLine.options)) {
            getSingleOutputFileNames(commandLine, addOutput);
        }
        else {
            getOwnOutputFileNames(commandLine, inputFileName, ignoreCase, addOutput);
        }
        return getOutputs();
    }
    ts.getOutputFileNames = getOutputFileNames;
    function getFirstProjectOutput(configFile, ignoreCase) {
        if (ts.outFile(configFile.options)) {
            var jsFilePath = getOutputPathsForBundle(configFile.options, false).jsFilePath;
            return ts.Debug.checkDefined(jsFilePath, "project ".concat(configFile.options.configFilePath, " expected to have at least one output"));
        }
        var getCommonSourceDirectory = ts.memoize(function () { return getCommonSourceDirectoryOfConfig(configFile, ignoreCase); });
        for (var _a = 0, _b = configFile.fileNames; _a < _b.length; _a++) {
            var inputFileName = _b[_a];
            if (ts.isDeclarationFileName(inputFileName))
                continue;
            var jsFilePath = getOutputJSFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory);
            if (jsFilePath)
                return jsFilePath;
            if (ts.fileExtensionIs(inputFileName, ".json"))
                continue;
            if (ts.getEmitDeclarations(configFile.options)) {
                return getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory);
            }
        }
        var buildInfoPath = getTsBuildInfoEmitOutputFilePath(configFile.options);
        if (buildInfoPath)
            return buildInfoPath;
        return ts.Debug.fail("project ".concat(configFile.options.configFilePath, " expected to have at least one output"));
    }
    ts.getFirstProjectOutput = getFirstProjectOutput;
    function emitFiles(resolver, host, targetSourceFile, _a, emitOnlyDtsFiles, onlyBuildInfo, forceDtsEmit) {
        var scriptTransformers = _a.scriptTransformers, declarationTransformers = _a.declarationTransformers;
        var compilerOptions = host.getCompilerOptions();
        var sourceMapDataList = (compilerOptions.sourceMap || compilerOptions.inlineSourceMap || ts.getAreDeclarationMapsEnabled(compilerOptions)) ? [] : undefined;
        var emittedFilesList = compilerOptions.listEmittedFiles ? [] : undefined;
        var emitterDiagnostics = ts.createDiagnosticCollection();
        var newLine = ts.getNewLineCharacter(compilerOptions, function () { return host.getNewLine(); });
        var writer = ts.createTextWriter(newLine);
        var _b = ts.performance.createTimer("printTime", "beforePrint", "afterPrint"), enter = _b.enter, exit = _b.exit;
        var bundleBuildInfo;
        var emitSkipped = false;
        enter();
        forEachEmittedFile(host, emitSourceFileOrBundle, ts.getSourceFilesToEmit(host, targetSourceFile, forceDtsEmit), forceDtsEmit, onlyBuildInfo, !targetSourceFile);
        exit();
        return {
            emitSkipped: emitSkipped,
            diagnostics: emitterDiagnostics.getDiagnostics(),
            emittedFiles: emittedFilesList,
            sourceMaps: sourceMapDataList,
        };
        function emitSourceFileOrBundle(_a, sourceFileOrBundle) {
            var jsFilePath = _a.jsFilePath, sourceMapFilePath = _a.sourceMapFilePath, declarationFilePath = _a.declarationFilePath, declarationMapPath = _a.declarationMapPath, buildInfoPath = _a.buildInfoPath;
            var buildInfoDirectory;
            if (buildInfoPath && sourceFileOrBundle && ts.isBundle(sourceFileOrBundle)) {
                buildInfoDirectory = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(buildInfoPath, host.getCurrentDirectory()));
                bundleBuildInfo = {
                    commonSourceDirectory: relativeToBuildInfo(host.getCommonSourceDirectory()),
                    sourceFiles: sourceFileOrBundle.sourceFiles.map(function (file) { return relativeToBuildInfo(ts.getNormalizedAbsolutePath(file.fileName, host.getCurrentDirectory())); })
                };
            }
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("emit", "emitJsFileOrBundle", { jsFilePath: jsFilePath });
            emitJsFileOrBundle(sourceFileOrBundle, jsFilePath, sourceMapFilePath, relativeToBuildInfo);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("emit", "emitDeclarationFileOrBundle", { declarationFilePath: declarationFilePath });
            emitDeclarationFileOrBundle(sourceFileOrBundle, declarationFilePath, declarationMapPath, relativeToBuildInfo);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("emit", "emitBuildInfo", { buildInfoPath: buildInfoPath });
            emitBuildInfo(bundleBuildInfo, buildInfoPath);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
            if (!emitSkipped && emittedFilesList) {
                if (!emitOnlyDtsFiles) {
                    if (jsFilePath) {
                        emittedFilesList.push(jsFilePath);
                    }
                    if (sourceMapFilePath) {
                        emittedFilesList.push(sourceMapFilePath);
                    }
                    if (buildInfoPath) {
                        emittedFilesList.push(buildInfoPath);
                    }
                }
                if (declarationFilePath) {
                    emittedFilesList.push(declarationFilePath);
                }
                if (declarationMapPath) {
                    emittedFilesList.push(declarationMapPath);
                }
            }
            function relativeToBuildInfo(path) {
                return ts.ensurePathIsNonModuleName(ts.getRelativePathFromDirectory(buildInfoDirectory, path, host.getCanonicalFileName));
            }
        }
        function emitBuildInfo(bundle, buildInfoPath) {
            if (!buildInfoPath || targetSourceFile || emitSkipped)
                return;
            var program = host.getProgramBuildInfo();
            if (host.isEmitBlocked(buildInfoPath)) {
                emitSkipped = true;
                return;
            }
            var version = ts.version;
            var buildInfo = { bundle: bundle, program: program, version: version };
            ts.writeFile(host, emitterDiagnostics, buildInfoPath, getBuildInfoText(buildInfo), false, undefined, { buildInfo: buildInfo });
        }
        function emitJsFileOrBundle(sourceFileOrBundle, jsFilePath, sourceMapFilePath, relativeToBuildInfo) {
            if (!sourceFileOrBundle || emitOnlyDtsFiles || !jsFilePath) {
                return;
            }
            if (host.isEmitBlocked(jsFilePath) || compilerOptions.noEmit) {
                emitSkipped = true;
                return;
            }
            var transform = ts.transformNodes(resolver, host, ts.factory, compilerOptions, [sourceFileOrBundle], scriptTransformers, false);
            var printerOptions = {
                removeComments: compilerOptions.removeComments,
                newLine: compilerOptions.newLine,
                noEmitHelpers: compilerOptions.noEmitHelpers,
                module: compilerOptions.module,
                target: compilerOptions.target,
                sourceMap: compilerOptions.sourceMap,
                inlineSourceMap: compilerOptions.inlineSourceMap,
                inlineSources: compilerOptions.inlineSources,
                extendedDiagnostics: compilerOptions.extendedDiagnostics,
                writeBundleFileInfo: !!bundleBuildInfo,
                relativeToBuildInfo: relativeToBuildInfo
            };
            var printer = createPrinter(printerOptions, {
                hasGlobalName: resolver.hasGlobalName,
                onEmitNode: transform.emitNodeWithNotification,
                isEmitNotificationEnabled: transform.isEmitNotificationEnabled,
                substituteNode: transform.substituteNode,
            });
            ts.Debug.assert(transform.transformed.length === 1, "Should only see one output from the transform");
            printSourceFileOrBundle(jsFilePath, sourceMapFilePath, transform, printer, compilerOptions);
            transform.dispose();
            if (bundleBuildInfo)
                bundleBuildInfo.js = printer.bundleFileInfo;
        }
        function emitDeclarationFileOrBundle(sourceFileOrBundle, declarationFilePath, declarationMapPath, relativeToBuildInfo) {
            if (!sourceFileOrBundle)
                return;
            if (!declarationFilePath) {
                if (emitOnlyDtsFiles || compilerOptions.emitDeclarationOnly)
                    emitSkipped = true;
                return;
            }
            var sourceFiles = ts.isSourceFile(sourceFileOrBundle) ? [sourceFileOrBundle] : sourceFileOrBundle.sourceFiles;
            var filesForEmit = forceDtsEmit ? sourceFiles : ts.filter(sourceFiles, ts.isSourceFileNotJson);
            var inputListOrBundle = ts.outFile(compilerOptions) ? [ts.factory.createBundle(filesForEmit, !ts.isSourceFile(sourceFileOrBundle) ? sourceFileOrBundle.prepends : undefined)] : filesForEmit;
            if (emitOnlyDtsFiles && !ts.getEmitDeclarations(compilerOptions)) {
                filesForEmit.forEach(collectLinkedAliases);
            }
            var declarationTransform = ts.transformNodes(resolver, host, ts.factory, compilerOptions, inputListOrBundle, declarationTransformers, false);
            if (ts.length(declarationTransform.diagnostics)) {
                for (var _a = 0, _b = declarationTransform.diagnostics; _a < _b.length; _a++) {
                    var diagnostic = _b[_a];
                    emitterDiagnostics.add(diagnostic);
                }
            }
            var printerOptions = {
                removeComments: compilerOptions.removeComments,
                newLine: compilerOptions.newLine,
                noEmitHelpers: true,
                module: compilerOptions.module,
                target: compilerOptions.target,
                sourceMap: !forceDtsEmit && compilerOptions.declarationMap,
                inlineSourceMap: compilerOptions.inlineSourceMap,
                extendedDiagnostics: compilerOptions.extendedDiagnostics,
                onlyPrintJsDocStyle: true,
                writeBundleFileInfo: !!bundleBuildInfo,
                recordInternalSection: !!bundleBuildInfo,
                relativeToBuildInfo: relativeToBuildInfo
            };
            var declarationPrinter = createPrinter(printerOptions, {
                hasGlobalName: resolver.hasGlobalName,
                onEmitNode: declarationTransform.emitNodeWithNotification,
                isEmitNotificationEnabled: declarationTransform.isEmitNotificationEnabled,
                substituteNode: declarationTransform.substituteNode,
            });
            var declBlocked = (!!declarationTransform.diagnostics && !!declarationTransform.diagnostics.length) || !!host.isEmitBlocked(declarationFilePath) || !!compilerOptions.noEmit;
            emitSkipped = emitSkipped || declBlocked;
            if (!declBlocked || forceDtsEmit) {
                ts.Debug.assert(declarationTransform.transformed.length === 1, "Should only see one output from the decl transform");
                printSourceFileOrBundle(declarationFilePath, declarationMapPath, declarationTransform, declarationPrinter, {
                    sourceMap: printerOptions.sourceMap,
                    sourceRoot: compilerOptions.sourceRoot,
                    mapRoot: compilerOptions.mapRoot,
                    extendedDiagnostics: compilerOptions.extendedDiagnostics,
                });
            }
            declarationTransform.dispose();
            if (bundleBuildInfo)
                bundleBuildInfo.dts = declarationPrinter.bundleFileInfo;
        }
        function collectLinkedAliases(node) {
            if (ts.isExportAssignment(node)) {
                if (node.expression.kind === 79) {
                    resolver.collectLinkedAliases(node.expression, true);
                }
                return;
            }
            else if (ts.isExportSpecifier(node)) {
                resolver.collectLinkedAliases(node.propertyName || node.name, true);
                return;
            }
            ts.forEachChild(node, collectLinkedAliases);
        }
        function printSourceFileOrBundle(jsFilePath, sourceMapFilePath, transform, printer, mapOptions) {
            var sourceFileOrBundle = transform.transformed[0];
            var bundle = sourceFileOrBundle.kind === 309 ? sourceFileOrBundle : undefined;
            var sourceFile = sourceFileOrBundle.kind === 308 ? sourceFileOrBundle : undefined;
            var sourceFiles = bundle ? bundle.sourceFiles : [sourceFile];
            var sourceMapGenerator;
            if (shouldEmitSourceMaps(mapOptions, sourceFileOrBundle)) {
                sourceMapGenerator = ts.createSourceMapGenerator(host, ts.getBaseFileName(ts.normalizeSlashes(jsFilePath)), getSourceRoot(mapOptions), getSourceMapDirectory(mapOptions, jsFilePath, sourceFile), mapOptions);
            }
            if (bundle) {
                printer.writeBundle(bundle, writer, sourceMapGenerator);
            }
            else {
                printer.writeFile(sourceFile, writer, sourceMapGenerator);
            }
            var sourceMapUrlPos;
            if (sourceMapGenerator) {
                if (sourceMapDataList) {
                    sourceMapDataList.push({
                        inputSourceFileNames: sourceMapGenerator.getSources(),
                        sourceMap: sourceMapGenerator.toJSON()
                    });
                }
                var sourceMappingURL = getSourceMappingURL(mapOptions, sourceMapGenerator, jsFilePath, sourceMapFilePath, sourceFile);
                if (sourceMappingURL) {
                    if (!writer.isAtStartOfLine())
                        writer.rawWrite(newLine);
                    sourceMapUrlPos = writer.getTextPos();
                    writer.writeComment("//# ".concat("sourceMappingURL", "=").concat(sourceMappingURL));
                }
                if (sourceMapFilePath) {
                    var sourceMap = sourceMapGenerator.toString();
                    ts.writeFile(host, emitterDiagnostics, sourceMapFilePath, sourceMap, false, sourceFiles);
                    if (printer.bundleFileInfo)
                        printer.bundleFileInfo.mapHash = ts.computeSignature(sourceMap, ts.maybeBind(host, host.createHash));
                }
            }
            else {
                writer.writeLine();
            }
            var text = writer.getText();
            ts.writeFile(host, emitterDiagnostics, jsFilePath, text, !!compilerOptions.emitBOM, sourceFiles, { sourceMapUrlPos: sourceMapUrlPos, diagnostics: transform.diagnostics });
            if (printer.bundleFileInfo)
                printer.bundleFileInfo.hash = ts.computeSignature(text, ts.maybeBind(host, host.createHash));
            writer.clear();
        }
        function shouldEmitSourceMaps(mapOptions, sourceFileOrBundle) {
            return (mapOptions.sourceMap || mapOptions.inlineSourceMap)
                && (sourceFileOrBundle.kind !== 308 || !ts.fileExtensionIs(sourceFileOrBundle.fileName, ".json"));
        }
        function getSourceRoot(mapOptions) {
            var sourceRoot = ts.normalizeSlashes(mapOptions.sourceRoot || "");
            return sourceRoot ? ts.ensureTrailingDirectorySeparator(sourceRoot) : sourceRoot;
        }
        function getSourceMapDirectory(mapOptions, filePath, sourceFile) {
            if (mapOptions.sourceRoot)
                return host.getCommonSourceDirectory();
            if (mapOptions.mapRoot) {
                var sourceMapDir = ts.normalizeSlashes(mapOptions.mapRoot);
                if (sourceFile) {
                    sourceMapDir = ts.getDirectoryPath(ts.getSourceFilePathInNewDir(sourceFile.fileName, host, sourceMapDir));
                }
                if (ts.getRootLength(sourceMapDir) === 0) {
                    sourceMapDir = ts.combinePaths(host.getCommonSourceDirectory(), sourceMapDir);
                }
                return sourceMapDir;
            }
            return ts.getDirectoryPath(ts.normalizePath(filePath));
        }
        function getSourceMappingURL(mapOptions, sourceMapGenerator, filePath, sourceMapFilePath, sourceFile) {
            if (mapOptions.inlineSourceMap) {
                var sourceMapText = sourceMapGenerator.toString();
                var base64SourceMapText = ts.base64encode(ts.sys, sourceMapText);
                return "data:application/json;base64,".concat(base64SourceMapText);
            }
            var sourceMapFile = ts.getBaseFileName(ts.normalizeSlashes(ts.Debug.checkDefined(sourceMapFilePath)));
            if (mapOptions.mapRoot) {
                var sourceMapDir = ts.normalizeSlashes(mapOptions.mapRoot);
                if (sourceFile) {
                    sourceMapDir = ts.getDirectoryPath(ts.getSourceFilePathInNewDir(sourceFile.fileName, host, sourceMapDir));
                }
                if (ts.getRootLength(sourceMapDir) === 0) {
                    sourceMapDir = ts.combinePaths(host.getCommonSourceDirectory(), sourceMapDir);
                    return encodeURI(ts.getRelativePathToDirectoryOrUrl(ts.getDirectoryPath(ts.normalizePath(filePath)), ts.combinePaths(sourceMapDir, sourceMapFile), host.getCurrentDirectory(), host.getCanonicalFileName, true));
                }
                else {
                    return encodeURI(ts.combinePaths(sourceMapDir, sourceMapFile));
                }
            }
            return encodeURI(sourceMapFile);
        }
    }
    ts.emitFiles = emitFiles;
    function getBuildInfoText(buildInfo) {
        return JSON.stringify(buildInfo);
    }
    ts.getBuildInfoText = getBuildInfoText;
    function getBuildInfo(buildInfoFile, buildInfoText) {
        return ts.readJsonOrUndefined(buildInfoFile, buildInfoText);
    }
    ts.getBuildInfo = getBuildInfo;
    ts.notImplementedResolver = {
        hasGlobalName: ts.notImplemented,
        getReferencedExportContainer: ts.notImplemented,
        getReferencedImportDeclaration: ts.notImplemented,
        getReferencedDeclarationWithCollidingName: ts.notImplemented,
        isDeclarationWithCollidingName: ts.notImplemented,
        isValueAliasDeclaration: ts.notImplemented,
        isReferencedAliasDeclaration: ts.notImplemented,
        isTopLevelValueImportEqualsWithEntityName: ts.notImplemented,
        getNodeCheckFlags: ts.notImplemented,
        isDeclarationVisible: ts.notImplemented,
        isLateBound: function (_node) { return false; },
        collectLinkedAliases: ts.notImplemented,
        isImplementationOfOverload: ts.notImplemented,
        isRequiredInitializedParameter: ts.notImplemented,
        isOptionalUninitializedParameterProperty: ts.notImplemented,
        isExpandoFunctionDeclaration: ts.notImplemented,
        getPropertiesOfContainerFunction: ts.notImplemented,
        createTypeOfDeclaration: ts.notImplemented,
        createReturnTypeOfSignatureDeclaration: ts.notImplemented,
        createTypeOfExpression: ts.notImplemented,
        createLiteralConstValue: ts.notImplemented,
        isSymbolAccessible: ts.notImplemented,
        isEntityNameVisible: ts.notImplemented,
        getConstantValue: ts.notImplemented,
        getReferencedValueDeclaration: ts.notImplemented,
        getTypeReferenceSerializationKind: ts.notImplemented,
        isOptionalParameter: ts.notImplemented,
        moduleExportsSomeValue: ts.notImplemented,
        isArgumentsLocalBinding: ts.notImplemented,
        getExternalModuleFileFromDeclaration: ts.notImplemented,
        getTypeReferenceDirectivesForEntityName: ts.notImplemented,
        getTypeReferenceDirectivesForSymbol: ts.notImplemented,
        isLiteralConstDeclaration: ts.notImplemented,
        getJsxFactoryEntity: ts.notImplemented,
        getJsxFragmentFactoryEntity: ts.notImplemented,
        getAllAccessorDeclarations: ts.notImplemented,
        getSymbolOfExternalModuleSpecifier: ts.notImplemented,
        isBindingCapturedByNode: ts.notImplemented,
        getDeclarationStatementsForSourceFile: ts.notImplemented,
        isImportRequiredByAugmentation: ts.notImplemented,
    };
    function createSourceFilesFromBundleBuildInfo(bundle, buildInfoDirectory, host) {
        var _a;
        var jsBundle = ts.Debug.checkDefined(bundle.js);
        var prologueMap = ((_a = jsBundle.sources) === null || _a === void 0 ? void 0 : _a.prologues) && ts.arrayToMap(jsBundle.sources.prologues, function (prologueInfo) { return prologueInfo.file; });
        return bundle.sourceFiles.map(function (fileName, index) {
            var _a, _b;
            var prologueInfo = prologueMap === null || prologueMap === void 0 ? void 0 : prologueMap.get(index);
            var statements = prologueInfo === null || prologueInfo === void 0 ? void 0 : prologueInfo.directives.map(function (directive) {
                var literal = ts.setTextRange(ts.factory.createStringLiteral(directive.expression.text), directive.expression);
                var statement = ts.setTextRange(ts.factory.createExpressionStatement(literal), directive);
                ts.setParent(literal, statement);
                return statement;
            });
            var eofToken = ts.factory.createToken(1);
            var sourceFile = ts.factory.createSourceFile(statements !== null && statements !== void 0 ? statements : [], eofToken, 0);
            sourceFile.fileName = ts.getRelativePathFromDirectory(host.getCurrentDirectory(), ts.getNormalizedAbsolutePath(fileName, buildInfoDirectory), !host.useCaseSensitiveFileNames());
            sourceFile.text = (_a = prologueInfo === null || prologueInfo === void 0 ? void 0 : prologueInfo.text) !== null && _a !== void 0 ? _a : "";
            ts.setTextRangePosWidth(sourceFile, 0, (_b = prologueInfo === null || prologueInfo === void 0 ? void 0 : prologueInfo.text.length) !== null && _b !== void 0 ? _b : 0);
            ts.setEachParent(sourceFile.statements, sourceFile);
            ts.setTextRangePosWidth(eofToken, sourceFile.end, 0);
            ts.setParent(eofToken, sourceFile);
            return sourceFile;
        });
    }
    function emitUsingBuildInfo(config, host, getCommandLine, customTransformers) {
        var createHash = ts.maybeBind(host, host.createHash);
        var _a = getOutputPathsForBundle(config.options, false), buildInfoPath = _a.buildInfoPath, jsFilePath = _a.jsFilePath, sourceMapFilePath = _a.sourceMapFilePath, declarationFilePath = _a.declarationFilePath, declarationMapPath = _a.declarationMapPath;
        var buildInfo;
        if (host.getBuildInfo) {
            buildInfo = host.getBuildInfo(buildInfoPath, config.options.configFilePath);
        }
        else {
            var buildInfoText = host.readFile(buildInfoPath);
            if (!buildInfoText)
                return buildInfoPath;
            buildInfo = getBuildInfo(buildInfoPath, buildInfoText);
        }
        if (!buildInfo)
            return buildInfoPath;
        if (!buildInfo.bundle || !buildInfo.bundle.js || (declarationFilePath && !buildInfo.bundle.dts))
            return buildInfoPath;
        var jsFileText = host.readFile(ts.Debug.checkDefined(jsFilePath));
        if (!jsFileText)
            return jsFilePath;
        if (ts.computeSignature(jsFileText, createHash) !== buildInfo.bundle.js.hash)
            return jsFilePath;
        var sourceMapText = sourceMapFilePath && host.readFile(sourceMapFilePath);
        if ((sourceMapFilePath && !sourceMapText) || config.options.inlineSourceMap)
            return sourceMapFilePath || "inline sourcemap decoding";
        if (sourceMapFilePath && ts.computeSignature(sourceMapText, createHash) !== buildInfo.bundle.js.mapHash)
            return sourceMapFilePath;
        var declarationText = declarationFilePath && host.readFile(declarationFilePath);
        if (declarationFilePath && !declarationText)
            return declarationFilePath;
        if (declarationFilePath && ts.computeSignature(declarationText, createHash) !== buildInfo.bundle.dts.hash)
            return declarationFilePath;
        var declarationMapText = declarationMapPath && host.readFile(declarationMapPath);
        if ((declarationMapPath && !declarationMapText) || config.options.inlineSourceMap)
            return declarationMapPath || "inline sourcemap decoding";
        if (declarationMapPath && ts.computeSignature(declarationMapText, createHash) !== buildInfo.bundle.dts.mapHash)
            return declarationMapPath;
        var buildInfoDirectory = ts.getDirectoryPath(ts.getNormalizedAbsolutePath(buildInfoPath, host.getCurrentDirectory()));
        var ownPrependInput = ts.createInputFiles(jsFileText, declarationText, sourceMapFilePath, sourceMapText, declarationMapPath, declarationMapText, jsFilePath, declarationFilePath, buildInfoPath, buildInfo, true);
        var outputFiles = [];
        var prependNodes = ts.createPrependNodes(config.projectReferences, getCommandLine, function (f) { return host.readFile(f); });
        var sourceFilesForJsEmit = createSourceFilesFromBundleBuildInfo(buildInfo.bundle, buildInfoDirectory, host);
        var changedDtsText;
        var changedDtsData;
        var emitHost = {
            getPrependNodes: ts.memoize(function () { return __spreadArray(__spreadArray([], prependNodes, true), [ownPrependInput], false); }),
            getCanonicalFileName: host.getCanonicalFileName,
            getCommonSourceDirectory: function () { return ts.getNormalizedAbsolutePath(buildInfo.bundle.commonSourceDirectory, buildInfoDirectory); },
            getCompilerOptions: function () { return config.options; },
            getCurrentDirectory: function () { return host.getCurrentDirectory(); },
            getNewLine: function () { return host.getNewLine(); },
            getSourceFile: ts.returnUndefined,
            getSourceFileByPath: ts.returnUndefined,
            getSourceFiles: function () { return sourceFilesForJsEmit; },
            getLibFileFromReference: ts.notImplemented,
            isSourceFileFromExternalLibrary: ts.returnFalse,
            getResolvedProjectReferenceToRedirect: ts.returnUndefined,
            getProjectReferenceRedirect: ts.returnUndefined,
            isSourceOfProjectReferenceRedirect: ts.returnFalse,
            writeFile: function (name, text, writeByteOrderMark, _onError, _sourceFiles, data) {
                switch (name) {
                    case jsFilePath:
                        if (jsFileText === text)
                            return;
                        break;
                    case sourceMapFilePath:
                        if (sourceMapText === text)
                            return;
                        break;
                    case buildInfoPath:
                        var newBuildInfo = data.buildInfo;
                        newBuildInfo.program = buildInfo.program;
                        if (newBuildInfo.program && changedDtsText !== undefined && config.options.composite) {
                            newBuildInfo.program.outSignature = ts.computeSignature(changedDtsText, createHash, changedDtsData);
                        }
                        var _a = buildInfo.bundle, js = _a.js, dts = _a.dts, sourceFiles = _a.sourceFiles;
                        newBuildInfo.bundle.js.sources = js.sources;
                        if (dts) {
                            newBuildInfo.bundle.dts.sources = dts.sources;
                        }
                        newBuildInfo.bundle.sourceFiles = sourceFiles;
                        outputFiles.push({ name: name, text: getBuildInfoText(newBuildInfo), writeByteOrderMark: writeByteOrderMark, buildInfo: newBuildInfo });
                        return;
                    case declarationFilePath:
                        if (declarationText === text)
                            return;
                        changedDtsText = text;
                        changedDtsData = data;
                        break;
                    case declarationMapPath:
                        if (declarationMapText === text)
                            return;
                        break;
                    default:
                        ts.Debug.fail("Unexpected path: ".concat(name));
                }
                outputFiles.push({ name: name, text: text, writeByteOrderMark: writeByteOrderMark });
            },
            isEmitBlocked: ts.returnFalse,
            readFile: function (f) { return host.readFile(f); },
            fileExists: function (f) { return host.fileExists(f); },
            useCaseSensitiveFileNames: function () { return host.useCaseSensitiveFileNames(); },
            getProgramBuildInfo: ts.returnUndefined,
            getSourceFileFromReference: ts.returnUndefined,
            redirectTargetsMap: ts.createMultiMap(),
            getFileIncludeReasons: ts.notImplemented,
            createHash: createHash,
        };
        emitFiles(ts.notImplementedResolver, emitHost, undefined, ts.getTransformers(config.options, customTransformers));
        return outputFiles;
    }
    ts.emitUsingBuildInfo = emitUsingBuildInfo;
    function createPrinter(printerOptions, handlers) {
        if (printerOptions === void 0) { printerOptions = {}; }
        if (handlers === void 0) { handlers = {}; }
        var hasGlobalName = handlers.hasGlobalName, _a = handlers.onEmitNode, onEmitNode = _a === void 0 ? ts.noEmitNotification : _a, isEmitNotificationEnabled = handlers.isEmitNotificationEnabled, _b = handlers.substituteNode, substituteNode = _b === void 0 ? ts.noEmitSubstitution : _b, onBeforeEmitNode = handlers.onBeforeEmitNode, onAfterEmitNode = handlers.onAfterEmitNode, onBeforeEmitNodeArray = handlers.onBeforeEmitNodeArray, onAfterEmitNodeArray = handlers.onAfterEmitNodeArray, onBeforeEmitToken = handlers.onBeforeEmitToken, onAfterEmitToken = handlers.onAfterEmitToken;
        var extendedDiagnostics = !!printerOptions.extendedDiagnostics;
        var newLine = ts.getNewLineCharacter(printerOptions);
        var moduleKind = ts.getEmitModuleKind(printerOptions);
        var bundledHelpers = new ts.Map();
        var currentSourceFile;
        var nodeIdToGeneratedName;
        var autoGeneratedIdToGeneratedName;
        var generatedNames;
        var formattedNameTempFlagsStack;
        var formattedNameTempFlags;
        var privateNameTempFlagsStack;
        var privateNameTempFlags;
        var tempFlagsStack;
        var tempFlags;
        var reservedNamesStack;
        var reservedNames;
        var preserveSourceNewlines = printerOptions.preserveSourceNewlines;
        var nextListElementPos;
        var writer;
        var ownWriter;
        var write = writeBase;
        var isOwnFileEmit;
        var bundleFileInfo = printerOptions.writeBundleFileInfo ? { sections: [] } : undefined;
        var relativeToBuildInfo = bundleFileInfo ? ts.Debug.checkDefined(printerOptions.relativeToBuildInfo) : undefined;
        var recordInternalSection = printerOptions.recordInternalSection;
        var sourceFileTextPos = 0;
        var sourceFileTextKind = "text";
        var sourceMapsDisabled = true;
        var sourceMapGenerator;
        var sourceMapSource;
        var sourceMapSourceIndex = -1;
        var mostRecentlyAddedSourceMapSource;
        var mostRecentlyAddedSourceMapSourceIndex = -1;
        var containerPos = -1;
        var containerEnd = -1;
        var declarationListContainerEnd = -1;
        var currentLineMap;
        var detachedCommentsInfo;
        var hasWrittenComment = false;
        var commentsDisabled = !!printerOptions.removeComments;
        var lastSubstitution;
        var currentParenthesizerRule;
        var _c = ts.performance.createTimerIf(extendedDiagnostics, "commentTime", "beforeComment", "afterComment"), enterComment = _c.enter, exitComment = _c.exit;
        var parenthesizer = ts.factory.parenthesizer;
        var typeArgumentParenthesizerRuleSelector = {
            select: function (index) { return index === 0 ? parenthesizer.parenthesizeLeadingTypeArgument : undefined; }
        };
        var emitBinaryExpression = createEmitBinaryExpression();
        reset();
        return {
            printNode: printNode,
            printList: printList,
            printFile: printFile,
            printBundle: printBundle,
            writeNode: writeNode,
            writeList: writeList,
            writeFile: writeFile,
            writeBundle: writeBundle,
            bundleFileInfo: bundleFileInfo
        };
        function printNode(hint, node, sourceFile) {
            switch (hint) {
                case 0:
                    ts.Debug.assert(ts.isSourceFile(node), "Expected a SourceFile node.");
                    break;
                case 2:
                    ts.Debug.assert(ts.isIdentifier(node), "Expected an Identifier node.");
                    break;
                case 1:
                    ts.Debug.assert(ts.isExpression(node), "Expected an Expression node.");
                    break;
            }
            switch (node.kind) {
                case 308: return printFile(node);
                case 309: return printBundle(node);
                case 310: return printUnparsedSource(node);
            }
            writeNode(hint, node, sourceFile, beginPrint());
            return endPrint();
        }
        function printList(format, nodes, sourceFile) {
            writeList(format, nodes, sourceFile, beginPrint());
            return endPrint();
        }
        function printBundle(bundle) {
            writeBundle(bundle, beginPrint(), undefined);
            return endPrint();
        }
        function printFile(sourceFile) {
            writeFile(sourceFile, beginPrint(), undefined);
            return endPrint();
        }
        function printUnparsedSource(unparsed) {
            writeUnparsedSource(unparsed, beginPrint());
            return endPrint();
        }
        function writeNode(hint, node, sourceFile, output) {
            var previousWriter = writer;
            setWriter(output, undefined);
            print(hint, node, sourceFile);
            reset();
            writer = previousWriter;
        }
        function writeList(format, nodes, sourceFile, output) {
            var previousWriter = writer;
            setWriter(output, undefined);
            if (sourceFile) {
                setSourceFile(sourceFile);
            }
            emitList(undefined, nodes, format);
            reset();
            writer = previousWriter;
        }
        function getTextPosWithWriteLine() {
            return writer.getTextPosWithWriteLine ? writer.getTextPosWithWriteLine() : writer.getTextPos();
        }
        function updateOrPushBundleFileTextLike(pos, end, kind) {
            var last = ts.lastOrUndefined(bundleFileInfo.sections);
            if (last && last.kind === kind) {
                last.end = end;
            }
            else {
                bundleFileInfo.sections.push({ pos: pos, end: end, kind: kind });
            }
        }
        function recordBundleFileInternalSectionStart(node) {
            if (recordInternalSection &&
                bundleFileInfo &&
                currentSourceFile &&
                (ts.isDeclaration(node) || ts.isVariableStatement(node)) &&
                ts.isInternalDeclaration(node, currentSourceFile) &&
                sourceFileTextKind !== "internal") {
                var prevSourceFileTextKind = sourceFileTextKind;
                recordBundleFileTextLikeSection(writer.getTextPos());
                sourceFileTextPos = getTextPosWithWriteLine();
                sourceFileTextKind = "internal";
                return prevSourceFileTextKind;
            }
            return undefined;
        }
        function recordBundleFileInternalSectionEnd(prevSourceFileTextKind) {
            if (prevSourceFileTextKind) {
                recordBundleFileTextLikeSection(writer.getTextPos());
                sourceFileTextPos = getTextPosWithWriteLine();
                sourceFileTextKind = prevSourceFileTextKind;
            }
        }
        function recordBundleFileTextLikeSection(end) {
            if (sourceFileTextPos < end) {
                updateOrPushBundleFileTextLike(sourceFileTextPos, end, sourceFileTextKind);
                return true;
            }
            return false;
        }
        function writeBundle(bundle, output, sourceMapGenerator) {
            var _a;
            isOwnFileEmit = false;
            var previousWriter = writer;
            setWriter(output, sourceMapGenerator);
            emitShebangIfNeeded(bundle);
            emitPrologueDirectivesIfNeeded(bundle);
            emitHelpers(bundle);
            emitSyntheticTripleSlashReferencesIfNeeded(bundle);
            for (var _b = 0, _c = bundle.prepends; _b < _c.length; _b++) {
                var prepend = _c[_b];
                writeLine();
                var pos = writer.getTextPos();
                var savedSections = bundleFileInfo && bundleFileInfo.sections;
                if (savedSections)
                    bundleFileInfo.sections = [];
                print(4, prepend, undefined);
                if (bundleFileInfo) {
                    var newSections = bundleFileInfo.sections;
                    bundleFileInfo.sections = savedSections;
                    if (prepend.oldFileOfCurrentEmit)
                        (_a = bundleFileInfo.sections).push.apply(_a, newSections);
                    else {
                        newSections.forEach(function (section) { return ts.Debug.assert(ts.isBundleFileTextLike(section)); });
                        bundleFileInfo.sections.push({
                            pos: pos,
                            end: writer.getTextPos(),
                            kind: "prepend",
                            data: relativeToBuildInfo(prepend.fileName),
                            texts: newSections
                        });
                    }
                }
            }
            sourceFileTextPos = getTextPosWithWriteLine();
            for (var _d = 0, _e = bundle.sourceFiles; _d < _e.length; _d++) {
                var sourceFile = _e[_d];
                print(0, sourceFile, sourceFile);
            }
            if (bundleFileInfo && bundle.sourceFiles.length) {
                var end = writer.getTextPos();
                if (recordBundleFileTextLikeSection(end)) {
                    var prologues = getPrologueDirectivesFromBundledSourceFiles(bundle);
                    if (prologues) {
                        if (!bundleFileInfo.sources)
                            bundleFileInfo.sources = {};
                        bundleFileInfo.sources.prologues = prologues;
                    }
                    var helpers = getHelpersFromBundledSourceFiles(bundle);
                    if (helpers) {
                        if (!bundleFileInfo.sources)
                            bundleFileInfo.sources = {};
                        bundleFileInfo.sources.helpers = helpers;
                    }
                }
            }
            reset();
            writer = previousWriter;
        }
        function writeUnparsedSource(unparsed, output) {
            var previousWriter = writer;
            setWriter(output, undefined);
            print(4, unparsed, undefined);
            reset();
            writer = previousWriter;
        }
        function writeFile(sourceFile, output, sourceMapGenerator) {
            isOwnFileEmit = true;
            var previousWriter = writer;
            setWriter(output, sourceMapGenerator);
            emitShebangIfNeeded(sourceFile);
            emitPrologueDirectivesIfNeeded(sourceFile);
            print(0, sourceFile, sourceFile);
            reset();
            writer = previousWriter;
        }
        function beginPrint() {
            return ownWriter || (ownWriter = ts.createTextWriter(newLine));
        }
        function endPrint() {
            var text = ownWriter.getText();
            ownWriter.clear();
            return text;
        }
        function print(hint, node, sourceFile) {
            if (sourceFile) {
                setSourceFile(sourceFile);
            }
            pipelineEmit(hint, node, undefined);
        }
        function setSourceFile(sourceFile) {
            currentSourceFile = sourceFile;
            currentLineMap = undefined;
            detachedCommentsInfo = undefined;
            if (sourceFile) {
                setSourceMapSource(sourceFile);
            }
        }
        function setWriter(_writer, _sourceMapGenerator) {
            if (_writer && printerOptions.omitTrailingSemicolon) {
                _writer = ts.getTrailingSemicolonDeferringWriter(_writer);
            }
            writer = _writer;
            sourceMapGenerator = _sourceMapGenerator;
            sourceMapsDisabled = !writer || !sourceMapGenerator;
        }
        function reset() {
            nodeIdToGeneratedName = [];
            autoGeneratedIdToGeneratedName = [];
            generatedNames = new ts.Set();
            formattedNameTempFlagsStack = [];
            formattedNameTempFlags = new ts.Map();
            privateNameTempFlagsStack = [];
            privateNameTempFlags = 0;
            tempFlagsStack = [];
            tempFlags = 0;
            reservedNamesStack = [];
            currentSourceFile = undefined;
            currentLineMap = undefined;
            detachedCommentsInfo = undefined;
            setWriter(undefined, undefined);
        }
        function getCurrentLineMap() {
            return currentLineMap || (currentLineMap = ts.getLineStarts(ts.Debug.checkDefined(currentSourceFile)));
        }
        function emit(node, parenthesizerRule) {
            if (node === undefined)
                return;
            var prevSourceFileTextKind = recordBundleFileInternalSectionStart(node);
            pipelineEmit(4, node, parenthesizerRule);
            recordBundleFileInternalSectionEnd(prevSourceFileTextKind);
        }
        function emitIdentifierName(node) {
            if (node === undefined)
                return;
            pipelineEmit(2, node, undefined);
        }
        function emitExpression(node, parenthesizerRule) {
            if (node === undefined)
                return;
            pipelineEmit(1, node, parenthesizerRule);
        }
        function emitJsxAttributeValue(node) {
            pipelineEmit(ts.isStringLiteral(node) ? 6 : 4, node);
        }
        function beforeEmitNode(node) {
            if (preserveSourceNewlines && (ts.getEmitFlags(node) & 134217728)) {
                preserveSourceNewlines = false;
            }
        }
        function afterEmitNode(savedPreserveSourceNewlines) {
            preserveSourceNewlines = savedPreserveSourceNewlines;
        }
        function pipelineEmit(emitHint, node, parenthesizerRule) {
            currentParenthesizerRule = parenthesizerRule;
            var pipelinePhase = getPipelinePhase(0, emitHint, node);
            pipelinePhase(emitHint, node);
            currentParenthesizerRule = undefined;
        }
        function shouldEmitComments(node) {
            return !commentsDisabled && !ts.isSourceFile(node);
        }
        function shouldEmitSourceMaps(node) {
            return !sourceMapsDisabled &&
                !ts.isSourceFile(node) &&
                !ts.isInJsonFile(node) &&
                !ts.isUnparsedSource(node) &&
                !ts.isUnparsedPrepend(node);
        }
        function getPipelinePhase(phase, emitHint, node) {
            switch (phase) {
                case 0:
                    if (onEmitNode !== ts.noEmitNotification && (!isEmitNotificationEnabled || isEmitNotificationEnabled(node))) {
                        return pipelineEmitWithNotification;
                    }
                case 1:
                    if (substituteNode !== ts.noEmitSubstitution && (lastSubstitution = substituteNode(emitHint, node) || node) !== node) {
                        if (currentParenthesizerRule) {
                            lastSubstitution = currentParenthesizerRule(lastSubstitution);
                        }
                        return pipelineEmitWithSubstitution;
                    }
                case 2:
                    if (shouldEmitComments(node)) {
                        return pipelineEmitWithComments;
                    }
                case 3:
                    if (shouldEmitSourceMaps(node)) {
                        return pipelineEmitWithSourceMaps;
                    }
                case 4:
                    return pipelineEmitWithHint;
                default:
                    return ts.Debug.assertNever(phase);
            }
        }
        function getNextPipelinePhase(currentPhase, emitHint, node) {
            return getPipelinePhase(currentPhase + 1, emitHint, node);
        }
        function pipelineEmitWithNotification(hint, node) {
            var pipelinePhase = getNextPipelinePhase(0, hint, node);
            onEmitNode(hint, node, pipelinePhase);
        }
        function pipelineEmitWithHint(hint, node) {
            onBeforeEmitNode === null || onBeforeEmitNode === void 0 ? void 0 : onBeforeEmitNode(node);
            if (preserveSourceNewlines) {
                var savedPreserveSourceNewlines = preserveSourceNewlines;
                beforeEmitNode(node);
                pipelineEmitWithHintWorker(hint, node);
                afterEmitNode(savedPreserveSourceNewlines);
            }
            else {
                pipelineEmitWithHintWorker(hint, node);
            }
            onAfterEmitNode === null || onAfterEmitNode === void 0 ? void 0 : onAfterEmitNode(node);
            currentParenthesizerRule = undefined;
        }
        function pipelineEmitWithHintWorker(hint, node, allowSnippets) {
            if (allowSnippets === void 0) { allowSnippets = true; }
            if (allowSnippets) {
                var snippet = ts.getSnippetElement(node);
                if (snippet) {
                    return emitSnippetNode(hint, node, snippet);
                }
            }
            if (hint === 0)
                return emitSourceFile(ts.cast(node, ts.isSourceFile));
            if (hint === 2)
                return emitIdentifier(ts.cast(node, ts.isIdentifier));
            if (hint === 6)
                return emitLiteral(ts.cast(node, ts.isStringLiteral), true);
            if (hint === 3)
                return emitMappedTypeParameter(ts.cast(node, ts.isTypeParameterDeclaration));
            if (hint === 5) {
                ts.Debug.assertNode(node, ts.isEmptyStatement);
                return emitEmptyStatement(true);
            }
            if (hint === 4) {
                switch (node.kind) {
                    case 15:
                    case 16:
                    case 17:
                        return emitLiteral(node, false);
                    case 79:
                        return emitIdentifier(node);
                    case 80:
                        return emitPrivateIdentifier(node);
                    case 163:
                        return emitQualifiedName(node);
                    case 164:
                        return emitComputedPropertyName(node);
                    case 165:
                        return emitTypeParameter(node);
                    case 166:
                        return emitParameter(node);
                    case 167:
                        return emitDecorator(node);
                    case 168:
                        return emitPropertySignature(node);
                    case 169:
                        return emitPropertyDeclaration(node);
                    case 170:
                        return emitMethodSignature(node);
                    case 171:
                        return emitMethodDeclaration(node);
                    case 172:
                        return emitClassStaticBlockDeclaration(node);
                    case 173:
                        return emitConstructor(node);
                    case 174:
                    case 175:
                        return emitAccessorDeclaration(node);
                    case 176:
                        return emitCallSignature(node);
                    case 177:
                        return emitConstructSignature(node);
                    case 178:
                        return emitIndexSignature(node);
                    case 179:
                        return emitTypePredicate(node);
                    case 180:
                        return emitTypeReference(node);
                    case 181:
                        return emitFunctionType(node);
                    case 182:
                        return emitConstructorType(node);
                    case 183:
                        return emitTypeQuery(node);
                    case 184:
                        return emitTypeLiteral(node);
                    case 185:
                        return emitArrayType(node);
                    case 186:
                        return emitTupleType(node);
                    case 187:
                        return emitOptionalType(node);
                    case 189:
                        return emitUnionType(node);
                    case 190:
                        return emitIntersectionType(node);
                    case 191:
                        return emitConditionalType(node);
                    case 192:
                        return emitInferType(node);
                    case 193:
                        return emitParenthesizedType(node);
                    case 230:
                        return emitExpressionWithTypeArguments(node);
                    case 194:
                        return emitThisType();
                    case 195:
                        return emitTypeOperator(node);
                    case 196:
                        return emitIndexedAccessType(node);
                    case 197:
                        return emitMappedType(node);
                    case 198:
                        return emitLiteralType(node);
                    case 199:
                        return emitNamedTupleMember(node);
                    case 200:
                        return emitTemplateType(node);
                    case 201:
                        return emitTemplateTypeSpan(node);
                    case 202:
                        return emitImportTypeNode(node);
                    case 203:
                        return emitObjectBindingPattern(node);
                    case 204:
                        return emitArrayBindingPattern(node);
                    case 205:
                        return emitBindingElement(node);
                    case 236:
                        return emitTemplateSpan(node);
                    case 237:
                        return emitSemicolonClassElement();
                    case 238:
                        return emitBlock(node);
                    case 240:
                        return emitVariableStatement(node);
                    case 239:
                        return emitEmptyStatement(false);
                    case 241:
                        return emitExpressionStatement(node);
                    case 242:
                        return emitIfStatement(node);
                    case 243:
                        return emitDoStatement(node);
                    case 244:
                        return emitWhileStatement(node);
                    case 245:
                        return emitForStatement(node);
                    case 246:
                        return emitForInStatement(node);
                    case 247:
                        return emitForOfStatement(node);
                    case 248:
                        return emitContinueStatement(node);
                    case 249:
                        return emitBreakStatement(node);
                    case 250:
                        return emitReturnStatement(node);
                    case 251:
                        return emitWithStatement(node);
                    case 252:
                        return emitSwitchStatement(node);
                    case 253:
                        return emitLabeledStatement(node);
                    case 254:
                        return emitThrowStatement(node);
                    case 255:
                        return emitTryStatement(node);
                    case 256:
                        return emitDebuggerStatement(node);
                    case 257:
                        return emitVariableDeclaration(node);
                    case 258:
                        return emitVariableDeclarationList(node);
                    case 259:
                        return emitFunctionDeclaration(node);
                    case 260:
                        return emitClassDeclaration(node);
                    case 261:
                        return emitInterfaceDeclaration(node);
                    case 262:
                        return emitTypeAliasDeclaration(node);
                    case 263:
                        return emitEnumDeclaration(node);
                    case 264:
                        return emitModuleDeclaration(node);
                    case 265:
                        return emitModuleBlock(node);
                    case 266:
                        return emitCaseBlock(node);
                    case 267:
                        return emitNamespaceExportDeclaration(node);
                    case 268:
                        return emitImportEqualsDeclaration(node);
                    case 269:
                        return emitImportDeclaration(node);
                    case 270:
                        return emitImportClause(node);
                    case 271:
                        return emitNamespaceImport(node);
                    case 277:
                        return emitNamespaceExport(node);
                    case 272:
                        return emitNamedImports(node);
                    case 273:
                        return emitImportSpecifier(node);
                    case 274:
                        return emitExportAssignment(node);
                    case 275:
                        return emitExportDeclaration(node);
                    case 276:
                        return emitNamedExports(node);
                    case 278:
                        return emitExportSpecifier(node);
                    case 296:
                        return emitAssertClause(node);
                    case 297:
                        return emitAssertEntry(node);
                    case 279:
                        return;
                    case 280:
                        return emitExternalModuleReference(node);
                    case 11:
                        return emitJsxText(node);
                    case 283:
                    case 286:
                        return emitJsxOpeningElementOrFragment(node);
                    case 284:
                    case 287:
                        return emitJsxClosingElementOrFragment(node);
                    case 288:
                        return emitJsxAttribute(node);
                    case 289:
                        return emitJsxAttributes(node);
                    case 290:
                        return emitJsxSpreadAttribute(node);
                    case 291:
                        return emitJsxExpression(node);
                    case 292:
                        return emitCaseClause(node);
                    case 293:
                        return emitDefaultClause(node);
                    case 294:
                        return emitHeritageClause(node);
                    case 295:
                        return emitCatchClause(node);
                    case 299:
                        return emitPropertyAssignment(node);
                    case 300:
                        return emitShorthandPropertyAssignment(node);
                    case 301:
                        return emitSpreadAssignment(node);
                    case 302:
                        return emitEnumMember(node);
                    case 303:
                        return writeUnparsedNode(node);
                    case 310:
                    case 304:
                        return emitUnparsedSourceOrPrepend(node);
                    case 305:
                    case 306:
                        return emitUnparsedTextLike(node);
                    case 307:
                        return emitUnparsedSyntheticReference(node);
                    case 308:
                        return emitSourceFile(node);
                    case 309:
                        return ts.Debug.fail("Bundles should be printed using printBundle");
                    case 311:
                        return ts.Debug.fail("InputFiles should not be printed");
                    case 312:
                        return emitJSDocTypeExpression(node);
                    case 313:
                        return emitJSDocNameReference(node);
                    case 315:
                        return writePunctuation("*");
                    case 316:
                        return writePunctuation("?");
                    case 317:
                        return emitJSDocNullableType(node);
                    case 318:
                        return emitJSDocNonNullableType(node);
                    case 319:
                        return emitJSDocOptionalType(node);
                    case 320:
                        return emitJSDocFunctionType(node);
                    case 188:
                    case 321:
                        return emitRestOrJSDocVariadicType(node);
                    case 322:
                        return;
                    case 323:
                        return emitJSDoc(node);
                    case 325:
                        return emitJSDocTypeLiteral(node);
                    case 326:
                        return emitJSDocSignature(node);
                    case 330:
                    case 335:
                    case 340:
                        return emitJSDocSimpleTag(node);
                    case 331:
                    case 332:
                        return emitJSDocHeritageTag(node);
                    case 333:
                    case 334:
                        return;
                    case 336:
                    case 337:
                    case 338:
                    case 339:
                        return;
                    case 341:
                        return emitJSDocCallbackTag(node);
                    case 343:
                    case 350:
                        return emitJSDocPropertyLikeTag(node);
                    case 342:
                    case 344:
                    case 345:
                    case 346:
                        return emitJSDocSimpleTypedTag(node);
                    case 347:
                        return emitJSDocTemplateTag(node);
                    case 348:
                        return emitJSDocTypedefTag(node);
                    case 349:
                        return emitJSDocSeeTag(node);
                    case 352:
                    case 356:
                    case 355:
                        return;
                }
                if (ts.isExpression(node)) {
                    hint = 1;
                    if (substituteNode !== ts.noEmitSubstitution) {
                        var substitute = substituteNode(hint, node) || node;
                        if (substitute !== node) {
                            node = substitute;
                            if (currentParenthesizerRule) {
                                node = currentParenthesizerRule(node);
                            }
                        }
                    }
                }
            }
            if (hint === 1) {
                switch (node.kind) {
                    case 8:
                    case 9:
                        return emitNumericOrBigIntLiteral(node);
                    case 10:
                    case 13:
                    case 14:
                        return emitLiteral(node, false);
                    case 79:
                        return emitIdentifier(node);
                    case 80:
                        return emitPrivateIdentifier(node);
                    case 206:
                        return emitArrayLiteralExpression(node);
                    case 207:
                        return emitObjectLiteralExpression(node);
                    case 208:
                        return emitPropertyAccessExpression(node);
                    case 209:
                        return emitElementAccessExpression(node);
                    case 210:
                        return emitCallExpression(node);
                    case 211:
                        return emitNewExpression(node);
                    case 212:
                        return emitTaggedTemplateExpression(node);
                    case 213:
                        return emitTypeAssertionExpression(node);
                    case 214:
                        return emitParenthesizedExpression(node);
                    case 215:
                        return emitFunctionExpression(node);
                    case 216:
                        return emitArrowFunction(node);
                    case 217:
                        return emitDeleteExpression(node);
                    case 218:
                        return emitTypeOfExpression(node);
                    case 219:
                        return emitVoidExpression(node);
                    case 220:
                        return emitAwaitExpression(node);
                    case 221:
                        return emitPrefixUnaryExpression(node);
                    case 222:
                        return emitPostfixUnaryExpression(node);
                    case 223:
                        return emitBinaryExpression(node);
                    case 224:
                        return emitConditionalExpression(node);
                    case 225:
                        return emitTemplateExpression(node);
                    case 226:
                        return emitYieldExpression(node);
                    case 227:
                        return emitSpreadElement(node);
                    case 228:
                        return emitClassExpression(node);
                    case 229:
                        return;
                    case 231:
                        return emitAsExpression(node);
                    case 232:
                        return emitNonNullExpression(node);
                    case 230:
                        return emitExpressionWithTypeArguments(node);
                    case 235:
                        return emitSatisfiesExpression(node);
                    case 233:
                        return emitMetaProperty(node);
                    case 234:
                        return ts.Debug.fail("SyntheticExpression should never be printed.");
                    case 281:
                        return emitJsxElement(node);
                    case 282:
                        return emitJsxSelfClosingElement(node);
                    case 285:
                        return emitJsxFragment(node);
                    case 351:
                        return ts.Debug.fail("SyntaxList should not be printed");
                    case 352:
                        return;
                    case 353:
                        return emitPartiallyEmittedExpression(node);
                    case 354:
                        return emitCommaList(node);
                    case 355:
                    case 356:
                        return;
                    case 357:
                        return ts.Debug.fail("SyntheticReferenceExpression should not be printed");
                }
            }
            if (ts.isKeyword(node.kind))
                return writeTokenNode(node, writeKeyword);
            if (ts.isTokenKind(node.kind))
                return writeTokenNode(node, writePunctuation);
            ts.Debug.fail("Unhandled SyntaxKind: ".concat(ts.Debug.formatSyntaxKind(node.kind), "."));
        }
        function emitMappedTypeParameter(node) {
            emit(node.name);
            writeSpace();
            writeKeyword("in");
            writeSpace();
            emit(node.constraint);
        }
        function pipelineEmitWithSubstitution(hint, node) {
            var pipelinePhase = getNextPipelinePhase(1, hint, node);
            ts.Debug.assertIsDefined(lastSubstitution);
            node = lastSubstitution;
            lastSubstitution = undefined;
            pipelinePhase(hint, node);
        }
        function getHelpersFromBundledSourceFiles(bundle) {
            var result;
            if (moduleKind === ts.ModuleKind.None || printerOptions.noEmitHelpers) {
                return undefined;
            }
            var bundledHelpers = new ts.Map();
            for (var _a = 0, _b = bundle.sourceFiles; _a < _b.length; _a++) {
                var sourceFile = _b[_a];
                var shouldSkip = ts.getExternalHelpersModuleName(sourceFile) !== undefined;
                var helpers = getSortedEmitHelpers(sourceFile);
                if (!helpers)
                    continue;
                for (var _c = 0, helpers_5 = helpers; _c < helpers_5.length; _c++) {
                    var helper = helpers_5[_c];
                    if (!helper.scoped && !shouldSkip && !bundledHelpers.get(helper.name)) {
                        bundledHelpers.set(helper.name, true);
                        (result || (result = [])).push(helper.name);
                    }
                }
            }
            return result;
        }
        function emitHelpers(node) {
            var helpersEmitted = false;
            var bundle = node.kind === 309 ? node : undefined;
            if (bundle && moduleKind === ts.ModuleKind.None) {
                return;
            }
            var numPrepends = bundle ? bundle.prepends.length : 0;
            var numNodes = bundle ? bundle.sourceFiles.length + numPrepends : 1;
            for (var i = 0; i < numNodes; i++) {
                var currentNode = bundle ? i < numPrepends ? bundle.prepends[i] : bundle.sourceFiles[i - numPrepends] : node;
                var sourceFile = ts.isSourceFile(currentNode) ? currentNode : ts.isUnparsedSource(currentNode) ? undefined : currentSourceFile;
                var shouldSkip = printerOptions.noEmitHelpers || (!!sourceFile && ts.hasRecordedExternalHelpers(sourceFile));
                var shouldBundle = (ts.isSourceFile(currentNode) || ts.isUnparsedSource(currentNode)) && !isOwnFileEmit;
                var helpers = ts.isUnparsedSource(currentNode) ? currentNode.helpers : getSortedEmitHelpers(currentNode);
                if (helpers) {
                    for (var _a = 0, helpers_6 = helpers; _a < helpers_6.length; _a++) {
                        var helper = helpers_6[_a];
                        if (!helper.scoped) {
                            if (shouldSkip)
                                continue;
                            if (shouldBundle) {
                                if (bundledHelpers.get(helper.name)) {
                                    continue;
                                }
                                bundledHelpers.set(helper.name, true);
                            }
                        }
                        else if (bundle) {
                            continue;
                        }
                        var pos = getTextPosWithWriteLine();
                        if (typeof helper.text === "string") {
                            writeLines(helper.text);
                        }
                        else {
                            writeLines(helper.text(makeFileLevelOptimisticUniqueName));
                        }
                        if (bundleFileInfo)
                            bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "emitHelpers", data: helper.name });
                        helpersEmitted = true;
                    }
                }
            }
            return helpersEmitted;
        }
        function getSortedEmitHelpers(node) {
            var helpers = ts.getEmitHelpers(node);
            return helpers && ts.stableSort(helpers, ts.compareEmitHelpers);
        }
        function emitNumericOrBigIntLiteral(node) {
            emitLiteral(node, false);
        }
        function emitLiteral(node, jsxAttributeEscape) {
            var text = getLiteralTextOfNode(node, printerOptions.neverAsciiEscape, jsxAttributeEscape);
            if ((printerOptions.sourceMap || printerOptions.inlineSourceMap)
                && (node.kind === 10 || ts.isTemplateLiteralKind(node.kind))) {
                writeLiteral(text);
            }
            else {
                writeStringLiteral(text);
            }
        }
        function emitUnparsedSourceOrPrepend(unparsed) {
            for (var _a = 0, _b = unparsed.texts; _a < _b.length; _a++) {
                var text = _b[_a];
                writeLine();
                emit(text);
            }
        }
        function writeUnparsedNode(unparsed) {
            writer.rawWrite(unparsed.parent.text.substring(unparsed.pos, unparsed.end));
        }
        function emitUnparsedTextLike(unparsed) {
            var pos = getTextPosWithWriteLine();
            writeUnparsedNode(unparsed);
            if (bundleFileInfo) {
                updateOrPushBundleFileTextLike(pos, writer.getTextPos(), unparsed.kind === 305 ?
                    "text" :
                    "internal");
            }
        }
        function emitUnparsedSyntheticReference(unparsed) {
            var pos = getTextPosWithWriteLine();
            writeUnparsedNode(unparsed);
            if (bundleFileInfo) {
                var section = ts.clone(unparsed.section);
                section.pos = pos;
                section.end = writer.getTextPos();
                bundleFileInfo.sections.push(section);
            }
        }
        function emitSnippetNode(hint, node, snippet) {
            switch (snippet.kind) {
                case 1:
                    emitPlaceholder(hint, node, snippet);
                    break;
                case 0:
                    emitTabStop(hint, node, snippet);
                    break;
            }
        }
        function emitPlaceholder(hint, node, snippet) {
            nonEscapingWrite("${".concat(snippet.order, ":"));
            pipelineEmitWithHintWorker(hint, node, false);
            nonEscapingWrite("}");
        }
        function emitTabStop(hint, node, snippet) {
            ts.Debug.assert(node.kind === 239, "A tab stop cannot be attached to a node of kind ".concat(ts.Debug.formatSyntaxKind(node.kind), "."));
            ts.Debug.assert(hint !== 5, "A tab stop cannot be attached to an embedded statement.");
            nonEscapingWrite("$".concat(snippet.order));
        }
        function emitIdentifier(node) {
            var writeText = node.symbol ? writeSymbol : write;
            writeText(getTextOfNode(node, false), node.symbol);
            emitList(node, node.typeArguments, 53776);
        }
        function emitPrivateIdentifier(node) {
            var writeText = node.symbol ? writeSymbol : write;
            writeText(getTextOfNode(node, false), node.symbol);
        }
        function emitQualifiedName(node) {
            emitEntityName(node.left);
            writePunctuation(".");
            emit(node.right);
        }
        function emitEntityName(node) {
            if (node.kind === 79) {
                emitExpression(node);
            }
            else {
                emit(node);
            }
        }
        function emitComputedPropertyName(node) {
            writePunctuation("[");
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfComputedPropertyName);
            writePunctuation("]");
        }
        function emitTypeParameter(node) {
            emitModifiers(node, node.modifiers);
            emit(node.name);
            if (node.constraint) {
                writeSpace();
                writeKeyword("extends");
                writeSpace();
                emit(node.constraint);
            }
            if (node.default) {
                writeSpace();
                writeOperator("=");
                writeSpace();
                emit(node.default);
            }
        }
        function emitParameter(node) {
            emitDecoratorsAndModifiers(node, node.modifiers);
            emit(node.dotDotDotToken);
            emitNodeWithWriter(node.name, writeParameter);
            emit(node.questionToken);
            if (node.parent && node.parent.kind === 320 && !node.name) {
                emit(node.type);
            }
            else {
                emitTypeAnnotation(node.type);
            }
            emitInitializer(node.initializer, node.type ? node.type.end : node.questionToken ? node.questionToken.end : node.name ? node.name.end : node.modifiers ? node.modifiers.end : node.pos, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitDecorator(decorator) {
            writePunctuation("@");
            emitExpression(decorator.expression, parenthesizer.parenthesizeLeftSideOfAccess);
        }
        function emitPropertySignature(node) {
            emitModifiers(node, node.modifiers);
            emitNodeWithWriter(node.name, writeProperty);
            emit(node.questionToken);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
        }
        function emitPropertyDeclaration(node) {
            emitDecoratorsAndModifiers(node, node.modifiers);
            emit(node.name);
            emit(node.questionToken);
            emit(node.exclamationToken);
            emitTypeAnnotation(node.type);
            emitInitializer(node.initializer, node.type ? node.type.end : node.questionToken ? node.questionToken.end : node.name.end, node);
            writeTrailingSemicolon();
        }
        function emitMethodSignature(node) {
            pushNameGenerationScope(node);
            emitModifiers(node, node.modifiers);
            emit(node.name);
            emit(node.questionToken);
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
            popNameGenerationScope(node);
        }
        function emitMethodDeclaration(node) {
            emitDecoratorsAndModifiers(node, node.modifiers);
            emit(node.asteriskToken);
            emit(node.name);
            emit(node.questionToken);
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitClassStaticBlockDeclaration(node) {
            writeKeyword("static");
            emitBlockFunctionBody(node.body);
        }
        function emitConstructor(node) {
            emitModifiers(node, node.modifiers);
            writeKeyword("constructor");
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitAccessorDeclaration(node) {
            emitDecoratorsAndModifiers(node, node.modifiers);
            writeKeyword(node.kind === 174 ? "get" : "set");
            writeSpace();
            emit(node.name);
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitCallSignature(node) {
            pushNameGenerationScope(node);
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
            popNameGenerationScope(node);
        }
        function emitConstructSignature(node) {
            pushNameGenerationScope(node);
            writeKeyword("new");
            writeSpace();
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
            popNameGenerationScope(node);
        }
        function emitIndexSignature(node) {
            emitModifiers(node, node.modifiers);
            emitParametersForIndexSignature(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeTrailingSemicolon();
        }
        function emitTemplateTypeSpan(node) {
            emit(node.type);
            emit(node.literal);
        }
        function emitSemicolonClassElement() {
            writeTrailingSemicolon();
        }
        function emitTypePredicate(node) {
            if (node.assertsModifier) {
                emit(node.assertsModifier);
                writeSpace();
            }
            emit(node.parameterName);
            if (node.type) {
                writeSpace();
                writeKeyword("is");
                writeSpace();
                emit(node.type);
            }
        }
        function emitTypeReference(node) {
            emit(node.typeName);
            emitTypeArguments(node, node.typeArguments);
        }
        function emitFunctionType(node) {
            pushNameGenerationScope(node);
            emitTypeParameters(node, node.typeParameters);
            emitParametersForArrow(node, node.parameters);
            writeSpace();
            writePunctuation("=>");
            writeSpace();
            emit(node.type);
            popNameGenerationScope(node);
        }
        function emitJSDocFunctionType(node) {
            writeKeyword("function");
            emitParameters(node, node.parameters);
            writePunctuation(":");
            emit(node.type);
        }
        function emitJSDocNullableType(node) {
            writePunctuation("?");
            emit(node.type);
        }
        function emitJSDocNonNullableType(node) {
            writePunctuation("!");
            emit(node.type);
        }
        function emitJSDocOptionalType(node) {
            emit(node.type);
            writePunctuation("=");
        }
        function emitConstructorType(node) {
            pushNameGenerationScope(node);
            emitModifiers(node, node.modifiers);
            writeKeyword("new");
            writeSpace();
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            writeSpace();
            writePunctuation("=>");
            writeSpace();
            emit(node.type);
            popNameGenerationScope(node);
        }
        function emitTypeQuery(node) {
            writeKeyword("typeof");
            writeSpace();
            emit(node.exprName);
            emitTypeArguments(node, node.typeArguments);
        }
        function emitTypeLiteral(node) {
            writePunctuation("{");
            var flags = ts.getEmitFlags(node) & 1 ? 768 : 32897;
            emitList(node, node.members, flags | 524288);
            writePunctuation("}");
        }
        function emitArrayType(node) {
            emit(node.elementType, parenthesizer.parenthesizeNonArrayTypeOfPostfixType);
            writePunctuation("[");
            writePunctuation("]");
        }
        function emitRestOrJSDocVariadicType(node) {
            writePunctuation("...");
            emit(node.type);
        }
        function emitTupleType(node) {
            emitTokenWithComment(22, node.pos, writePunctuation, node);
            var flags = ts.getEmitFlags(node) & 1 ? 528 : 657;
            emitList(node, node.elements, flags | 524288, parenthesizer.parenthesizeElementTypeOfTupleType);
            emitTokenWithComment(23, node.elements.end, writePunctuation, node);
        }
        function emitNamedTupleMember(node) {
            emit(node.dotDotDotToken);
            emit(node.name);
            emit(node.questionToken);
            emitTokenWithComment(58, node.name.end, writePunctuation, node);
            writeSpace();
            emit(node.type);
        }
        function emitOptionalType(node) {
            emit(node.type, parenthesizer.parenthesizeTypeOfOptionalType);
            writePunctuation("?");
        }
        function emitUnionType(node) {
            emitList(node, node.types, 516, parenthesizer.parenthesizeConstituentTypeOfUnionType);
        }
        function emitIntersectionType(node) {
            emitList(node, node.types, 520, parenthesizer.parenthesizeConstituentTypeOfIntersectionType);
        }
        function emitConditionalType(node) {
            emit(node.checkType, parenthesizer.parenthesizeCheckTypeOfConditionalType);
            writeSpace();
            writeKeyword("extends");
            writeSpace();
            emit(node.extendsType, parenthesizer.parenthesizeExtendsTypeOfConditionalType);
            writeSpace();
            writePunctuation("?");
            writeSpace();
            emit(node.trueType);
            writeSpace();
            writePunctuation(":");
            writeSpace();
            emit(node.falseType);
        }
        function emitInferType(node) {
            writeKeyword("infer");
            writeSpace();
            emit(node.typeParameter);
        }
        function emitParenthesizedType(node) {
            writePunctuation("(");
            emit(node.type);
            writePunctuation(")");
        }
        function emitThisType() {
            writeKeyword("this");
        }
        function emitTypeOperator(node) {
            writeTokenText(node.operator, writeKeyword);
            writeSpace();
            var parenthesizerRule = node.operator === 146 ?
                parenthesizer.parenthesizeOperandOfReadonlyTypeOperator :
                parenthesizer.parenthesizeOperandOfTypeOperator;
            emit(node.type, parenthesizerRule);
        }
        function emitIndexedAccessType(node) {
            emit(node.objectType, parenthesizer.parenthesizeNonArrayTypeOfPostfixType);
            writePunctuation("[");
            emit(node.indexType);
            writePunctuation("]");
        }
        function emitMappedType(node) {
            var emitFlags = ts.getEmitFlags(node);
            writePunctuation("{");
            if (emitFlags & 1) {
                writeSpace();
            }
            else {
                writeLine();
                increaseIndent();
            }
            if (node.readonlyToken) {
                emit(node.readonlyToken);
                if (node.readonlyToken.kind !== 146) {
                    writeKeyword("readonly");
                }
                writeSpace();
            }
            writePunctuation("[");
            pipelineEmit(3, node.typeParameter);
            if (node.nameType) {
                writeSpace();
                writeKeyword("as");
                writeSpace();
                emit(node.nameType);
            }
            writePunctuation("]");
            if (node.questionToken) {
                emit(node.questionToken);
                if (node.questionToken.kind !== 57) {
                    writePunctuation("?");
                }
            }
            writePunctuation(":");
            writeSpace();
            emit(node.type);
            writeTrailingSemicolon();
            if (emitFlags & 1) {
                writeSpace();
            }
            else {
                writeLine();
                decreaseIndent();
            }
            emitList(node, node.members, 2);
            writePunctuation("}");
        }
        function emitLiteralType(node) {
            emitExpression(node.literal);
        }
        function emitTemplateType(node) {
            emit(node.head);
            emitList(node, node.templateSpans, 262144);
        }
        function emitImportTypeNode(node) {
            if (node.isTypeOf) {
                writeKeyword("typeof");
                writeSpace();
            }
            writeKeyword("import");
            writePunctuation("(");
            emit(node.argument);
            if (node.assertions) {
                writePunctuation(",");
                writeSpace();
                writePunctuation("{");
                writeSpace();
                writeKeyword("assert");
                writePunctuation(":");
                writeSpace();
                var elements = node.assertions.assertClause.elements;
                emitList(node.assertions.assertClause, elements, 526226);
                writeSpace();
                writePunctuation("}");
            }
            writePunctuation(")");
            if (node.qualifier) {
                writePunctuation(".");
                emit(node.qualifier);
            }
            emitTypeArguments(node, node.typeArguments);
        }
        function emitObjectBindingPattern(node) {
            writePunctuation("{");
            emitList(node, node.elements, 525136);
            writePunctuation("}");
        }
        function emitArrayBindingPattern(node) {
            writePunctuation("[");
            emitList(node, node.elements, 524880);
            writePunctuation("]");
        }
        function emitBindingElement(node) {
            emit(node.dotDotDotToken);
            if (node.propertyName) {
                emit(node.propertyName);
                writePunctuation(":");
                writeSpace();
            }
            emit(node.name);
            emitInitializer(node.initializer, node.name.end, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitArrayLiteralExpression(node) {
            var elements = node.elements;
            var preferNewLine = node.multiLine ? 65536 : 0;
            emitExpressionList(node, elements, 8914 | preferNewLine, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitObjectLiteralExpression(node) {
            ts.forEach(node.properties, generateMemberNames);
            var indentedFlag = ts.getEmitFlags(node) & 65536;
            if (indentedFlag) {
                increaseIndent();
            }
            var preferNewLine = node.multiLine ? 65536 : 0;
            var allowTrailingComma = currentSourceFile && currentSourceFile.languageVersion >= 1 && !ts.isJsonSourceFile(currentSourceFile) ? 64 : 0;
            emitList(node, node.properties, 526226 | allowTrailingComma | preferNewLine);
            if (indentedFlag) {
                decreaseIndent();
            }
        }
        function emitPropertyAccessExpression(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            var token = node.questionDotToken || ts.setTextRangePosEnd(ts.factory.createToken(24), node.expression.end, node.name.pos);
            var linesBeforeDot = getLinesBetweenNodes(node, node.expression, token);
            var linesAfterDot = getLinesBetweenNodes(node, token, node.name);
            writeLinesAndIndent(linesBeforeDot, false);
            var shouldEmitDotDot = token.kind !== 28 &&
                mayNeedDotDotForPropertyAccess(node.expression) &&
                !writer.hasTrailingComment() &&
                !writer.hasTrailingWhitespace();
            if (shouldEmitDotDot) {
                writePunctuation(".");
            }
            if (node.questionDotToken) {
                emit(token);
            }
            else {
                emitTokenWithComment(token.kind, node.expression.end, writePunctuation, node);
            }
            writeLinesAndIndent(linesAfterDot, false);
            emit(node.name);
            decreaseIndentIf(linesBeforeDot, linesAfterDot);
        }
        function mayNeedDotDotForPropertyAccess(expression) {
            expression = ts.skipPartiallyEmittedExpressions(expression);
            if (ts.isNumericLiteral(expression)) {
                var text = getLiteralTextOfNode(expression, true, false);
                return !expression.numericLiteralFlags && !ts.stringContains(text, ts.tokenToString(24));
            }
            else if (ts.isAccessExpression(expression)) {
                var constantValue = ts.getConstantValue(expression);
                return typeof constantValue === "number" && isFinite(constantValue)
                    && Math.floor(constantValue) === constantValue;
            }
        }
        function emitElementAccessExpression(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            emit(node.questionDotToken);
            emitTokenWithComment(22, node.expression.end, writePunctuation, node);
            emitExpression(node.argumentExpression);
            emitTokenWithComment(23, node.argumentExpression.end, writePunctuation, node);
        }
        function emitCallExpression(node) {
            var indirectCall = ts.getEmitFlags(node) & 536870912;
            if (indirectCall) {
                writePunctuation("(");
                writeLiteral("0");
                writePunctuation(",");
                writeSpace();
            }
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            if (indirectCall) {
                writePunctuation(")");
            }
            emit(node.questionDotToken);
            emitTypeArguments(node, node.typeArguments);
            emitExpressionList(node, node.arguments, 2576, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitNewExpression(node) {
            emitTokenWithComment(103, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfNew);
            emitTypeArguments(node, node.typeArguments);
            emitExpressionList(node, node.arguments, 18960, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitTaggedTemplateExpression(node) {
            var indirectCall = ts.getEmitFlags(node) & 536870912;
            if (indirectCall) {
                writePunctuation("(");
                writeLiteral("0");
                writePunctuation(",");
                writeSpace();
            }
            emitExpression(node.tag, parenthesizer.parenthesizeLeftSideOfAccess);
            if (indirectCall) {
                writePunctuation(")");
            }
            emitTypeArguments(node, node.typeArguments);
            writeSpace();
            emitExpression(node.template);
        }
        function emitTypeAssertionExpression(node) {
            writePunctuation("<");
            emit(node.type);
            writePunctuation(">");
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitParenthesizedExpression(node) {
            var openParenPos = emitTokenWithComment(20, node.pos, writePunctuation, node);
            var indented = writeLineSeparatorsAndIndentBefore(node.expression, node);
            emitExpression(node.expression, undefined);
            writeLineSeparatorsAfter(node.expression, node);
            decreaseIndentIf(indented);
            emitTokenWithComment(21, node.expression ? node.expression.end : openParenPos, writePunctuation, node);
        }
        function emitFunctionExpression(node) {
            generateNameIfNeeded(node.name);
            emitFunctionDeclarationOrExpression(node);
        }
        function emitArrowFunction(node) {
            emitModifiers(node, node.modifiers);
            emitSignatureAndBody(node, emitArrowFunctionHead);
        }
        function emitArrowFunctionHead(node) {
            emitTypeParameters(node, node.typeParameters);
            emitParametersForArrow(node, node.parameters);
            emitTypeAnnotation(node.type);
            writeSpace();
            emit(node.equalsGreaterThanToken);
        }
        function emitDeleteExpression(node) {
            emitTokenWithComment(89, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitTypeOfExpression(node) {
            emitTokenWithComment(112, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitVoidExpression(node) {
            emitTokenWithComment(114, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitAwaitExpression(node) {
            emitTokenWithComment(133, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function emitPrefixUnaryExpression(node) {
            writeTokenText(node.operator, writeOperator);
            if (shouldEmitWhitespaceBeforeOperand(node)) {
                writeSpace();
            }
            emitExpression(node.operand, parenthesizer.parenthesizeOperandOfPrefixUnary);
        }
        function shouldEmitWhitespaceBeforeOperand(node) {
            var operand = node.operand;
            return operand.kind === 221
                && ((node.operator === 39 && (operand.operator === 39 || operand.operator === 45))
                    || (node.operator === 40 && (operand.operator === 40 || operand.operator === 46)));
        }
        function emitPostfixUnaryExpression(node) {
            emitExpression(node.operand, parenthesizer.parenthesizeOperandOfPostfixUnary);
            writeTokenText(node.operator, writeOperator);
        }
        function createEmitBinaryExpression() {
            return ts.createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, undefined);
            function onEnter(node, state) {
                if (state) {
                    state.stackIndex++;
                    state.preserveSourceNewlinesStack[state.stackIndex] = preserveSourceNewlines;
                    state.containerPosStack[state.stackIndex] = containerPos;
                    state.containerEndStack[state.stackIndex] = containerEnd;
                    state.declarationListContainerEndStack[state.stackIndex] = declarationListContainerEnd;
                    var emitComments_1 = state.shouldEmitCommentsStack[state.stackIndex] = shouldEmitComments(node);
                    var emitSourceMaps = state.shouldEmitSourceMapsStack[state.stackIndex] = shouldEmitSourceMaps(node);
                    onBeforeEmitNode === null || onBeforeEmitNode === void 0 ? void 0 : onBeforeEmitNode(node);
                    if (emitComments_1)
                        emitCommentsBeforeNode(node);
                    if (emitSourceMaps)
                        emitSourceMapsBeforeNode(node);
                    beforeEmitNode(node);
                }
                else {
                    state = {
                        stackIndex: 0,
                        preserveSourceNewlinesStack: [undefined],
                        containerPosStack: [-1],
                        containerEndStack: [-1],
                        declarationListContainerEndStack: [-1],
                        shouldEmitCommentsStack: [false],
                        shouldEmitSourceMapsStack: [false],
                    };
                }
                return state;
            }
            function onLeft(next, _workArea, parent) {
                return maybeEmitExpression(next, parent, "left");
            }
            function onOperator(operatorToken, _state, node) {
                var isCommaOperator = operatorToken.kind !== 27;
                var linesBeforeOperator = getLinesBetweenNodes(node, node.left, operatorToken);
                var linesAfterOperator = getLinesBetweenNodes(node, operatorToken, node.right);
                writeLinesAndIndent(linesBeforeOperator, isCommaOperator);
                emitLeadingCommentsOfPosition(operatorToken.pos);
                writeTokenNode(operatorToken, operatorToken.kind === 101 ? writeKeyword : writeOperator);
                emitTrailingCommentsOfPosition(operatorToken.end, true);
                writeLinesAndIndent(linesAfterOperator, true);
            }
            function onRight(next, _workArea, parent) {
                return maybeEmitExpression(next, parent, "right");
            }
            function onExit(node, state) {
                var linesBeforeOperator = getLinesBetweenNodes(node, node.left, node.operatorToken);
                var linesAfterOperator = getLinesBetweenNodes(node, node.operatorToken, node.right);
                decreaseIndentIf(linesBeforeOperator, linesAfterOperator);
                if (state.stackIndex > 0) {
                    var savedPreserveSourceNewlines = state.preserveSourceNewlinesStack[state.stackIndex];
                    var savedContainerPos = state.containerPosStack[state.stackIndex];
                    var savedContainerEnd = state.containerEndStack[state.stackIndex];
                    var savedDeclarationListContainerEnd = state.declarationListContainerEndStack[state.stackIndex];
                    var shouldEmitComments_1 = state.shouldEmitCommentsStack[state.stackIndex];
                    var shouldEmitSourceMaps_1 = state.shouldEmitSourceMapsStack[state.stackIndex];
                    afterEmitNode(savedPreserveSourceNewlines);
                    if (shouldEmitSourceMaps_1)
                        emitSourceMapsAfterNode(node);
                    if (shouldEmitComments_1)
                        emitCommentsAfterNode(node, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd);
                    onAfterEmitNode === null || onAfterEmitNode === void 0 ? void 0 : onAfterEmitNode(node);
                    state.stackIndex--;
                }
            }
            function maybeEmitExpression(next, parent, side) {
                var parenthesizerRule = side === "left" ?
                    parenthesizer.getParenthesizeLeftSideOfBinaryForOperator(parent.operatorToken.kind) :
                    parenthesizer.getParenthesizeRightSideOfBinaryForOperator(parent.operatorToken.kind);
                var pipelinePhase = getPipelinePhase(0, 1, next);
                if (pipelinePhase === pipelineEmitWithSubstitution) {
                    ts.Debug.assertIsDefined(lastSubstitution);
                    next = parenthesizerRule(ts.cast(lastSubstitution, ts.isExpression));
                    pipelinePhase = getNextPipelinePhase(1, 1, next);
                    lastSubstitution = undefined;
                }
                if (pipelinePhase === pipelineEmitWithComments ||
                    pipelinePhase === pipelineEmitWithSourceMaps ||
                    pipelinePhase === pipelineEmitWithHint) {
                    if (ts.isBinaryExpression(next)) {
                        return next;
                    }
                }
                currentParenthesizerRule = parenthesizerRule;
                pipelinePhase(1, next);
            }
        }
        function emitConditionalExpression(node) {
            var linesBeforeQuestion = getLinesBetweenNodes(node, node.condition, node.questionToken);
            var linesAfterQuestion = getLinesBetweenNodes(node, node.questionToken, node.whenTrue);
            var linesBeforeColon = getLinesBetweenNodes(node, node.whenTrue, node.colonToken);
            var linesAfterColon = getLinesBetweenNodes(node, node.colonToken, node.whenFalse);
            emitExpression(node.condition, parenthesizer.parenthesizeConditionOfConditionalExpression);
            writeLinesAndIndent(linesBeforeQuestion, true);
            emit(node.questionToken);
            writeLinesAndIndent(linesAfterQuestion, true);
            emitExpression(node.whenTrue, parenthesizer.parenthesizeBranchOfConditionalExpression);
            decreaseIndentIf(linesBeforeQuestion, linesAfterQuestion);
            writeLinesAndIndent(linesBeforeColon, true);
            emit(node.colonToken);
            writeLinesAndIndent(linesAfterColon, true);
            emitExpression(node.whenFalse, parenthesizer.parenthesizeBranchOfConditionalExpression);
            decreaseIndentIf(linesBeforeColon, linesAfterColon);
        }
        function emitTemplateExpression(node) {
            emit(node.head);
            emitList(node, node.templateSpans, 262144);
        }
        function emitYieldExpression(node) {
            emitTokenWithComment(125, node.pos, writeKeyword, node);
            emit(node.asteriskToken);
            emitExpressionWithLeadingSpace(node.expression && parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsiAndDisallowedComma);
        }
        function emitSpreadElement(node) {
            emitTokenWithComment(25, node.pos, writePunctuation, node);
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitClassExpression(node) {
            generateNameIfNeeded(node.name);
            emitClassDeclarationOrExpression(node);
        }
        function emitExpressionWithTypeArguments(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            emitTypeArguments(node, node.typeArguments);
        }
        function emitAsExpression(node) {
            emitExpression(node.expression, undefined);
            if (node.type) {
                writeSpace();
                writeKeyword("as");
                writeSpace();
                emit(node.type);
            }
        }
        function emitNonNullExpression(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess);
            writeOperator("!");
        }
        function emitSatisfiesExpression(node) {
            emitExpression(node.expression, undefined);
            if (node.type) {
                writeSpace();
                writeKeyword("satisfies");
                writeSpace();
                emit(node.type);
            }
        }
        function emitMetaProperty(node) {
            writeToken(node.keywordToken, node.pos, writePunctuation);
            writePunctuation(".");
            emit(node.name);
        }
        function emitTemplateSpan(node) {
            emitExpression(node.expression);
            emit(node.literal);
        }
        function emitBlock(node) {
            emitBlockStatements(node, !node.multiLine && isEmptyBlock(node));
        }
        function emitBlockStatements(node, forceSingleLine) {
            emitTokenWithComment(18, node.pos, writePunctuation, node);
            var format = forceSingleLine || ts.getEmitFlags(node) & 1 ? 768 : 129;
            emitList(node, node.statements, format);
            emitTokenWithComment(19, node.statements.end, writePunctuation, node, !!(format & 1));
        }
        function emitVariableStatement(node) {
            emitModifiers(node, node.modifiers);
            emit(node.declarationList);
            writeTrailingSemicolon();
        }
        function emitEmptyStatement(isEmbeddedStatement) {
            if (isEmbeddedStatement) {
                writePunctuation(";");
            }
            else {
                writeTrailingSemicolon();
            }
        }
        function emitExpressionStatement(node) {
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfExpressionStatement);
            if (!currentSourceFile || !ts.isJsonSourceFile(currentSourceFile) || ts.nodeIsSynthesized(node.expression)) {
                writeTrailingSemicolon();
            }
        }
        function emitIfStatement(node) {
            var openParenPos = emitTokenWithComment(99, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.thenStatement);
            if (node.elseStatement) {
                writeLineOrSpace(node, node.thenStatement, node.elseStatement);
                emitTokenWithComment(91, node.thenStatement.end, writeKeyword, node);
                if (node.elseStatement.kind === 242) {
                    writeSpace();
                    emit(node.elseStatement);
                }
                else {
                    emitEmbeddedStatement(node, node.elseStatement);
                }
            }
        }
        function emitWhileClause(node, startPos) {
            var openParenPos = emitTokenWithComment(115, startPos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21, node.expression.end, writePunctuation, node);
        }
        function emitDoStatement(node) {
            emitTokenWithComment(90, node.pos, writeKeyword, node);
            emitEmbeddedStatement(node, node.statement);
            if (ts.isBlock(node.statement) && !preserveSourceNewlines) {
                writeSpace();
            }
            else {
                writeLineOrSpace(node, node.statement, node.expression);
            }
            emitWhileClause(node, node.statement.end);
            writeTrailingSemicolon();
        }
        function emitWhileStatement(node) {
            emitWhileClause(node, node.pos);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForStatement(node) {
            var openParenPos = emitTokenWithComment(97, node.pos, writeKeyword, node);
            writeSpace();
            var pos = emitTokenWithComment(20, openParenPos, writePunctuation, node);
            emitForBinding(node.initializer);
            pos = emitTokenWithComment(26, node.initializer ? node.initializer.end : pos, writePunctuation, node);
            emitExpressionWithLeadingSpace(node.condition);
            pos = emitTokenWithComment(26, node.condition ? node.condition.end : pos, writePunctuation, node);
            emitExpressionWithLeadingSpace(node.incrementor);
            emitTokenWithComment(21, node.incrementor ? node.incrementor.end : pos, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForInStatement(node) {
            var openParenPos = emitTokenWithComment(97, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20, openParenPos, writePunctuation, node);
            emitForBinding(node.initializer);
            writeSpace();
            emitTokenWithComment(101, node.initializer.end, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression);
            emitTokenWithComment(21, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForOfStatement(node) {
            var openParenPos = emitTokenWithComment(97, node.pos, writeKeyword, node);
            writeSpace();
            emitWithTrailingSpace(node.awaitModifier);
            emitTokenWithComment(20, openParenPos, writePunctuation, node);
            emitForBinding(node.initializer);
            writeSpace();
            emitTokenWithComment(162, node.initializer.end, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression);
            emitTokenWithComment(21, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitForBinding(node) {
            if (node !== undefined) {
                if (node.kind === 258) {
                    emit(node);
                }
                else {
                    emitExpression(node);
                }
            }
        }
        function emitContinueStatement(node) {
            emitTokenWithComment(86, node.pos, writeKeyword, node);
            emitWithLeadingSpace(node.label);
            writeTrailingSemicolon();
        }
        function emitBreakStatement(node) {
            emitTokenWithComment(81, node.pos, writeKeyword, node);
            emitWithLeadingSpace(node.label);
            writeTrailingSemicolon();
        }
        function emitTokenWithComment(token, pos, writer, contextNode, indentLeading) {
            var node = ts.getParseTreeNode(contextNode);
            var isSimilarNode = node && node.kind === contextNode.kind;
            var startPos = pos;
            if (isSimilarNode && currentSourceFile) {
                pos = ts.skipTrivia(currentSourceFile.text, pos);
            }
            if (isSimilarNode && contextNode.pos !== startPos) {
                var needsIndent = indentLeading && currentSourceFile && !ts.positionsAreOnSameLine(startPos, pos, currentSourceFile);
                if (needsIndent) {
                    increaseIndent();
                }
                emitLeadingCommentsOfPosition(startPos);
                if (needsIndent) {
                    decreaseIndent();
                }
            }
            pos = writeTokenText(token, writer, pos);
            if (isSimilarNode && contextNode.end !== pos) {
                var isJsxExprContext = contextNode.kind === 291;
                emitTrailingCommentsOfPosition(pos, !isJsxExprContext, isJsxExprContext);
            }
            return pos;
        }
        function commentWillEmitNewLine(node) {
            return node.kind === 2 || !!node.hasTrailingNewLine;
        }
        function willEmitLeadingNewLine(node) {
            if (!currentSourceFile)
                return false;
            if (ts.some(ts.getLeadingCommentRanges(currentSourceFile.text, node.pos), commentWillEmitNewLine))
                return true;
            if (ts.some(ts.getSyntheticLeadingComments(node), commentWillEmitNewLine))
                return true;
            if (ts.isPartiallyEmittedExpression(node)) {
                if (node.pos !== node.expression.pos) {
                    if (ts.some(ts.getTrailingCommentRanges(currentSourceFile.text, node.expression.pos), commentWillEmitNewLine))
                        return true;
                }
                return willEmitLeadingNewLine(node.expression);
            }
            return false;
        }
        function parenthesizeExpressionForNoAsi(node) {
            if (!commentsDisabled && ts.isPartiallyEmittedExpression(node) && willEmitLeadingNewLine(node)) {
                var parseNode = ts.getParseTreeNode(node);
                if (parseNode && ts.isParenthesizedExpression(parseNode)) {
                    var parens = ts.factory.createParenthesizedExpression(node.expression);
                    ts.setOriginalNode(parens, node);
                    ts.setTextRange(parens, parseNode);
                    return parens;
                }
                return ts.factory.createParenthesizedExpression(node);
            }
            return node;
        }
        function parenthesizeExpressionForNoAsiAndDisallowedComma(node) {
            return parenthesizeExpressionForNoAsi(parenthesizer.parenthesizeExpressionForDisallowedComma(node));
        }
        function emitReturnStatement(node) {
            emitTokenWithComment(105, node.pos, writeKeyword, node);
            emitExpressionWithLeadingSpace(node.expression && parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsi);
            writeTrailingSemicolon();
        }
        function emitWithStatement(node) {
            var openParenPos = emitTokenWithComment(116, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21, node.expression.end, writePunctuation, node);
            emitEmbeddedStatement(node, node.statement);
        }
        function emitSwitchStatement(node) {
            var openParenPos = emitTokenWithComment(107, node.pos, writeKeyword, node);
            writeSpace();
            emitTokenWithComment(20, openParenPos, writePunctuation, node);
            emitExpression(node.expression);
            emitTokenWithComment(21, node.expression.end, writePunctuation, node);
            writeSpace();
            emit(node.caseBlock);
        }
        function emitLabeledStatement(node) {
            emit(node.label);
            emitTokenWithComment(58, node.label.end, writePunctuation, node);
            writeSpace();
            emit(node.statement);
        }
        function emitThrowStatement(node) {
            emitTokenWithComment(109, node.pos, writeKeyword, node);
            emitExpressionWithLeadingSpace(parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsi);
            writeTrailingSemicolon();
        }
        function emitTryStatement(node) {
            emitTokenWithComment(111, node.pos, writeKeyword, node);
            writeSpace();
            emit(node.tryBlock);
            if (node.catchClause) {
                writeLineOrSpace(node, node.tryBlock, node.catchClause);
                emit(node.catchClause);
            }
            if (node.finallyBlock) {
                writeLineOrSpace(node, node.catchClause || node.tryBlock, node.finallyBlock);
                emitTokenWithComment(96, (node.catchClause || node.tryBlock).end, writeKeyword, node);
                writeSpace();
                emit(node.finallyBlock);
            }
        }
        function emitDebuggerStatement(node) {
            writeToken(87, node.pos, writeKeyword);
            writeTrailingSemicolon();
        }
        function emitVariableDeclaration(node) {
            var _a, _b, _c, _d, _e;
            emit(node.name);
            emit(node.exclamationToken);
            emitTypeAnnotation(node.type);
            emitInitializer(node.initializer, (_e = (_b = (_a = node.type) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : (_d = (_c = node.name.emitNode) === null || _c === void 0 ? void 0 : _c.typeNode) === null || _d === void 0 ? void 0 : _d.end) !== null && _e !== void 0 ? _e : node.name.end, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitVariableDeclarationList(node) {
            writeKeyword(ts.isLet(node) ? "let" : ts.isVarConst(node) ? "const" : "var");
            writeSpace();
            emitList(node, node.declarations, 528);
        }
        function emitFunctionDeclaration(node) {
            emitFunctionDeclarationOrExpression(node);
        }
        function emitFunctionDeclarationOrExpression(node) {
            emitModifiers(node, node.modifiers);
            writeKeyword("function");
            emit(node.asteriskToken);
            writeSpace();
            emitIdentifierName(node.name);
            emitSignatureAndBody(node, emitSignatureHead);
        }
        function emitSignatureAndBody(node, emitSignatureHead) {
            var body = node.body;
            if (body) {
                if (ts.isBlock(body)) {
                    var indentedFlag = ts.getEmitFlags(node) & 65536;
                    if (indentedFlag) {
                        increaseIndent();
                    }
                    pushNameGenerationScope(node);
                    ts.forEach(node.parameters, generateNames);
                    generateNames(node.body);
                    emitSignatureHead(node);
                    emitBlockFunctionBody(body);
                    popNameGenerationScope(node);
                    if (indentedFlag) {
                        decreaseIndent();
                    }
                }
                else {
                    emitSignatureHead(node);
                    writeSpace();
                    emitExpression(body, parenthesizer.parenthesizeConciseBodyOfArrowFunction);
                }
            }
            else {
                emitSignatureHead(node);
                writeTrailingSemicolon();
            }
        }
        function emitSignatureHead(node) {
            emitTypeParameters(node, node.typeParameters);
            emitParameters(node, node.parameters);
            emitTypeAnnotation(node.type);
        }
        function shouldEmitBlockFunctionBodyOnSingleLine(body) {
            if (ts.getEmitFlags(body) & 1) {
                return true;
            }
            if (body.multiLine) {
                return false;
            }
            if (!ts.nodeIsSynthesized(body) && currentSourceFile && !ts.rangeIsOnSingleLine(body, currentSourceFile)) {
                return false;
            }
            if (getLeadingLineTerminatorCount(body, ts.firstOrUndefined(body.statements), 2)
                || getClosingLineTerminatorCount(body, ts.lastOrUndefined(body.statements), 2, body.statements)) {
                return false;
            }
            var previousStatement;
            for (var _a = 0, _b = body.statements; _a < _b.length; _a++) {
                var statement = _b[_a];
                if (getSeparatingLineTerminatorCount(previousStatement, statement, 2) > 0) {
                    return false;
                }
                previousStatement = statement;
            }
            return true;
        }
        function emitBlockFunctionBody(body) {
            onBeforeEmitNode === null || onBeforeEmitNode === void 0 ? void 0 : onBeforeEmitNode(body);
            writeSpace();
            writePunctuation("{");
            increaseIndent();
            var emitBlockFunctionBody = shouldEmitBlockFunctionBodyOnSingleLine(body)
                ? emitBlockFunctionBodyOnSingleLine
                : emitBlockFunctionBodyWorker;
            emitBodyWithDetachedComments(body, body.statements, emitBlockFunctionBody);
            decreaseIndent();
            writeToken(19, body.statements.end, writePunctuation, body);
            onAfterEmitNode === null || onAfterEmitNode === void 0 ? void 0 : onAfterEmitNode(body);
        }
        function emitBlockFunctionBodyOnSingleLine(body) {
            emitBlockFunctionBodyWorker(body, true);
        }
        function emitBlockFunctionBodyWorker(body, emitBlockFunctionBodyOnSingleLine) {
            var statementOffset = emitPrologueDirectives(body.statements);
            var pos = writer.getTextPos();
            emitHelpers(body);
            if (statementOffset === 0 && pos === writer.getTextPos() && emitBlockFunctionBodyOnSingleLine) {
                decreaseIndent();
                emitList(body, body.statements, 768);
                increaseIndent();
            }
            else {
                emitList(body, body.statements, 1, undefined, statementOffset);
            }
        }
        function emitClassDeclaration(node) {
            emitClassDeclarationOrExpression(node);
        }
        function emitClassDeclarationOrExpression(node) {
            ts.forEach(node.members, generateMemberNames);
            emitDecoratorsAndModifiers(node, node.modifiers);
            writeKeyword("class");
            if (node.name) {
                writeSpace();
                emitIdentifierName(node.name);
            }
            var indentedFlag = ts.getEmitFlags(node) & 65536;
            if (indentedFlag) {
                increaseIndent();
            }
            emitTypeParameters(node, node.typeParameters);
            emitList(node, node.heritageClauses, 0);
            writeSpace();
            writePunctuation("{");
            emitList(node, node.members, 129);
            writePunctuation("}");
            if (indentedFlag) {
                decreaseIndent();
            }
        }
        function emitInterfaceDeclaration(node) {
            emitModifiers(node, node.modifiers);
            writeKeyword("interface");
            writeSpace();
            emit(node.name);
            emitTypeParameters(node, node.typeParameters);
            emitList(node, node.heritageClauses, 512);
            writeSpace();
            writePunctuation("{");
            emitList(node, node.members, 129);
            writePunctuation("}");
        }
        function emitTypeAliasDeclaration(node) {
            emitModifiers(node, node.modifiers);
            writeKeyword("type");
            writeSpace();
            emit(node.name);
            emitTypeParameters(node, node.typeParameters);
            writeSpace();
            writePunctuation("=");
            writeSpace();
            emit(node.type);
            writeTrailingSemicolon();
        }
        function emitEnumDeclaration(node) {
            emitModifiers(node, node.modifiers);
            writeKeyword("enum");
            writeSpace();
            emit(node.name);
            writeSpace();
            writePunctuation("{");
            emitList(node, node.members, 145);
            writePunctuation("}");
        }
        function emitModuleDeclaration(node) {
            emitModifiers(node, node.modifiers);
            if (~node.flags & 1024) {
                writeKeyword(node.flags & 16 ? "namespace" : "module");
                writeSpace();
            }
            emit(node.name);
            var body = node.body;
            if (!body)
                return writeTrailingSemicolon();
            while (body && ts.isModuleDeclaration(body)) {
                writePunctuation(".");
                emit(body.name);
                body = body.body;
            }
            writeSpace();
            emit(body);
        }
        function emitModuleBlock(node) {
            pushNameGenerationScope(node);
            ts.forEach(node.statements, generateNames);
            emitBlockStatements(node, isEmptyBlock(node));
            popNameGenerationScope(node);
        }
        function emitCaseBlock(node) {
            emitTokenWithComment(18, node.pos, writePunctuation, node);
            emitList(node, node.clauses, 129);
            emitTokenWithComment(19, node.clauses.end, writePunctuation, node, true);
        }
        function emitImportEqualsDeclaration(node) {
            emitModifiers(node, node.modifiers);
            emitTokenWithComment(100, node.modifiers ? node.modifiers.end : node.pos, writeKeyword, node);
            writeSpace();
            if (node.isTypeOnly) {
                emitTokenWithComment(154, node.pos, writeKeyword, node);
                writeSpace();
            }
            emit(node.name);
            writeSpace();
            emitTokenWithComment(63, node.name.end, writePunctuation, node);
            writeSpace();
            emitModuleReference(node.moduleReference);
            writeTrailingSemicolon();
        }
        function emitModuleReference(node) {
            if (node.kind === 79) {
                emitExpression(node);
            }
            else {
                emit(node);
            }
        }
        function emitImportDeclaration(node) {
            emitModifiers(node, node.modifiers);
            emitTokenWithComment(100, node.modifiers ? node.modifiers.end : node.pos, writeKeyword, node);
            writeSpace();
            if (node.importClause) {
                emit(node.importClause);
                writeSpace();
                emitTokenWithComment(158, node.importClause.end, writeKeyword, node);
                writeSpace();
            }
            emitExpression(node.moduleSpecifier);
            if (node.assertClause) {
                emitWithLeadingSpace(node.assertClause);
            }
            writeTrailingSemicolon();
        }
        function emitImportClause(node) {
            if (node.isTypeOnly) {
                emitTokenWithComment(154, node.pos, writeKeyword, node);
                writeSpace();
            }
            emit(node.name);
            if (node.name && node.namedBindings) {
                emitTokenWithComment(27, node.name.end, writePunctuation, node);
                writeSpace();
            }
            emit(node.namedBindings);
        }
        function emitNamespaceImport(node) {
            var asPos = emitTokenWithComment(41, node.pos, writePunctuation, node);
            writeSpace();
            emitTokenWithComment(128, asPos, writeKeyword, node);
            writeSpace();
            emit(node.name);
        }
        function emitNamedImports(node) {
            emitNamedImportsOrExports(node);
        }
        function emitImportSpecifier(node) {
            emitImportOrExportSpecifier(node);
        }
        function emitExportAssignment(node) {
            var nextPos = emitTokenWithComment(93, node.pos, writeKeyword, node);
            writeSpace();
            if (node.isExportEquals) {
                emitTokenWithComment(63, nextPos, writeOperator, node);
            }
            else {
                emitTokenWithComment(88, nextPos, writeKeyword, node);
            }
            writeSpace();
            emitExpression(node.expression, node.isExportEquals ?
                parenthesizer.getParenthesizeRightSideOfBinaryForOperator(63) :
                parenthesizer.parenthesizeExpressionOfExportDefault);
            writeTrailingSemicolon();
        }
        function emitExportDeclaration(node) {
            emitModifiers(node, node.modifiers);
            var nextPos = emitTokenWithComment(93, node.pos, writeKeyword, node);
            writeSpace();
            if (node.isTypeOnly) {
                nextPos = emitTokenWithComment(154, nextPos, writeKeyword, node);
                writeSpace();
            }
            if (node.exportClause) {
                emit(node.exportClause);
            }
            else {
                nextPos = emitTokenWithComment(41, nextPos, writePunctuation, node);
            }
            if (node.moduleSpecifier) {
                writeSpace();
                var fromPos = node.exportClause ? node.exportClause.end : nextPos;
                emitTokenWithComment(158, fromPos, writeKeyword, node);
                writeSpace();
                emitExpression(node.moduleSpecifier);
            }
            if (node.assertClause) {
                emitWithLeadingSpace(node.assertClause);
            }
            writeTrailingSemicolon();
        }
        function emitAssertClause(node) {
            emitTokenWithComment(130, node.pos, writeKeyword, node);
            writeSpace();
            var elements = node.elements;
            emitList(node, elements, 526226);
        }
        function emitAssertEntry(node) {
            emit(node.name);
            writePunctuation(":");
            writeSpace();
            var value = node.value;
            if ((ts.getEmitFlags(value) & 512) === 0) {
                var commentRange = ts.getCommentRange(value);
                emitTrailingCommentsOfPosition(commentRange.pos);
            }
            emit(value);
        }
        function emitNamespaceExportDeclaration(node) {
            var nextPos = emitTokenWithComment(93, node.pos, writeKeyword, node);
            writeSpace();
            nextPos = emitTokenWithComment(128, nextPos, writeKeyword, node);
            writeSpace();
            nextPos = emitTokenWithComment(143, nextPos, writeKeyword, node);
            writeSpace();
            emit(node.name);
            writeTrailingSemicolon();
        }
        function emitNamespaceExport(node) {
            var asPos = emitTokenWithComment(41, node.pos, writePunctuation, node);
            writeSpace();
            emitTokenWithComment(128, asPos, writeKeyword, node);
            writeSpace();
            emit(node.name);
        }
        function emitNamedExports(node) {
            emitNamedImportsOrExports(node);
        }
        function emitExportSpecifier(node) {
            emitImportOrExportSpecifier(node);
        }
        function emitNamedImportsOrExports(node) {
            writePunctuation("{");
            emitList(node, node.elements, 525136);
            writePunctuation("}");
        }
        function emitImportOrExportSpecifier(node) {
            if (node.isTypeOnly) {
                writeKeyword("type");
                writeSpace();
            }
            if (node.propertyName) {
                emit(node.propertyName);
                writeSpace();
                emitTokenWithComment(128, node.propertyName.end, writeKeyword, node);
                writeSpace();
            }
            emit(node.name);
        }
        function emitExternalModuleReference(node) {
            writeKeyword("require");
            writePunctuation("(");
            emitExpression(node.expression);
            writePunctuation(")");
        }
        function emitJsxElement(node) {
            emit(node.openingElement);
            emitList(node, node.children, 262144);
            emit(node.closingElement);
        }
        function emitJsxSelfClosingElement(node) {
            writePunctuation("<");
            emitJsxTagName(node.tagName);
            emitTypeArguments(node, node.typeArguments);
            writeSpace();
            emit(node.attributes);
            writePunctuation("/>");
        }
        function emitJsxFragment(node) {
            emit(node.openingFragment);
            emitList(node, node.children, 262144);
            emit(node.closingFragment);
        }
        function emitJsxOpeningElementOrFragment(node) {
            writePunctuation("<");
            if (ts.isJsxOpeningElement(node)) {
                var indented = writeLineSeparatorsAndIndentBefore(node.tagName, node);
                emitJsxTagName(node.tagName);
                emitTypeArguments(node, node.typeArguments);
                if (node.attributes.properties && node.attributes.properties.length > 0) {
                    writeSpace();
                }
                emit(node.attributes);
                writeLineSeparatorsAfter(node.attributes, node);
                decreaseIndentIf(indented);
            }
            writePunctuation(">");
        }
        function emitJsxText(node) {
            writer.writeLiteral(node.text);
        }
        function emitJsxClosingElementOrFragment(node) {
            writePunctuation("</");
            if (ts.isJsxClosingElement(node)) {
                emitJsxTagName(node.tagName);
            }
            writePunctuation(">");
        }
        function emitJsxAttributes(node) {
            emitList(node, node.properties, 262656);
        }
        function emitJsxAttribute(node) {
            emit(node.name);
            emitNodeWithPrefix("=", writePunctuation, node.initializer, emitJsxAttributeValue);
        }
        function emitJsxSpreadAttribute(node) {
            writePunctuation("{...");
            emitExpression(node.expression);
            writePunctuation("}");
        }
        function hasTrailingCommentsAtPosition(pos) {
            var result = false;
            ts.forEachTrailingCommentRange((currentSourceFile === null || currentSourceFile === void 0 ? void 0 : currentSourceFile.text) || "", pos + 1, function () { return result = true; });
            return result;
        }
        function hasLeadingCommentsAtPosition(pos) {
            var result = false;
            ts.forEachLeadingCommentRange((currentSourceFile === null || currentSourceFile === void 0 ? void 0 : currentSourceFile.text) || "", pos + 1, function () { return result = true; });
            return result;
        }
        function hasCommentsAtPosition(pos) {
            return hasTrailingCommentsAtPosition(pos) || hasLeadingCommentsAtPosition(pos);
        }
        function emitJsxExpression(node) {
            var _a;
            if (node.expression || (!commentsDisabled && !ts.nodeIsSynthesized(node) && hasCommentsAtPosition(node.pos))) {
                var isMultiline = currentSourceFile && !ts.nodeIsSynthesized(node) && ts.getLineAndCharacterOfPosition(currentSourceFile, node.pos).line !== ts.getLineAndCharacterOfPosition(currentSourceFile, node.end).line;
                if (isMultiline) {
                    writer.increaseIndent();
                }
                var end = emitTokenWithComment(18, node.pos, writePunctuation, node);
                emit(node.dotDotDotToken);
                emitExpression(node.expression);
                emitTokenWithComment(19, ((_a = node.expression) === null || _a === void 0 ? void 0 : _a.end) || end, writePunctuation, node);
                if (isMultiline) {
                    writer.decreaseIndent();
                }
            }
        }
        function emitJsxTagName(node) {
            if (node.kind === 79) {
                emitExpression(node);
            }
            else {
                emit(node);
            }
        }
        function emitCaseClause(node) {
            emitTokenWithComment(82, node.pos, writeKeyword, node);
            writeSpace();
            emitExpression(node.expression, parenthesizer.parenthesizeExpressionForDisallowedComma);
            emitCaseOrDefaultClauseRest(node, node.statements, node.expression.end);
        }
        function emitDefaultClause(node) {
            var pos = emitTokenWithComment(88, node.pos, writeKeyword, node);
            emitCaseOrDefaultClauseRest(node, node.statements, pos);
        }
        function emitCaseOrDefaultClauseRest(parentNode, statements, colonPos) {
            var emitAsSingleStatement = statements.length === 1 &&
                (!currentSourceFile ||
                    ts.nodeIsSynthesized(parentNode) ||
                    ts.nodeIsSynthesized(statements[0]) ||
                    ts.rangeStartPositionsAreOnSameLine(parentNode, statements[0], currentSourceFile));
            var format = 163969;
            if (emitAsSingleStatement) {
                writeToken(58, colonPos, writePunctuation, parentNode);
                writeSpace();
                format &= ~(1 | 128);
            }
            else {
                emitTokenWithComment(58, colonPos, writePunctuation, parentNode);
            }
            emitList(parentNode, statements, format);
        }
        function emitHeritageClause(node) {
            writeSpace();
            writeTokenText(node.token, writeKeyword);
            writeSpace();
            emitList(node, node.types, 528);
        }
        function emitCatchClause(node) {
            var openParenPos = emitTokenWithComment(83, node.pos, writeKeyword, node);
            writeSpace();
            if (node.variableDeclaration) {
                emitTokenWithComment(20, openParenPos, writePunctuation, node);
                emit(node.variableDeclaration);
                emitTokenWithComment(21, node.variableDeclaration.end, writePunctuation, node);
                writeSpace();
            }
            emit(node.block);
        }
        function emitPropertyAssignment(node) {
            emit(node.name);
            writePunctuation(":");
            writeSpace();
            var initializer = node.initializer;
            if ((ts.getEmitFlags(initializer) & 512) === 0) {
                var commentRange = ts.getCommentRange(initializer);
                emitTrailingCommentsOfPosition(commentRange.pos);
            }
            emitExpression(initializer, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitShorthandPropertyAssignment(node) {
            emit(node.name);
            if (node.objectAssignmentInitializer) {
                writeSpace();
                writePunctuation("=");
                writeSpace();
                emitExpression(node.objectAssignmentInitializer, parenthesizer.parenthesizeExpressionForDisallowedComma);
            }
        }
        function emitSpreadAssignment(node) {
            if (node.expression) {
                emitTokenWithComment(25, node.pos, writePunctuation, node);
                emitExpression(node.expression, parenthesizer.parenthesizeExpressionForDisallowedComma);
            }
        }
        function emitEnumMember(node) {
            emit(node.name);
            emitInitializer(node.initializer, node.name.end, node, parenthesizer.parenthesizeExpressionForDisallowedComma);
        }
        function emitJSDoc(node) {
            write("/**");
            if (node.comment) {
                var text = ts.getTextOfJSDocComment(node.comment);
                if (text) {
                    var lines = text.split(/\r\n?|\n/g);
                    for (var _a = 0, lines_2 = lines; _a < lines_2.length; _a++) {
                        var line = lines_2[_a];
                        writeLine();
                        writeSpace();
                        writePunctuation("*");
                        writeSpace();
                        write(line);
                    }
                }
            }
            if (node.tags) {
                if (node.tags.length === 1 && node.tags[0].kind === 346 && !node.comment) {
                    writeSpace();
                    emit(node.tags[0]);
                }
                else {
                    emitList(node, node.tags, 33);
                }
            }
            writeSpace();
            write("*/");
        }
        function emitJSDocSimpleTypedTag(tag) {
            emitJSDocTagName(tag.tagName);
            emitJSDocTypeExpression(tag.typeExpression);
            emitJSDocComment(tag.comment);
        }
        function emitJSDocSeeTag(tag) {
            emitJSDocTagName(tag.tagName);
            emit(tag.name);
            emitJSDocComment(tag.comment);
        }
        function emitJSDocNameReference(node) {
            writeSpace();
            writePunctuation("{");
            emit(node.name);
            writePunctuation("}");
        }
        function emitJSDocHeritageTag(tag) {
            emitJSDocTagName(tag.tagName);
            writeSpace();
            writePunctuation("{");
            emit(tag.class);
            writePunctuation("}");
            emitJSDocComment(tag.comment);
        }
        function emitJSDocTemplateTag(tag) {
            emitJSDocTagName(tag.tagName);
            emitJSDocTypeExpression(tag.constraint);
            writeSpace();
            emitList(tag, tag.typeParameters, 528);
            emitJSDocComment(tag.comment);
        }
        function emitJSDocTypedefTag(tag) {
            emitJSDocTagName(tag.tagName);
            if (tag.typeExpression) {
                if (tag.typeExpression.kind === 312) {
                    emitJSDocTypeExpression(tag.typeExpression);
                }
                else {
                    writeSpace();
                    writePunctuation("{");
                    write("Object");
                    if (tag.typeExpression.isArrayType) {
                        writePunctuation("[");
                        writePunctuation("]");
                    }
                    writePunctuation("}");
                }
            }
            if (tag.fullName) {
                writeSpace();
                emit(tag.fullName);
            }
            emitJSDocComment(tag.comment);
            if (tag.typeExpression && tag.typeExpression.kind === 325) {
                emitJSDocTypeLiteral(tag.typeExpression);
            }
        }
        function emitJSDocCallbackTag(tag) {
            emitJSDocTagName(tag.tagName);
            if (tag.name) {
                writeSpace();
                emit(tag.name);
            }
            emitJSDocComment(tag.comment);
            emitJSDocSignature(tag.typeExpression);
        }
        function emitJSDocSimpleTag(tag) {
            emitJSDocTagName(tag.tagName);
            emitJSDocComment(tag.comment);
        }
        function emitJSDocTypeLiteral(lit) {
            emitList(lit, ts.factory.createNodeArray(lit.jsDocPropertyTags), 33);
        }
        function emitJSDocSignature(sig) {
            if (sig.typeParameters) {
                emitList(sig, ts.factory.createNodeArray(sig.typeParameters), 33);
            }
            if (sig.parameters) {
                emitList(sig, ts.factory.createNodeArray(sig.parameters), 33);
            }
            if (sig.type) {
                writeLine();
                writeSpace();
                writePunctuation("*");
                writeSpace();
                emit(sig.type);
            }
        }
        function emitJSDocPropertyLikeTag(param) {
            emitJSDocTagName(param.tagName);
            emitJSDocTypeExpression(param.typeExpression);
            writeSpace();
            if (param.isBracketed) {
                writePunctuation("[");
            }
            emit(param.name);
            if (param.isBracketed) {
                writePunctuation("]");
            }
            emitJSDocComment(param.comment);
        }
        function emitJSDocTagName(tagName) {
            writePunctuation("@");
            emit(tagName);
        }
        function emitJSDocComment(comment) {
            var text = ts.getTextOfJSDocComment(comment);
            if (text) {
                writeSpace();
                write(text);
            }
        }
        function emitJSDocTypeExpression(typeExpression) {
            if (typeExpression) {
                writeSpace();
                writePunctuation("{");
                emit(typeExpression.type);
                writePunctuation("}");
            }
        }
        function emitSourceFile(node) {
            writeLine();
            var statements = node.statements;
            var shouldEmitDetachedComment = statements.length === 0 ||
                !ts.isPrologueDirective(statements[0]) ||
                ts.nodeIsSynthesized(statements[0]);
            if (shouldEmitDetachedComment) {
                emitBodyWithDetachedComments(node, statements, emitSourceFileWorker);
                return;
            }
            emitSourceFileWorker(node);
        }
        function emitSyntheticTripleSlashReferencesIfNeeded(node) {
            emitTripleSlashDirectives(!!node.hasNoDefaultLib, node.syntheticFileReferences || [], node.syntheticTypeReferences || [], node.syntheticLibReferences || []);
            for (var _a = 0, _b = node.prepends; _a < _b.length; _a++) {
                var prepend = _b[_a];
                if (ts.isUnparsedSource(prepend) && prepend.syntheticReferences) {
                    for (var _c = 0, _d = prepend.syntheticReferences; _c < _d.length; _c++) {
                        var ref = _d[_c];
                        emit(ref);
                        writeLine();
                    }
                }
            }
        }
        function emitTripleSlashDirectivesIfNeeded(node) {
            if (node.isDeclarationFile)
                emitTripleSlashDirectives(node.hasNoDefaultLib, node.referencedFiles, node.typeReferenceDirectives, node.libReferenceDirectives);
        }
        function emitTripleSlashDirectives(hasNoDefaultLib, files, types, libs) {
            if (hasNoDefaultLib) {
                var pos = writer.getTextPos();
                writeComment("/// <reference no-default-lib=\"true\"/>");
                if (bundleFileInfo)
                    bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "no-default-lib" });
                writeLine();
            }
            if (currentSourceFile && currentSourceFile.moduleName) {
                writeComment("/// <amd-module name=\"".concat(currentSourceFile.moduleName, "\" />"));
                writeLine();
            }
            if (currentSourceFile && currentSourceFile.amdDependencies) {
                for (var _a = 0, _b = currentSourceFile.amdDependencies; _a < _b.length; _a++) {
                    var dep = _b[_a];
                    if (dep.name) {
                        writeComment("/// <amd-dependency name=\"".concat(dep.name, "\" path=\"").concat(dep.path, "\" />"));
                    }
                    else {
                        writeComment("/// <amd-dependency path=\"".concat(dep.path, "\" />"));
                    }
                    writeLine();
                }
            }
            for (var _c = 0, files_2 = files; _c < files_2.length; _c++) {
                var directive = files_2[_c];
                var pos = writer.getTextPos();
                writeComment("/// <reference path=\"".concat(directive.fileName, "\" />"));
                if (bundleFileInfo)
                    bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "reference", data: directive.fileName });
                writeLine();
            }
            for (var _d = 0, types_23 = types; _d < types_23.length; _d++) {
                var directive = types_23[_d];
                var pos = writer.getTextPos();
                var resolutionMode = directive.resolutionMode && directive.resolutionMode !== (currentSourceFile === null || currentSourceFile === void 0 ? void 0 : currentSourceFile.impliedNodeFormat)
                    ? "resolution-mode=\"".concat(directive.resolutionMode === ts.ModuleKind.ESNext ? "import" : "require", "\"")
                    : "";
                writeComment("/// <reference types=\"".concat(directive.fileName, "\" ").concat(resolutionMode, "/>"));
                if (bundleFileInfo)
                    bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: !directive.resolutionMode ? "type" : directive.resolutionMode === ts.ModuleKind.ESNext ? "type-import" : "type-require", data: directive.fileName });
                writeLine();
            }
            for (var _e = 0, libs_1 = libs; _e < libs_1.length; _e++) {
                var directive = libs_1[_e];
                var pos = writer.getTextPos();
                writeComment("/// <reference lib=\"".concat(directive.fileName, "\" />"));
                if (bundleFileInfo)
                    bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "lib", data: directive.fileName });
                writeLine();
            }
        }
        function emitSourceFileWorker(node) {
            var statements = node.statements;
            pushNameGenerationScope(node);
            ts.forEach(node.statements, generateNames);
            emitHelpers(node);
            var index = ts.findIndex(statements, function (statement) { return !ts.isPrologueDirective(statement); });
            emitTripleSlashDirectivesIfNeeded(node);
            emitList(node, statements, 1, undefined, index === -1 ? statements.length : index);
            popNameGenerationScope(node);
        }
        function emitPartiallyEmittedExpression(node) {
            var emitFlags = ts.getEmitFlags(node);
            if (!(emitFlags & 512) && node.pos !== node.expression.pos) {
                emitTrailingCommentsOfPosition(node.expression.pos);
            }
            emitExpression(node.expression);
            if (!(emitFlags & 1024) && node.end !== node.expression.end) {
                emitLeadingCommentsOfPosition(node.expression.end);
            }
        }
        function emitCommaList(node) {
            emitExpressionList(node, node.elements, 528, undefined);
        }
        function emitPrologueDirectives(statements, sourceFile, seenPrologueDirectives, recordBundleFileSection) {
            var needsToSetSourceFile = !!sourceFile;
            for (var i = 0; i < statements.length; i++) {
                var statement = statements[i];
                if (ts.isPrologueDirective(statement)) {
                    var shouldEmitPrologueDirective = seenPrologueDirectives ? !seenPrologueDirectives.has(statement.expression.text) : true;
                    if (shouldEmitPrologueDirective) {
                        if (needsToSetSourceFile) {
                            needsToSetSourceFile = false;
                            setSourceFile(sourceFile);
                        }
                        writeLine();
                        var pos = writer.getTextPos();
                        emit(statement);
                        if (recordBundleFileSection && bundleFileInfo)
                            bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "prologue", data: statement.expression.text });
                        if (seenPrologueDirectives) {
                            seenPrologueDirectives.add(statement.expression.text);
                        }
                    }
                }
                else {
                    return i;
                }
            }
            return statements.length;
        }
        function emitUnparsedPrologues(prologues, seenPrologueDirectives) {
            for (var _a = 0, prologues_1 = prologues; _a < prologues_1.length; _a++) {
                var prologue = prologues_1[_a];
                if (!seenPrologueDirectives.has(prologue.data)) {
                    writeLine();
                    var pos = writer.getTextPos();
                    emit(prologue);
                    if (bundleFileInfo)
                        bundleFileInfo.sections.push({ pos: pos, end: writer.getTextPos(), kind: "prologue", data: prologue.data });
                    if (seenPrologueDirectives) {
                        seenPrologueDirectives.add(prologue.data);
                    }
                }
            }
        }
        function emitPrologueDirectivesIfNeeded(sourceFileOrBundle) {
            if (ts.isSourceFile(sourceFileOrBundle)) {
                emitPrologueDirectives(sourceFileOrBundle.statements, sourceFileOrBundle);
            }
            else {
                var seenPrologueDirectives = new ts.Set();
                for (var _a = 0, _b = sourceFileOrBundle.prepends; _a < _b.length; _a++) {
                    var prepend = _b[_a];
                    emitUnparsedPrologues(prepend.prologues, seenPrologueDirectives);
                }
                for (var _c = 0, _d = sourceFileOrBundle.sourceFiles; _c < _d.length; _c++) {
                    var sourceFile = _d[_c];
                    emitPrologueDirectives(sourceFile.statements, sourceFile, seenPrologueDirectives, true);
                }
                setSourceFile(undefined);
            }
        }
        function getPrologueDirectivesFromBundledSourceFiles(bundle) {
            var seenPrologueDirectives = new ts.Set();
            var prologues;
            for (var index = 0; index < bundle.sourceFiles.length; index++) {
                var sourceFile = bundle.sourceFiles[index];
                var directives = void 0;
                var end = 0;
                for (var _a = 0, _b = sourceFile.statements; _a < _b.length; _a++) {
                    var statement = _b[_a];
                    if (!ts.isPrologueDirective(statement))
                        break;
                    if (seenPrologueDirectives.has(statement.expression.text))
                        continue;
                    seenPrologueDirectives.add(statement.expression.text);
                    (directives || (directives = [])).push({
                        pos: statement.pos,
                        end: statement.end,
                        expression: {
                            pos: statement.expression.pos,
                            end: statement.expression.end,
                            text: statement.expression.text
                        }
                    });
                    end = end < statement.end ? statement.end : end;
                }
                if (directives)
                    (prologues || (prologues = [])).push({ file: index, text: sourceFile.text.substring(0, end), directives: directives });
            }
            return prologues;
        }
        function emitShebangIfNeeded(sourceFileOrBundle) {
            if (ts.isSourceFile(sourceFileOrBundle) || ts.isUnparsedSource(sourceFileOrBundle)) {
                var shebang = ts.getShebang(sourceFileOrBundle.text);
                if (shebang) {
                    writeComment(shebang);
                    writeLine();
                    return true;
                }
            }
            else {
                for (var _a = 0, _b = sourceFileOrBundle.prepends; _a < _b.length; _a++) {
                    var prepend = _b[_a];
                    ts.Debug.assertNode(prepend, ts.isUnparsedSource);
                    if (emitShebangIfNeeded(prepend)) {
                        return true;
                    }
                }
                for (var _c = 0, _d = sourceFileOrBundle.sourceFiles; _c < _d.length; _c++) {
                    var sourceFile = _d[_c];
                    if (emitShebangIfNeeded(sourceFile)) {
                        return true;
                    }
                }
            }
        }
        function emitNodeWithWriter(node, writer) {
            if (!node)
                return;
            var savedWrite = write;
            write = writer;
            emit(node);
            write = savedWrite;
        }
        function emitDecoratorsAndModifiers(node, modifiers) {
            if (modifiers === null || modifiers === void 0 ? void 0 : modifiers.length) {
                if (ts.every(modifiers, ts.isModifier)) {
                    return emitModifiers(node, modifiers);
                }
                if (ts.every(modifiers, ts.isDecorator)) {
                    return emitDecorators(node, modifiers);
                }
                onBeforeEmitNodeArray === null || onBeforeEmitNodeArray === void 0 ? void 0 : onBeforeEmitNodeArray(modifiers);
                var lastMode = void 0;
                var mode = void 0;
                var start = 0;
                var pos = 0;
                while (start < modifiers.length) {
                    while (pos < modifiers.length) {
                        var modifier = modifiers[pos];
                        mode = ts.isDecorator(modifier) ? "decorators" : "modifiers";
                        if (lastMode === undefined) {
                            lastMode = mode;
                        }
                        else if (mode !== lastMode) {
                            break;
                        }
                        pos++;
                    }
                    var textRange = { pos: -1, end: -1 };
                    if (start === 0)
                        textRange.pos = modifiers.pos;
                    if (pos === modifiers.length - 1)
                        textRange.end = modifiers.end;
                    emitNodeListItems(emit, node, modifiers, lastMode === "modifiers" ? 2359808 : 2146305, undefined, start, pos - start, false, textRange);
                    start = pos;
                    lastMode = mode;
                    pos++;
                }
                onAfterEmitNodeArray === null || onAfterEmitNodeArray === void 0 ? void 0 : onAfterEmitNodeArray(modifiers);
            }
        }
        function emitModifiers(node, modifiers) {
            emitList(node, modifiers, 2359808);
        }
        function emitTypeAnnotation(node) {
            if (node) {
                writePunctuation(":");
                writeSpace();
                emit(node);
            }
        }
        function emitInitializer(node, equalCommentStartPos, container, parenthesizerRule) {
            if (node) {
                writeSpace();
                emitTokenWithComment(63, equalCommentStartPos, writeOperator, container);
                writeSpace();
                emitExpression(node, parenthesizerRule);
            }
        }
        function emitNodeWithPrefix(prefix, prefixWriter, node, emit) {
            if (node) {
                prefixWriter(prefix);
                emit(node);
            }
        }
        function emitWithLeadingSpace(node) {
            if (node) {
                writeSpace();
                emit(node);
            }
        }
        function emitExpressionWithLeadingSpace(node, parenthesizerRule) {
            if (node) {
                writeSpace();
                emitExpression(node, parenthesizerRule);
            }
        }
        function emitWithTrailingSpace(node) {
            if (node) {
                emit(node);
                writeSpace();
            }
        }
        function emitEmbeddedStatement(parent, node) {
            if (ts.isBlock(node) || ts.getEmitFlags(parent) & 1) {
                writeSpace();
                emit(node);
            }
            else {
                writeLine();
                increaseIndent();
                if (ts.isEmptyStatement(node)) {
                    pipelineEmit(5, node);
                }
                else {
                    emit(node);
                }
                decreaseIndent();
            }
        }
        function emitDecorators(parentNode, decorators) {
            emitList(parentNode, decorators, 2146305);
        }
        function emitTypeArguments(parentNode, typeArguments) {
            emitList(parentNode, typeArguments, 53776, typeArgumentParenthesizerRuleSelector);
        }
        function emitTypeParameters(parentNode, typeParameters) {
            if (ts.isFunctionLike(parentNode) && parentNode.typeArguments) {
                return emitTypeArguments(parentNode, parentNode.typeArguments);
            }
            emitList(parentNode, typeParameters, 53776);
        }
        function emitParameters(parentNode, parameters) {
            emitList(parentNode, parameters, 2576);
        }
        function canEmitSimpleArrowHead(parentNode, parameters) {
            var parameter = ts.singleOrUndefined(parameters);
            return parameter
                && parameter.pos === parentNode.pos
                && ts.isArrowFunction(parentNode)
                && !parentNode.type
                && !ts.some(parentNode.modifiers)
                && !ts.some(parentNode.typeParameters)
                && !ts.some(parameter.modifiers)
                && !parameter.dotDotDotToken
                && !parameter.questionToken
                && !parameter.type
                && !parameter.initializer
                && ts.isIdentifier(parameter.name);
        }
        function emitParametersForArrow(parentNode, parameters) {
            if (canEmitSimpleArrowHead(parentNode, parameters)) {
                emitList(parentNode, parameters, 2576 & ~2048);
            }
            else {
                emitParameters(parentNode, parameters);
            }
        }
        function emitParametersForIndexSignature(parentNode, parameters) {
            emitList(parentNode, parameters, 8848);
        }
        function writeDelimiter(format) {
            switch (format & 60) {
                case 0:
                    break;
                case 16:
                    writePunctuation(",");
                    break;
                case 4:
                    writeSpace();
                    writePunctuation("|");
                    break;
                case 32:
                    writeSpace();
                    writePunctuation("*");
                    writeSpace();
                    break;
                case 8:
                    writeSpace();
                    writePunctuation("&");
                    break;
            }
        }
        function emitList(parentNode, children, format, parenthesizerRule, start, count) {
            emitNodeList(emit, parentNode, children, format, parenthesizerRule, start, count);
        }
        function emitExpressionList(parentNode, children, format, parenthesizerRule, start, count) {
            emitNodeList(emitExpression, parentNode, children, format, parenthesizerRule, start, count);
        }
        function emitNodeList(emit, parentNode, children, format, parenthesizerRule, start, count) {
            if (start === void 0) { start = 0; }
            if (count === void 0) { count = children ? children.length - start : 0; }
            var isUndefined = children === undefined;
            if (isUndefined && format & 16384) {
                return;
            }
            var isEmpty = children === undefined || start >= children.length || count === 0;
            if (isEmpty && format & 32768) {
                onBeforeEmitNodeArray === null || onBeforeEmitNodeArray === void 0 ? void 0 : onBeforeEmitNodeArray(children);
                onAfterEmitNodeArray === null || onAfterEmitNodeArray === void 0 ? void 0 : onAfterEmitNodeArray(children);
                return;
            }
            if (format & 15360) {
                writePunctuation(getOpeningBracket(format));
                if (isEmpty && children) {
                    emitTrailingCommentsOfPosition(children.pos, true);
                }
            }
            onBeforeEmitNodeArray === null || onBeforeEmitNodeArray === void 0 ? void 0 : onBeforeEmitNodeArray(children);
            if (isEmpty) {
                if (format & 1 && !(preserveSourceNewlines && (!parentNode || currentSourceFile && ts.rangeIsOnSingleLine(parentNode, currentSourceFile)))) {
                    writeLine();
                }
                else if (format & 256 && !(format & 524288)) {
                    writeSpace();
                }
            }
            else {
                emitNodeListItems(emit, parentNode, children, format, parenthesizerRule, start, count, children.hasTrailingComma, children);
            }
            onAfterEmitNodeArray === null || onAfterEmitNodeArray === void 0 ? void 0 : onAfterEmitNodeArray(children);
            if (format & 15360) {
                if (isEmpty && children) {
                    emitLeadingCommentsOfPosition(children.end);
                }
                writePunctuation(getClosingBracket(format));
            }
        }
        function emitNodeListItems(emit, parentNode, children, format, parenthesizerRule, start, count, hasTrailingComma, childrenTextRange) {
            var mayEmitInterveningComments = (format & 262144) === 0;
            var shouldEmitInterveningComments = mayEmitInterveningComments;
            var leadingLineTerminatorCount = getLeadingLineTerminatorCount(parentNode, children[start], format);
            if (leadingLineTerminatorCount) {
                writeLine(leadingLineTerminatorCount);
                shouldEmitInterveningComments = false;
            }
            else if (format & 256) {
                writeSpace();
            }
            if (format & 128) {
                increaseIndent();
            }
            var emitListItem = getEmitListItem(emit, parenthesizerRule);
            var previousSibling;
            var previousSourceFileTextKind;
            var shouldDecreaseIndentAfterEmit = false;
            for (var i = 0; i < count; i++) {
                var child = children[start + i];
                if (format & 32) {
                    writeLine();
                    writeDelimiter(format);
                }
                else if (previousSibling) {
                    if (format & 60 && previousSibling.end !== (parentNode ? parentNode.end : -1)) {
                        emitLeadingCommentsOfPosition(previousSibling.end);
                    }
                    writeDelimiter(format);
                    recordBundleFileInternalSectionEnd(previousSourceFileTextKind);
                    var separatingLineTerminatorCount = getSeparatingLineTerminatorCount(previousSibling, child, format);
                    if (separatingLineTerminatorCount > 0) {
                        if ((format & (3 | 128)) === 0) {
                            increaseIndent();
                            shouldDecreaseIndentAfterEmit = true;
                        }
                        writeLine(separatingLineTerminatorCount);
                        shouldEmitInterveningComments = false;
                    }
                    else if (previousSibling && format & 512) {
                        writeSpace();
                    }
                }
                previousSourceFileTextKind = recordBundleFileInternalSectionStart(child);
                if (shouldEmitInterveningComments) {
                    var commentRange = ts.getCommentRange(child);
                    emitTrailingCommentsOfPosition(commentRange.pos);
                }
                else {
                    shouldEmitInterveningComments = mayEmitInterveningComments;
                }
                nextListElementPos = child.pos;
                emitListItem(child, emit, parenthesizerRule, i);
                if (shouldDecreaseIndentAfterEmit) {
                    decreaseIndent();
                    shouldDecreaseIndentAfterEmit = false;
                }
                previousSibling = child;
            }
            var emitFlags = previousSibling ? ts.getEmitFlags(previousSibling) : 0;
            var skipTrailingComments = commentsDisabled || !!(emitFlags & 1024);
            var emitTrailingComma = hasTrailingComma && (format & 64) && (format & 16);
            if (emitTrailingComma) {
                if (previousSibling && !skipTrailingComments) {
                    emitTokenWithComment(27, previousSibling.end, writePunctuation, previousSibling);
                }
                else {
                    writePunctuation(",");
                }
            }
            if (previousSibling && (parentNode ? parentNode.end : -1) !== previousSibling.end && (format & 60) && !skipTrailingComments) {
                emitLeadingCommentsOfPosition(emitTrailingComma && (childrenTextRange === null || childrenTextRange === void 0 ? void 0 : childrenTextRange.end) ? childrenTextRange.end : previousSibling.end);
            }
            if (format & 128) {
                decreaseIndent();
            }
            recordBundleFileInternalSectionEnd(previousSourceFileTextKind);
            var closingLineTerminatorCount = getClosingLineTerminatorCount(parentNode, children[start + count - 1], format, childrenTextRange);
            if (closingLineTerminatorCount) {
                writeLine(closingLineTerminatorCount);
            }
            else if (format & (2097152 | 256)) {
                writeSpace();
            }
        }
        function writeLiteral(s) {
            writer.writeLiteral(s);
        }
        function writeStringLiteral(s) {
            writer.writeStringLiteral(s);
        }
        function writeBase(s) {
            writer.write(s);
        }
        function writeSymbol(s, sym) {
            writer.writeSymbol(s, sym);
        }
        function writePunctuation(s) {
            writer.writePunctuation(s);
        }
        function writeTrailingSemicolon() {
            writer.writeTrailingSemicolon(";");
        }
        function writeKeyword(s) {
            writer.writeKeyword(s);
        }
        function writeOperator(s) {
            writer.writeOperator(s);
        }
        function writeParameter(s) {
            writer.writeParameter(s);
        }
        function writeComment(s) {
            writer.writeComment(s);
        }
        function writeSpace() {
            writer.writeSpace(" ");
        }
        function writeProperty(s) {
            writer.writeProperty(s);
        }
        function nonEscapingWrite(s) {
            if (writer.nonEscapingWrite) {
                writer.nonEscapingWrite(s);
            }
            else {
                writer.write(s);
            }
        }
        function writeLine(count) {
            if (count === void 0) { count = 1; }
            for (var i = 0; i < count; i++) {
                writer.writeLine(i > 0);
            }
        }
        function increaseIndent() {
            writer.increaseIndent();
        }
        function decreaseIndent() {
            writer.decreaseIndent();
        }
        function writeToken(token, pos, writer, contextNode) {
            return !sourceMapsDisabled
                ? emitTokenWithSourceMap(contextNode, token, writer, pos, writeTokenText)
                : writeTokenText(token, writer, pos);
        }
        function writeTokenNode(node, writer) {
            if (onBeforeEmitToken) {
                onBeforeEmitToken(node);
            }
            writer(ts.tokenToString(node.kind));
            if (onAfterEmitToken) {
                onAfterEmitToken(node);
            }
        }
        function writeTokenText(token, writer, pos) {
            var tokenString = ts.tokenToString(token);
            writer(tokenString);
            return pos < 0 ? pos : pos + tokenString.length;
        }
        function writeLineOrSpace(parentNode, prevChildNode, nextChildNode) {
            if (ts.getEmitFlags(parentNode) & 1) {
                writeSpace();
            }
            else if (preserveSourceNewlines) {
                var lines = getLinesBetweenNodes(parentNode, prevChildNode, nextChildNode);
                if (lines) {
                    writeLine(lines);
                }
                else {
                    writeSpace();
                }
            }
            else {
                writeLine();
            }
        }
        function writeLines(text) {
            var lines = text.split(/\r\n?|\n/g);
            var indentation = ts.guessIndentation(lines);
            for (var _a = 0, lines_3 = lines; _a < lines_3.length; _a++) {
                var lineText = lines_3[_a];
                var line = indentation ? lineText.slice(indentation) : lineText;
                if (line.length) {
                    writeLine();
                    write(line);
                }
            }
        }
        function writeLinesAndIndent(lineCount, writeSpaceIfNotIndenting) {
            if (lineCount) {
                increaseIndent();
                writeLine(lineCount);
            }
            else if (writeSpaceIfNotIndenting) {
                writeSpace();
            }
        }
        function decreaseIndentIf(value1, value2) {
            if (value1) {
                decreaseIndent();
            }
            if (value2) {
                decreaseIndent();
            }
        }
        function getLeadingLineTerminatorCount(parentNode, firstChild, format) {
            if (format & 2 || preserveSourceNewlines) {
                if (format & 65536) {
                    return 1;
                }
                if (firstChild === undefined) {
                    return !parentNode || currentSourceFile && ts.rangeIsOnSingleLine(parentNode, currentSourceFile) ? 0 : 1;
                }
                if (firstChild.pos === nextListElementPos) {
                    return 0;
                }
                if (firstChild.kind === 11) {
                    return 0;
                }
                if (currentSourceFile && parentNode &&
                    !ts.positionIsSynthesized(parentNode.pos) &&
                    !ts.nodeIsSynthesized(firstChild) &&
                    (!firstChild.parent || ts.getOriginalNode(firstChild.parent) === ts.getOriginalNode(parentNode))) {
                    if (preserveSourceNewlines) {
                        return getEffectiveLines(function (includeComments) { return ts.getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter(firstChild.pos, parentNode.pos, currentSourceFile, includeComments); });
                    }
                    return ts.rangeStartPositionsAreOnSameLine(parentNode, firstChild, currentSourceFile) ? 0 : 1;
                }
                if (synthesizedNodeStartsOnNewLine(firstChild, format)) {
                    return 1;
                }
            }
            return format & 1 ? 1 : 0;
        }
        function getSeparatingLineTerminatorCount(previousNode, nextNode, format) {
            if (format & 2 || preserveSourceNewlines) {
                if (previousNode === undefined || nextNode === undefined) {
                    return 0;
                }
                if (nextNode.kind === 11) {
                    return 0;
                }
                else if (currentSourceFile && !ts.nodeIsSynthesized(previousNode) && !ts.nodeIsSynthesized(nextNode)) {
                    if (preserveSourceNewlines && siblingNodePositionsAreComparable(previousNode, nextNode)) {
                        return getEffectiveLines(function (includeComments) { return ts.getLinesBetweenRangeEndAndRangeStart(previousNode, nextNode, currentSourceFile, includeComments); });
                    }
                    else if (!preserveSourceNewlines && originalNodesHaveSameParent(previousNode, nextNode)) {
                        return ts.rangeEndIsOnSameLineAsRangeStart(previousNode, nextNode, currentSourceFile) ? 0 : 1;
                    }
                    return format & 65536 ? 1 : 0;
                }
                else if (synthesizedNodeStartsOnNewLine(previousNode, format) || synthesizedNodeStartsOnNewLine(nextNode, format)) {
                    return 1;
                }
            }
            else if (ts.getStartsOnNewLine(nextNode)) {
                return 1;
            }
            return format & 1 ? 1 : 0;
        }
        function getClosingLineTerminatorCount(parentNode, lastChild, format, childrenTextRange) {
            if (format & 2 || preserveSourceNewlines) {
                if (format & 65536) {
                    return 1;
                }
                if (lastChild === undefined) {
                    return !parentNode || currentSourceFile && ts.rangeIsOnSingleLine(parentNode, currentSourceFile) ? 0 : 1;
                }
                if (currentSourceFile && parentNode && !ts.positionIsSynthesized(parentNode.pos) && !ts.nodeIsSynthesized(lastChild) && (!lastChild.parent || lastChild.parent === parentNode)) {
                    if (preserveSourceNewlines) {
                        var end_1 = childrenTextRange && !ts.positionIsSynthesized(childrenTextRange.end) ? childrenTextRange.end : lastChild.end;
                        return getEffectiveLines(function (includeComments) { return ts.getLinesBetweenPositionAndNextNonWhitespaceCharacter(end_1, parentNode.end, currentSourceFile, includeComments); });
                    }
                    return ts.rangeEndPositionsAreOnSameLine(parentNode, lastChild, currentSourceFile) ? 0 : 1;
                }
                if (synthesizedNodeStartsOnNewLine(lastChild, format)) {
                    return 1;
                }
            }
            if (format & 1 && !(format & 131072)) {
                return 1;
            }
            return 