lueSymbol(reference, startInDeclarationContainer) {
            var resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
            if (resolvedSymbol) {
                return resolvedSymbol;
            }
            var location = reference;
            if (startInDeclarationContainer) {
                var parent = reference.parent;
                if (ts.isDeclaration(parent) && reference === parent.name) {
                    location = getDeclarationContainer(parent);
                }
            }
            return resolveName(location, reference.escapedText, 111551 | 1048576 | 2097152, undefined, undefined, true);
        }
        function getReferencedValueOrAliasSymbol(reference) {
            var resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
            if (resolvedSymbol && resolvedSymbol !== unknownSymbol) {
                return resolvedSymbol;
            }
            return resolveName(reference, reference.escapedText, 111551 | 1048576 | 2097152, undefined, undefined, true, undefined, undefined);
        }
        function getReferencedValueDeclaration(referenceIn) {
            if (!ts.isGeneratedIdentifier(referenceIn)) {
                var reference = ts.getParseTreeNode(referenceIn, ts.isIdentifier);
                if (reference) {
                    var symbol = getReferencedValueSymbol(reference);
                    if (symbol) {
                        return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration;
                    }
                }
            }
            return undefined;
        }
        function isLiteralConstDeclaration(node) {
            if (ts.isDeclarationReadonly(node) || ts.isVariableDeclaration(node) && ts.isVarConst(node)) {
                return isFreshLiteralType(getTypeOfSymbol(getSymbolOfNode(node)));
            }
            return false;
        }
        function literalTypeToNode(type, enclosing, tracker) {
            var enumResult = type.flags & 1024 ? nodeBuilder.symbolToExpression(type.symbol, 111551, enclosing, undefined, tracker)
                : type === trueType ? ts.factory.createTrue() : type === falseType && ts.factory.createFalse();
            if (enumResult)
                return enumResult;
            var literalValue = type.value;
            return typeof literalValue === "object" ? ts.factory.createBigIntLiteral(literalValue) :
                typeof literalValue === "number" ? ts.factory.createNumericLiteral(literalValue) :
                    ts.factory.createStringLiteral(literalValue);
        }
        function createLiteralConstValue(node, tracker) {
            var type = getTypeOfSymbol(getSymbolOfNode(node));
            return literalTypeToNode(type, node, tracker);
        }
        function getJsxFactoryEntity(location) {
            return location ? (getJsxNamespace(location), (ts.getSourceFileOfNode(location).localJsxFactory || _jsxFactoryEntity)) : _jsxFactoryEntity;
        }
        function getJsxFragmentFactoryEntity(location) {
            if (location) {
                var file = ts.getSourceFileOfNode(location);
                if (file) {
                    if (file.localJsxFragmentFactory) {
                        return file.localJsxFragmentFactory;
                    }
                    var jsxFragPragmas = file.pragmas.get("jsxfrag");
                    var jsxFragPragma = ts.isArray(jsxFragPragmas) ? jsxFragPragmas[0] : jsxFragPragmas;
                    if (jsxFragPragma) {
                        file.localJsxFragmentFactory = ts.parseIsolatedEntityName(jsxFragPragma.arguments.factory, languageVersion);
                        return file.localJsxFragmentFactory;
                    }
                }
            }
            if (compilerOptions.jsxFragmentFactory) {
                return ts.parseIsolatedEntityName(compilerOptions.jsxFragmentFactory, languageVersion);
            }
        }
        function createResolver() {
            var resolvedTypeReferenceDirectives = host.getResolvedTypeReferenceDirectives();
            var fileToDirective;
            if (resolvedTypeReferenceDirectives) {
                fileToDirective = new ts.Map();
                resolvedTypeReferenceDirectives.forEach(function (resolvedDirective, key, mode) {
                    if (!resolvedDirective || !resolvedDirective.resolvedFileName) {
                        return;
                    }
                    var file = host.getSourceFile(resolvedDirective.resolvedFileName);
                    if (file) {
                        addReferencedFilesToTypeDirective(file, key, mode);
                    }
                });
            }
            return {
                getReferencedExportContainer: getReferencedExportContainer,
                getReferencedImportDeclaration: getReferencedImportDeclaration,
                getReferencedDeclarationWithCollidingName: getReferencedDeclarationWithCollidingName,
                isDeclarationWithCollidingName: isDeclarationWithCollidingName,
                isValueAliasDeclaration: function (nodeIn) {
                    var node = ts.getParseTreeNode(nodeIn);
                    return node ? isValueAliasDeclaration(node) : true;
                },
                hasGlobalName: hasGlobalName,
                isReferencedAliasDeclaration: function (nodeIn, checkChildren) {
                    var node = ts.getParseTreeNode(nodeIn);
                    return node ? isReferencedAliasDeclaration(node, checkChildren) : true;
                },
                getNodeCheckFlags: function (nodeIn) {
                    var node = ts.getParseTreeNode(nodeIn);
                    return node ? getNodeCheckFlags(node) : 0;
                },
                isTopLevelValueImportEqualsWithEntityName: isTopLevelValueImportEqualsWithEntityName,
                isDeclarationVisible: isDeclarationVisible,
                isImplementationOfOverload: isImplementationOfOverload,
                isRequiredInitializedParameter: isRequiredInitializedParameter,
                isOptionalUninitializedParameterProperty: isOptionalUninitializedParameterProperty,
                isExpandoFunctionDeclaration: isExpandoFunctionDeclaration,
                getPropertiesOfContainerFunction: getPropertiesOfContainerFunction,
                createTypeOfDeclaration: createTypeOfDeclaration,
                createReturnTypeOfSignatureDeclaration: createReturnTypeOfSignatureDeclaration,
                createTypeOfExpression: createTypeOfExpression,
                createLiteralConstValue: createLiteralConstValue,
                isSymbolAccessible: isSymbolAccessible,
                isEntityNameVisible: isEntityNameVisible,
                getConstantValue: function (nodeIn) {
                    var node = ts.getParseTreeNode(nodeIn, canHaveConstantValue);
                    return node ? getConstantValue(node) : undefined;
                },
                collectLinkedAliases: collectLinkedAliases,
                getReferencedValueDeclaration: getReferencedValueDeclaration,
                getTypeReferenceSerializationKind: getTypeReferenceSerializationKind,
                isOptionalParameter: isOptionalParameter,
                moduleExportsSomeValue: moduleExportsSomeValue,
                isArgumentsLocalBinding: isArgumentsLocalBinding,
                getExternalModuleFileFromDeclaration: function (nodeIn) {
                    var node = ts.getParseTreeNode(nodeIn, ts.hasPossibleExternalModuleReference);
                    return node && getExternalModuleFileFromDeclaration(node);
                },
                getTypeReferenceDirectivesForEntityName: getTypeReferenceDirectivesForEntityName,
                getTypeReferenceDirectivesForSymbol: getTypeReferenceDirectivesForSymbol,
                isLiteralConstDeclaration: isLiteralConstDeclaration,
                isLateBound: function (nodeIn) {
                    var node = ts.getParseTreeNode(nodeIn, ts.isDeclaration);
                    var symbol = node && getSymbolOfNode(node);
                    return !!(symbol && ts.getCheckFlags(symbol) & 4096);
                },
                getJsxFactoryEntity: getJsxFactoryEntity,
                getJsxFragmentFactoryEntity: getJsxFragmentFactoryEntity,
                getAllAccessorDeclarations: function (accessor) {
                    accessor = ts.getParseTreeNode(accessor, ts.isGetOrSetAccessorDeclaration);
                    var otherKind = accessor.kind === 175 ? 174 : 175;
                    var otherAccessor = ts.getDeclarationOfKind(getSymbolOfNode(accessor), otherKind);
                    var firstAccessor = otherAccessor && (otherAccessor.pos < accessor.pos) ? otherAccessor : accessor;
                    var secondAccessor = otherAccessor && (otherAccessor.pos < accessor.pos) ? accessor : otherAccessor;
                    var setAccessor = accessor.kind === 175 ? accessor : otherAccessor;
                    var getAccessor = accessor.kind === 174 ? accessor : otherAccessor;
                    return {
                        firstAccessor: firstAccessor,
                        secondAccessor: secondAccessor,
                        setAccessor: setAccessor,
                        getAccessor: getAccessor
                    };
                },
                getSymbolOfExternalModuleSpecifier: function (moduleName) { return resolveExternalModuleNameWorker(moduleName, moduleName, undefined); },
                isBindingCapturedByNode: function (node, decl) {
                    var parseNode = ts.getParseTreeNode(node);
                    var parseDecl = ts.getParseTreeNode(decl);
                    return !!parseNode && !!parseDecl && (ts.isVariableDeclaration(parseDecl) || ts.isBindingElement(parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl);
                },
                getDeclarationStatementsForSourceFile: function (node, flags, tracker, bundled) {
                    var n = ts.getParseTreeNode(node);
                    ts.Debug.assert(n && n.kind === 308, "Non-sourcefile node passed into getDeclarationsForSourceFile");
                    var sym = getSymbolOfNode(node);
                    if (!sym) {
                        return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, tracker, bundled);
                    }
                    return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, tracker, bundled);
                },
                isImportRequiredByAugmentation: isImportRequiredByAugmentation,
            };
            function isImportRequiredByAugmentation(node) {
                var file = ts.getSourceFileOfNode(node);
                if (!file.symbol)
                    return false;
                var importTarget = getExternalModuleFileFromDeclaration(node);
                if (!importTarget)
                    return false;
                if (importTarget === file)
                    return false;
                var exports = getExportsOfModule(file.symbol);
                for (var _i = 0, _a = ts.arrayFrom(exports.values()); _i < _a.length; _i++) {
                    var s = _a[_i];
                    if (s.mergeId) {
                        var merged = getMergedSymbol(s);
                        if (merged.declarations) {
                            for (var _b = 0, _c = merged.declarations; _b < _c.length; _b++) {
                                var d = _c[_b];
                                var declFile = ts.getSourceFileOfNode(d);
                                if (declFile === importTarget) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            function isInHeritageClause(node) {
                return node.parent && node.parent.kind === 230 && node.parent.parent && node.parent.parent.kind === 294;
            }
            function getTypeReferenceDirectivesForEntityName(node) {
                if (!fileToDirective) {
                    return undefined;
                }
                var meaning;
                if (node.parent.kind === 164) {
                    meaning = 111551 | 1048576;
                }
                else {
                    meaning = 788968 | 1920;
                    if ((node.kind === 79 && isInTypeQuery(node)) || (node.kind === 208 && !isInHeritageClause(node))) {
                        meaning = 111551 | 1048576;
                    }
                }
                var symbol = resolveEntityName(node, meaning, true);
                return symbol && symbol !== unknownSymbol ? getTypeReferenceDirectivesForSymbol(symbol, meaning) : undefined;
            }
            function getTypeReferenceDirectivesForSymbol(symbol, meaning) {
                if (!fileToDirective || !isSymbolFromTypeDeclarationFile(symbol)) {
                    return undefined;
                }
                var typeReferenceDirectives;
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    if (decl.symbol && decl.symbol.flags & meaning) {
                        var file = ts.getSourceFileOfNode(decl);
                        var typeReferenceDirective = fileToDirective.get(file.path);
                        if (typeReferenceDirective) {
                            (typeReferenceDirectives || (typeReferenceDirectives = [])).push(typeReferenceDirective);
                        }
                        else {
                            return undefined;
                        }
                    }
                }
                return typeReferenceDirectives;
            }
            function isSymbolFromTypeDeclarationFile(symbol) {
                if (!symbol.declarations) {
                    return false;
                }
                var current = symbol;
                while (true) {
                    var parent = getParentOfSymbol(current);
                    if (parent) {
                        current = parent;
                    }
                    else {
                        break;
                    }
                }
                if (current.valueDeclaration && current.valueDeclaration.kind === 308 && current.flags & 512) {
                    return false;
                }
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    var file = ts.getSourceFileOfNode(decl);
                    if (fileToDirective.has(file.path)) {
                        return true;
                    }
                }
                return false;
            }
            function addReferencedFilesToTypeDirective(file, key, mode) {
                if (fileToDirective.has(file.path))
                    return;
                fileToDirective.set(file.path, [key, mode]);
                for (var _i = 0, _a = file.referencedFiles; _i < _a.length; _i++) {
                    var _b = _a[_i], fileName = _b.fileName, resolutionMode = _b.resolutionMode;
                    var resolvedFile = ts.resolveTripleslashReference(fileName, file.fileName);
                    var referencedFile = host.getSourceFile(resolvedFile);
                    if (referencedFile) {
                        addReferencedFilesToTypeDirective(referencedFile, key, resolutionMode || file.impliedNodeFormat);
                    }
                }
            }
        }
        function getExternalModuleFileFromDeclaration(declaration) {
            var specifier = declaration.kind === 264 ? ts.tryCast(declaration.name, ts.isStringLiteral) : ts.getExternalModuleName(declaration);
            var moduleSymbol = resolveExternalModuleNameWorker(specifier, specifier, undefined);
            if (!moduleSymbol) {
                return undefined;
            }
            return ts.getDeclarationOfKind(moduleSymbol, 308);
        }
        function initializeTypeChecker() {
            for (var _i = 0, _a = host.getSourceFiles(); _i < _a.length; _i++) {
                var file = _a[_i];
                ts.bindSourceFile(file, compilerOptions);
            }
            amalgamatedDuplicates = new ts.Map();
            var augmentations;
            for (var _b = 0, _c = host.getSourceFiles(); _b < _c.length; _b++) {
                var file = _c[_b];
                if (file.redirectInfo) {
                    continue;
                }
                if (!ts.isExternalOrCommonJsModule(file)) {
                    var fileGlobalThisSymbol = file.locals.get("globalThis");
                    if (fileGlobalThisSymbol === null || fileGlobalThisSymbol === void 0 ? void 0 : fileGlobalThisSymbol.declarations) {
                        for (var _d = 0, _e = fileGlobalThisSymbol.declarations; _d < _e.length; _d++) {
                            var declaration = _e[_d];
                            diagnostics.add(ts.createDiagnosticForNode(declaration, ts.Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, "globalThis"));
                        }
                    }
                    mergeSymbolTable(globals, file.locals);
                }
                if (file.jsGlobalAugmentations) {
                    mergeSymbolTable(globals, file.jsGlobalAugmentations);
                }
                if (file.patternAmbientModules && file.patternAmbientModules.length) {
                    patternAmbientModules = ts.concatenate(patternAmbientModules, file.patternAmbientModules);
                }
                if (file.moduleAugmentations.length) {
                    (augmentations || (augmentations = [])).push(file.moduleAugmentations);
                }
                if (file.symbol && file.symbol.globalExports) {
                    var source = file.symbol.globalExports;
                    source.forEach(function (sourceSymbol, id) {
                        if (!globals.has(id)) {
                            globals.set(id, sourceSymbol);
                        }
                    });
                }
            }
            if (augmentations) {
                for (var _f = 0, augmentations_1 = augmentations; _f < augmentations_1.length; _f++) {
                    var list = augmentations_1[_f];
                    for (var _g = 0, list_1 = list; _g < list_1.length; _g++) {
                        var augmentation = list_1[_g];
                        if (!ts.isGlobalScopeAugmentation(augmentation.parent))
                            continue;
                        mergeModuleAugmentation(augmentation);
                    }
                }
            }
            addToSymbolTable(globals, builtinGlobals, ts.Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0);
            getSymbolLinks(undefinedSymbol).type = undefinedWideningType;
            getSymbolLinks(argumentsSymbol).type = getGlobalType("IArguments", 0, true);
            getSymbolLinks(unknownSymbol).type = errorType;
            getSymbolLinks(globalThisSymbol).type = createObjectType(16, globalThisSymbol);
            globalArrayType = getGlobalType("Array", 1, true);
            globalObjectType = getGlobalType("Object", 0, true);
            globalFunctionType = getGlobalType("Function", 0, true);
            globalCallableFunctionType = strictBindCallApply && getGlobalType("CallableFunction", 0, true) || globalFunctionType;
            globalNewableFunctionType = strictBindCallApply && getGlobalType("NewableFunction", 0, true) || globalFunctionType;
            globalStringType = getGlobalType("String", 0, true);
            globalNumberType = getGlobalType("Number", 0, true);
            globalBooleanType = getGlobalType("Boolean", 0, true);
            globalRegExpType = getGlobalType("RegExp", 0, true);
            anyArrayType = createArrayType(anyType);
            autoArrayType = createArrayType(autoType);
            if (autoArrayType === emptyObjectType) {
                autoArrayType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            }
            globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray", 1) || globalArrayType;
            anyReadonlyArrayType = globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType;
            globalThisType = getGlobalTypeOrUndefined("ThisType", 1);
            if (augmentations) {
                for (var _h = 0, augmentations_2 = augmentations; _h < augmentations_2.length; _h++) {
                    var list = augmentations_2[_h];
                    for (var _j = 0, list_2 = list; _j < list_2.length; _j++) {
                        var augmentation = list_2[_j];
                        if (ts.isGlobalScopeAugmentation(augmentation.parent))
                            continue;
                        mergeModuleAugmentation(augmentation);
                    }
                }
            }
            amalgamatedDuplicates.forEach(function (_a) {
                var firstFile = _a.firstFile, secondFile = _a.secondFile, conflictingSymbols = _a.conflictingSymbols;
                if (conflictingSymbols.size < 8) {
                    conflictingSymbols.forEach(function (_a, symbolName) {
                        var isBlockScoped = _a.isBlockScoped, firstFileLocations = _a.firstFileLocations, secondFileLocations = _a.secondFileLocations;
                        var message = isBlockScoped ? ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0 : ts.Diagnostics.Duplicate_identifier_0;
                        for (var _i = 0, firstFileLocations_1 = firstFileLocations; _i < firstFileLocations_1.length; _i++) {
                            var node = firstFileLocations_1[_i];
                            addDuplicateDeclarationError(node, message, symbolName, secondFileLocations);
                        }
                        for (var _b = 0, secondFileLocations_1 = secondFileLocations; _b < secondFileLocations_1.length; _b++) {
                            var node = secondFileLocations_1[_b];
                            addDuplicateDeclarationError(node, message, symbolName, firstFileLocations);
                        }
                    });
                }
                else {
                    var list = ts.arrayFrom(conflictingSymbols.keys()).join(", ");
                    diagnostics.add(ts.addRelatedInfo(ts.createDiagnosticForNode(firstFile, ts.Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), ts.createDiagnosticForNode(secondFile, ts.Diagnostics.Conflicts_are_in_this_file)));
                    diagnostics.add(ts.addRelatedInfo(ts.createDiagnosticForNode(secondFile, ts.Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), ts.createDiagnosticForNode(firstFile, ts.Diagnostics.Conflicts_are_in_this_file)));
                }
            });
            amalgamatedDuplicates = undefined;
        }
        function checkExternalEmitHelpers(location, helpers) {
            if ((requestedExternalEmitHelpers & helpers) !== helpers && compilerOptions.importHelpers) {
                var sourceFile = ts.getSourceFileOfNode(location);
                if (ts.isEffectiveExternalModule(sourceFile, compilerOptions) && !(location.flags & 16777216)) {
                    var helpersModule = resolveHelpersModule(sourceFile, location);
                    if (helpersModule !== unknownSymbol) {
                        var uncheckedHelpers = helpers & ~requestedExternalEmitHelpers;
                        for (var helper = 1; helper <= 4194304; helper <<= 1) {
                            if (uncheckedHelpers & helper) {
                                var name = getHelperName(helper);
                                var symbol = getSymbol(helpersModule.exports, ts.escapeLeadingUnderscores(name), 111551);
                                if (!symbol) {
                                    error(location, ts.Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, ts.externalHelpersModuleNameText, name);
                                }
                                else if (helper & 524288) {
                                    if (!ts.some(getSignaturesOfSymbol(symbol), function (signature) { return getParameterCount(signature) > 3; })) {
                                        error(location, ts.Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, ts.externalHelpersModuleNameText, name, 4);
                                    }
                                }
                                else if (helper & 1048576) {
                                    if (!ts.some(getSignaturesOfSymbol(symbol), function (signature) { return getParameterCount(signature) > 4; })) {
                                        error(location, ts.Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, ts.externalHelpersModuleNameText, name, 5);
                                    }
                                }
                                else if (helper & 1024) {
                                    if (!ts.some(getSignaturesOfSymbol(symbol), function (signature) { return getParameterCount(signature) > 2; })) {
                                        error(location, ts.Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, ts.externalHelpersModuleNameText, name, 3);
                                    }
                                }
                            }
                        }
                    }
                    requestedExternalEmitHelpers |= helpers;
                }
            }
        }
        function getHelperName(helper) {
            switch (helper) {
                case 1: return "__extends";
                case 2: return "__assign";
                case 4: return "__rest";
                case 8: return "__decorate";
                case 16: return "__metadata";
                case 32: return "__param";
                case 64: return "__awaiter";
                case 128: return "__generator";
                case 256: return "__values";
                case 512: return "__read";
                case 1024: return "__spreadArray";
                case 2048: return "__await";
                case 4096: return "__asyncGenerator";
                case 8192: return "__asyncDelegator";
                case 16384: return "__asyncValues";
                case 32768: return "__exportStar";
                case 65536: return "__importStar";
                case 131072: return "__importDefault";
                case 262144: return "__makeTemplateObject";
                case 524288: return "__classPrivateFieldGet";
                case 1048576: return "__classPrivateFieldSet";
                case 2097152: return "__classPrivateFieldIn";
                case 4194304: return "__createBinding";
                default: return ts.Debug.fail("Unrecognized helper");
            }
        }
        function resolveHelpersModule(node, errorNode) {
            if (!externalHelpersModule) {
                externalHelpersModule = resolveExternalModule(node, ts.externalHelpersModuleNameText, ts.Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol;
            }
            return externalHelpersModule;
        }
        function checkGrammarDecoratorsAndModifiers(node) {
            return checkGrammarDecorators(node) || checkGrammarModifiers(node);
        }
        function checkGrammarDecorators(node) {
            if (ts.canHaveIllegalDecorators(node) && ts.some(node.illegalDecorators)) {
                return grammarErrorOnFirstToken(node, ts.Diagnostics.Decorators_are_not_valid_here);
            }
            if (!ts.canHaveDecorators(node) || !ts.hasDecorators(node)) {
                return false;
            }
            if (!ts.nodeCanBeDecorated(node, node.parent, node.parent.parent)) {
                if (node.kind === 171 && !ts.nodeIsPresent(node.body)) {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload);
                }
                else {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.Decorators_are_not_valid_here);
                }
            }
            else if (node.kind === 174 || node.kind === 175) {
                var accessors = ts.getAllAccessorDeclarations(node.parent.members, node);
                if (ts.hasDecorators(accessors.firstAccessor) && node === accessors.secondAccessor) {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name);
                }
            }
            return false;
        }
        function checkGrammarModifiers(node) {
            var quickResult = reportObviousModifierErrors(node);
            if (quickResult !== undefined) {
                return quickResult;
            }
            var lastStatic, lastDeclare, lastAsync, lastOverride;
            var flags = 0;
            for (var _i = 0, _a = node.modifiers; _i < _a.length; _i++) {
                var modifier = _a[_i];
                if (ts.isDecorator(modifier))
                    continue;
                if (modifier.kind !== 146) {
                    if (node.kind === 168 || node.kind === 170) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_type_member, ts.tokenToString(modifier.kind));
                    }
                    if (node.kind === 178 && (modifier.kind !== 124 || !ts.isClassLike(node.parent))) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_an_index_signature, ts.tokenToString(modifier.kind));
                    }
                }
                if (modifier.kind !== 101 && modifier.kind !== 145) {
                    if (node.kind === 165) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_type_parameter, ts.tokenToString(modifier.kind));
                    }
                }
                switch (modifier.kind) {
                    case 85:
                        if (node.kind !== 263) {
                            return grammarErrorOnNode(node, ts.Diagnostics.A_class_member_cannot_have_the_0_keyword, ts.tokenToString(85));
                        }
                        break;
                    case 161:
                        if (flags & 16384) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "override");
                        }
                        else if (flags & 2) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "override", "declare");
                        }
                        else if (flags & 64) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "override", "readonly");
                        }
                        else if (flags & 128) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "override", "accessor");
                        }
                        else if (flags & 512) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "override", "async");
                        }
                        flags |= 16384;
                        lastOverride = modifier;
                        break;
                    case 123:
                    case 122:
                    case 121:
                        var text = visibilityToString(ts.modifierToFlag(modifier.kind));
                        if (flags & 28) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & 16384) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "override");
                        }
                        else if (flags & 32) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "static");
                        }
                        else if (flags & 128) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "accessor");
                        }
                        else if (flags & 64) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly");
                        }
                        else if (flags & 512) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "async");
                        }
                        else if (node.parent.kind === 265 || node.parent.kind === 308) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text);
                        }
                        else if (flags & 256) {
                            if (modifier.kind === 121) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract");
                            }
                            else {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract");
                            }
                        }
                        else if (ts.isPrivateIdentifierClassElementDeclaration(node)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier);
                        }
                        flags |= ts.modifierToFlag(modifier.kind);
                        break;
                    case 124:
                        if (flags & 32) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "static");
                        }
                        else if (flags & 64) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly");
                        }
                        else if (flags & 512) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "static", "async");
                        }
                        else if (flags & 128) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "static", "accessor");
                        }
                        else if (node.parent.kind === 265 || node.parent.kind === 308) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static");
                        }
                        else if (node.kind === 166) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");
                        }
                        else if (flags & 256) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                        }
                        else if (flags & 16384) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "static", "override");
                        }
                        flags |= 32;
                        lastStatic = modifier;
                        break;
                    case 127:
                        if (flags & 128) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "accessor");
                        }
                        else if (flags & 64) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "readonly");
                        }
                        else if (flags & 2) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "declare");
                        }
                        else if (node.kind !== 169) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.accessor_modifier_can_only_appear_on_a_property_declaration);
                        }
                        flags |= 128;
                        break;
                    case 146:
                        if (flags & 64) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "readonly");
                        }
                        else if (node.kind !== 169 && node.kind !== 168 && node.kind !== 178 && node.kind !== 166) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature);
                        }
                        flags |= 64;
                        break;
                    case 93:
                        if (flags & 1) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "export");
                        }
                        else if (flags & 2) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");
                        }
                        else if (flags & 256) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract");
                        }
                        else if (flags & 512) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "async");
                        }
                        else if (ts.isClassLike(node.parent)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "export");
                        }
                        else if (node.kind === 166) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");
                        }
                        flags |= 1;
                        break;
                    case 88:
                        var container = node.parent.kind === 308 ? node.parent : node.parent.parent;
                        if (container.kind === 264 && !ts.isAmbientModule(container)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
                        }
                        else if (!(flags & 1)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "default");
                        }
                        flags |= 1024;
                        break;
                    case 136:
                        if (flags & 2) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "declare");
                        }
                        else if (flags & 512) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                        }
                        else if (flags & 16384) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "override");
                        }
                        else if (ts.isClassLike(node.parent) && !ts.isPropertyDeclaration(node)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "declare");
                        }
                        else if (node.kind === 166) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");
                        }
                        else if ((node.parent.flags & 16777216) && node.parent.kind === 265) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                        }
                        else if (ts.isPrivateIdentifierClassElementDeclaration(node)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "declare");
                        }
                        flags |= 2;
                        lastDeclare = modifier;
                        break;
                    case 126:
                        if (flags & 256) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "abstract");
                        }
                        if (node.kind !== 260 &&
                            node.kind !== 182) {
                            if (node.kind !== 171 &&
                                node.kind !== 169 &&
                                node.kind !== 174 &&
                                node.kind !== 175) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration);
                            }
                            if (!(node.parent.kind === 260 && ts.hasSyntacticModifier(node.parent, 256))) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class);
                            }
                            if (flags & 32) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                            }
                            if (flags & 8) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract");
                            }
                            if (flags & 512 && lastAsync) {
                                return grammarErrorOnNode(lastAsync, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");
                            }
                            if (flags & 16384) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "override");
                            }
                            if (flags & 128) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "accessor");
                            }
                        }
                        if (ts.isNamedDeclaration(node) && node.name.kind === 80) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "abstract");
                        }
                        flags |= 256;
                        break;
                    case 132:
                        if (flags & 512) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "async");
                        }
                        else if (flags & 2 || node.parent.flags & 16777216) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                        }
                        else if (node.kind === 166) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async");
                        }
                        if (flags & 256) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");
                        }
                        flags |= 512;
                        lastAsync = modifier;
                        break;
                    case 101:
                    case 145:
                        var inOutFlag = modifier.kind === 101 ? 32768 : 65536;
                        var inOutText = modifier.kind === 101 ? "in" : "out";
                        if (node.kind !== 165 || !(ts.isInterfaceDeclaration(node.parent) || ts.isClassLike(node.parent) || ts.isTypeAliasDeclaration(node.parent))) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias, inOutText);
                        }
                        if (flags & inOutFlag) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, inOutText);
                        }
                        if (inOutFlag & 32768 && flags & 65536) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "in", "out");
                        }
                        flags |= inOutFlag;
                        break;
                }
            }
            if (node.kind === 173) {
                if (flags & 32) {
                    return grammarErrorOnNode(lastStatic, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static");
                }
                if (flags & 16384) {
                    return grammarErrorOnNode(lastOverride, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "override");
                }
                if (flags & 512) {
                    return grammarErrorOnNode(lastAsync, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "async");
                }
                return false;
            }
            else if ((node.kind === 269 || node.kind === 268) && flags & 2) {
                return grammarErrorOnNode(lastDeclare, ts.Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare");
            }
            else if (node.kind === 166 && (flags & 16476) && ts.isBindingPattern(node.name)) {
                return grammarErrorOnNode(node, ts.Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern);
            }
            else if (node.kind === 166 && (flags & 16476) && node.dotDotDotToken) {
                return grammarErrorOnNode(node, ts.Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter);
            }
            if (flags & 512) {
                return checkGrammarAsyncModifier(node, lastAsync);
            }
            return false;
        }
        function reportObviousModifierErrors(node) {
            return !node.modifiers
                ? false
                : shouldReportBadModifier(node)
                    ? grammarErrorOnFirstToken(node, ts.Diagnostics.Modifiers_cannot_appear_here)
                    : undefined;
        }
        function shouldReportBadModifier(node) {
            switch (node.kind) {
                case 174:
                case 175:
                case 173:
                case 169:
                case 168:
                case 171:
                case 170:
                case 178:
                case 264:
                case 269:
                case 268:
                case 275:
                case 274:
                case 215:
                case 216:
                case 166:
                case 165:
                    return false;
                case 172:
                case 299:
                case 300:
                case 267:
                case 181:
                case 279:
                    return true;
                default:
                    if (node.parent.kind === 265 || node.parent.kind === 308) {
                        return false;
                    }
                    switch (node.kind) {
                        case 259:
                            return nodeHasAnyModifiersExcept(node, 132);
                        case 260:
                        case 182:
                            return nodeHasAnyModifiersExcept(node, 126);
                        case 228:
                        case 261:
                        case 240:
                        case 262:
                            return true;
                        case 263:
                            return nodeHasAnyModifiersExcept(node, 85);
                        default:
                            ts.Debug.assertNever(node);
                    }
            }
        }
        function nodeHasAnyModifiersExcept(node, allowedModifier) {
            for (var _i = 0, _a = node.modifiers; _i < _a.length; _i++) {
                var modifier = _a[_i];
                if (ts.isDecorator(modifier))
                    continue;
                return modifier.kind !== allowedModifier;
            }
            return false;
        }
        function checkGrammarAsyncModifier(node, asyncModifier) {
            switch (node.kind) {
                case 171:
                case 259:
                case 215:
                case 216:
                    return false;
            }
            return grammarErrorOnNode(asyncModifier, ts.Diagnostics._0_modifier_cannot_be_used_here, "async");
        }
        function checkGrammarForDisallowedTrailingComma(list, diag) {
            if (diag === void 0) { diag = ts.Diagnostics.Trailing_comma_not_allowed; }
            if (list && list.hasTrailingComma) {
                return grammarErrorAtPos(list[0], list.end - ",".length, ",".length, diag);
            }
            return false;
        }
        function checkGrammarTypeParameterList(typeParameters, file) {
            if (typeParameters && typeParameters.length === 0) {
                var start = typeParameters.pos - "<".length;
                var end = ts.skipTrivia(file.text, typeParameters.end) + ">".length;
                return grammarErrorAtPos(file, start, end - start, ts.Diagnostics.Type_parameter_list_cannot_be_empty);
            }
            return false;
        }
        function checkGrammarParameterList(parameters) {
            var seenOptionalParameter = false;
            var parameterCount = parameters.length;
            for (var i = 0; i < parameterCount; i++) {
                var parameter = parameters[i];
                if (parameter.dotDotDotToken) {
                    if (i !== (parameterCount - 1)) {
                        return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
                    }
                    if (!(parameter.flags & 16777216)) {
                        checkGrammarForDisallowedTrailingComma(parameters, ts.Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                    }
                    if (parameter.questionToken) {
                        return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.A_rest_parameter_cannot_be_optional);
                    }
                    if (parameter.initializer) {
                        return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_cannot_have_an_initializer);
                    }
                }
                else if (isOptionalParameter(parameter)) {
                    seenOptionalParameter = true;
                    if (parameter.questionToken && parameter.initializer) {
                        return grammarErrorOnNode(parameter.name, ts.Diagnostics.Parameter_cannot_have_question_mark_and_initializer);
                    }
                }
                else if (seenOptionalParameter && !parameter.initializer) {
                    return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);
                }
            }
        }
        function getNonSimpleParameters(parameters) {
            return ts.filter(parameters, function (parameter) { return !!parameter.initializer || ts.isBindingPattern(parameter.name) || ts.isRestParameter(parameter); });
        }
        function checkGrammarForUseStrictSimpleParameterList(node) {
            if (languageVersion >= 3) {
                var useStrictDirective_1 = node.body && ts.isBlock(node.body) && ts.findUseStrictPrologue(node.body.statements);
                if (useStrictDirective_1) {
                    var nonSimpleParameters = getNonSimpleParameters(node.parameters);
                    if (ts.length(nonSimpleParameters)) {
                        ts.forEach(nonSimpleParameters, function (parameter) {
                            ts.addRelatedInfo(error(parameter, ts.Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive), ts.createDiagnosticForNode(useStrictDirective_1, ts.Diagnostics.use_strict_directive_used_here));
                        });
                        var diagnostics_2 = nonSimpleParameters.map(function (parameter, index) { return (index === 0 ? ts.createDiagnosticForNode(parameter, ts.Diagnostics.Non_simple_parameter_declared_here) : ts.createDiagnosticForNode(parameter, ts.Diagnostics.and_here)); });
                        ts.addRelatedInfo.apply(void 0, __spreadArray([error(useStrictDirective_1, ts.Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list)], diagnostics_2, false));
                        return true;
                    }
                }
            }
            return false;
        }
        function checkGrammarFunctionLikeDeclaration(node) {
            var file = ts.getSourceFileOfNode(node);
            return checkGrammarDecoratorsAndModifiers(node) ||
                checkGrammarTypeParameterList(node.typeParameters, file) ||
                checkGrammarParameterList(node.parameters) ||
                checkGrammarArrowFunction(node, file) ||
                (ts.isFunctionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(node));
        }
        function checkGrammarClassLikeDeclaration(node) {
            var file = ts.getSourceFileOfNode(node);
            return checkGrammarClassDeclarationHeritageClauses(node) ||
                checkGrammarTypeParameterList(node.typeParameters, file);
        }
        function checkGrammarArrowFunction(node, file) {
            if (!ts.isArrowFunction(node)) {
                return false;
            }
            if (node.typeParameters && !(ts.length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || node.typeParameters[0].constraint)) {
                if (file && ts.fileExtensionIsOneOf(file.fileName, [".mts", ".cts"])) {
                    grammarErrorOnNode(node.typeParameters[0], ts.Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint);
                }
            }
            var equalsGreaterThanToken = node.equalsGreaterThanToken;
            var startLine = ts.getLineAndCharacterOfPosition(file, equalsGreaterThanToken.pos).line;
            var endLine = ts.getLineAndCharacterOfPosition(file, equalsGreaterThanToken.end).line;
            return startLine !== endLine && grammarErrorOnNode(equalsGreaterThanToken, ts.Diagnostics.Line_terminator_not_permitted_before_arrow);
        }
        function checkGrammarIndexSignatureParameters(node) {
            var parameter = node.parameters[0];
            if (node.parameters.length !== 1) {
                if (parameter) {
                    return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter);
                }
                else {
                    return grammarErrorOnNode(node, ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter);
                }
            }
            checkGrammarForDisallowedTrailingComma(node.parameters, ts.Diagnostics.An_index_signature_cannot_have_a_trailing_comma);
            if (parameter.dotDotDotToken) {
                return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.An_index_signature_cannot_have_a_rest_parameter);
            }
            if (ts.hasEffectiveModifiers(parameter)) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
            }
            if (parameter.questionToken) {
                return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);
            }
            if (parameter.initializer) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);
            }
            if (!parameter.type) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);
            }
            var type = getTypeFromTypeNode(parameter.type);
            if (someType(type, function (t) { return !!(t.flags & 8576); }) || isGenericType(type)) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead);
            }
            if (!everyType(type, isValidIndexKeyType)) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type);
            }
            if (!node.type) {
                return grammarErrorOnNode(node, ts.Diagnostics.An_index_signature_must_have_a_type_annotation);
            }
            return false;
        }
        function checkGrammarIndexSignature(node) {
            return checkGrammarDecoratorsAndModifiers(node) || checkGrammarIndexSignatureParameters(node);
        }
        function checkGrammarForAtLeastOneTypeArgument(node, typeArguments) {
            if (typeArguments && typeArguments.length === 0) {
                var sourceFile = ts.getSourceFileOfNode(node);
                var start = typeArguments.pos - "<".length;
                var end = ts.skipTrivia(sourceFile.text, typeArguments.end) + ">".length;
                return grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.Type_argument_list_cannot_be_empty);
            }
            return false;
        }
        function checkGrammarTypeArguments(node, typeArguments) {
            return checkGrammarForDisallowedTrailingComma(typeArguments) ||
                checkGrammarForAtLeastOneTypeArgument(node, typeArguments);
        }
        function checkGrammarTaggedTemplateChain(node) {
            if (node.questionDotToken || node.flags & 32) {
                return grammarErrorOnNode(node.template, ts.Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain);
            }
            return false;
        }
        function checkGrammarHeritageClause(node) {
            var types = node.types;
            if (checkGrammarForDisallowedTrailingComma(types)) {
                return true;
            }
            if (types && types.length === 0) {
                var listType = ts.tokenToString(node.token);
                return grammarErrorAtPos(node, types.pos, 0, ts.Diagnostics._0_list_cannot_be_empty, listType);
            }
            return ts.some(types, checkGrammarExpressionWithTypeArguments);
        }
        function checkGrammarExpressionWithTypeArguments(node) {
            if (ts.isExpressionWithTypeArguments(node) && ts.isImportKeyword(node.expression) && node.typeArguments) {
                return grammarErrorOnNode(node, ts.Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments);
            }
            return checkGrammarTypeArguments(node, node.typeArguments);
        }
        function checkGrammarClassDeclarationHeritageClauses(node) {
            var seenExtendsClause = false;
            var seenImplementsClause = false;
            if (!checkGrammarDecoratorsAndModifiers(node) && node.heritageClauses) {
                for (var _i = 0, _a = node.heritageClauses; _i < _a.length; _i++) {
                    var heritageClause = _a[_i];
                    if (heritageClause.token === 94) {
                        if (seenExtendsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_already_seen);
                        }
                        if (seenImplementsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_must_precede_implements_clause);
                        }
                        if (heritageClause.types.length > 1) {
                            return grammarErrorOnFirstToken(heritageClause.types[1], ts.Diagnostics.Classes_can_only_extend_a_single_class);
                        }
                        seenExtendsClause = true;
                    }
                    else {
                        ts.Debug.assert(heritageClause.token === 117);
                        if (seenImplementsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.implements_clause_already_seen);
                        }
                        seenImplementsClause = true;
                    }
                    checkGrammarHeritageClause(heritageClause);
                }
            }
        }
        function checkGrammarInterfaceDeclaration(node) {
            var seenExtendsClause = false;
            if (node.heritageClauses) {
                for (var _i = 0, _a = node.heritageClauses; _i < _a.length; _i++) {
                    var heritageClause = _a[_i];
                    if (heritageClause.token === 94) {
                        if (seenExtendsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_already_seen);
                        }
                        seenExtendsClause = true;
                    }
                    else {
                        ts.Debug.assert(heritageClause.token === 117);
                        return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.Interface_declaration_cannot_have_implements_clause);
                    }
                    checkGrammarHeritageClause(heritageClause);
                }
            }
            return false;
        }
        function checkGrammarComputedPropertyName(node) {
            if (node.kind !== 164) {
                return false;
            }
            var computedPropertyName = node;
            if (computedPropertyName.expression.kind === 223 && computedPropertyName.expression.operatorToken.kind === 27) {
                return grammarErrorOnNode(computedPropertyName.expression, ts.Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name);
            }
            return false;
        }
        function checkGrammarForGenerator(node) {
            if (node.asteriskToken) {
                ts.Debug.assert(node.kind === 259 ||
                    node.kind === 215 ||
                    node.kind === 171);
                if (node.flags & 16777216) {
                    return grammarErrorOnNode(node.asteriskToken, ts.Diagnostics.Generators_are_not_allowed_in_an_ambient_context);
                }
                if (!node.body) {
                    return grammarErrorOnNode(node.asteriskToken, ts.Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator);
                }
            }
        }
        function checkGrammarForInvalidQuestionMark(questionToken, message) {
            return !!questionToken && grammarErrorOnNode(questionToken, message);
        }
        function checkGrammarForInvalidExclamationToken(exclamationToken, message) {
            return !!exclamationToken && grammarErrorOnNode(exclamationToken, message);
        }
        function checkGrammarObjectLiteralExpression(node, inDestructuring) {
            var seen = new ts.Map();
            for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
                var prop = _a[_i];
                if (prop.kind === 301) {
                    if (inDestructuring) {
                        var expression = ts.skipParentheses(prop.expression);
                        if (ts.isArrayLiteralExpression(expression) || ts.isObjectLiteralExpression(expression)) {
                            return grammarErrorOnNode(prop.expression, ts.Diagnostics.A_rest_element_cannot_contain_a_binding_pattern);
                        }
                    }
                    continue;
                }
                var name = prop.name;
                if (name.kind === 164) {
                    checkGrammarComputedPropertyName(name);
                }
                if (prop.kind === 300 && !inDestructuring && prop.objectAssignmentInitializer) {
                    grammarErrorOnNode(prop.equalsToken, ts.Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern);
                }
                if (name.kind === 80) {
                    grammarErrorOnNode(name, ts.Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
                }
                if (ts.canHaveModifiers(prop) && prop.modifiers) {
                    for (var _b = 0, _c = prop.modifiers; _b < _c.length; _b++) {
                        var mod = _c[_b];
                        if (ts.isModifier(mod) && (mod.kind !== 132 || prop.kind !== 171)) {
                            grammarErrorOnNode(mod, ts.Diagnostics._0_modifier_cannot_be_used_here, ts.getTextOfNode(mod));
                        }
                    }
                }
                else if (ts.canHaveIllegalModifiers(prop) && prop.modifiers) {
                    for (var _d = 0, _e = prop.modifiers; _d < _e.length; _d++) {
                        var mod = _e[_d];
                        grammarErrorOnNode(mod, ts.Diagnostics._0_modifier_cannot_be_used_here, ts.getTextOfNode(mod));
                    }
                }
                var currentKind = void 0;
                switch (prop.kind) {
                    case 300:
                    case 299:
                        checkGrammarForInvalidExclamationToken(prop.exclamationToken, ts.Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context);
                        checkGrammarForInvalidQuestionMark(prop.questionToken, ts.Diagnostics.An_object_member_cannot_be_declared_optional);
                        if (name.kind === 8) {
                            checkGrammarNumericLiteral(name);
                        }
                        currentKind = 4;
                        break;
                    case 171:
                        currentKind = 8;
                        break;
                    case 174:
                        currentKind = 1;
                        break;
                    case 175:
                        currentKind = 2;
                        break;
                    default:
                        throw ts.Debug.assertNever(prop, "Unexpected syntax kind:" + prop.kind);
                }
                if (!inDestructuring) {
                    var effectiveName = ts.getPropertyNameForPropertyNameNode(name);
                    if (effectiveName === undefined) {
                        continue;
                    }
                    var existingKind = seen.get(effectiveName);
                    if (!existingKind) {
                        seen.set(effectiveName, currentKind);
                    }
                    else {
                        if ((currentKind & 8) && (existingKind & 8)) {
                            grammarErrorOnNode(name, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(name));
                        }
                        else if ((currentKind & 4) && (existingKind & 4)) {
                            grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name, ts.getTextOfNode(name));
                        }
                        else if ((currentKind & 3) && (existingKind & 3)) {
                            if (existingKind !== 3 && currentKind !== existingKind) {
                                seen.set(effectiveName, currentKind | existingKind);
                            }
                            else {
                                return grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);
                            }
                        }
                        else {
                            return grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);
                        }
                    }
                }
            }
        }
        function checkGrammarJsxElement(node) {
            checkGrammarJsxName(node.tagName);
            checkGrammarTypeArguments(node, node.typeArguments);
            var seen = new ts.Map();
            for (var _i = 0, _a = node.attributes.properties; _i < _a.length; _i++) {
                var attr = _a[_i];
                if (attr.kind === 290) {
                    continue;
                }
                var name = attr.name, initializer = attr.initializer;
                if (!seen.get(name.escapedText)) {
                    seen.set(name.escapedText, true);
                }
                else {
                    return grammarErrorOnNode(name, ts.Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name);
                }
                if (initializer && initializer.kind === 291 && !initializer.expression) {
                    return grammarErrorOnNode(initializer, ts.Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression);
                }
            }
        }
        function checkGrammarJsxName(node) {
            if (ts.isPropertyAccessExpression(node)) {
                var propName = node;
                do {
                    var check_1 = checkGrammarJsxNestedIdentifier(propName.name);
                    if (check_1) {
                        return check_1;
                    }
                    propName = propName.expression;
                } while (ts.isPropertyAccessExpression(propName));
                var check = checkGrammarJsxNestedIdentifier(propName);
                if (check) {
                    return check;
                }
            }
            function checkGrammarJsxNestedIdentifier(name) {
                if (ts.isIdentifier(name) && ts.idText(name).indexOf(":") !== -1) {
                    return grammarErrorOnNode(name, ts.Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names);
                }
            }
        }
        function checkGrammarJsxExpression(node) {
            if (node.expression && ts.isCommaSequence(node.expression)) {
                return grammarErrorOnNode(node.expression, ts.Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array);
            }
        }
        function checkGrammarForInOrForOfStatement(forInOrOfStatement) {
            if (checkGrammarStatementInAmbientContext(forInOrOfStatement)) {
                return true;
            }
            if (forInOrOfStatement.kind === 247 && forInOrOfStatement.awaitModifier) {
                if (!(forInOrOfStatement.flags & 32768)) {
                    var sourceFile = ts.getSourceFileOfNode(forInOrOfStatement);
                    if (ts.isInTopLevelContext(forInOrOfStatement)) {
                        if (!hasParseDiagnostics(sourceFile)) {
                            if (!ts.isEffectiveExternalModule(sourceFile, compilerOptions)) {
                                diagnostics.add(ts.createDiagnosticForNode(forInOrOfStatement.awaitModifier, ts.Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module));
                            }
                            switch (moduleKind) {
                                case ts.ModuleKind.Node16:
                                case ts.ModuleKind.NodeNext:
                                    if (sourceFile.impliedNodeFormat === ts.ModuleKind.CommonJS) {
                                        diagnostics.add(ts.createDiagnosticForNode(forInOrOfStatement.awaitModifier, ts.Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level));
                                        break;
                                    }
                                case ts.ModuleKind.ES2022:
                                case ts.ModuleKind.ESNext:
                                case ts.ModuleKind.System:
                                    if (languageVersion >= 4) {
                                        break;
                                    }
                                default:
                                    diagnostics.add(ts.createDiagnosticForNode(forInOrOfStatement.awaitModifier, ts.Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher));
                                    break;
                            }
                        }
                    }
                    else {
                        if (!hasParseDiagnostics(sourceFile)) {
                            var diagnostic = ts.createDiagnosticForNode(forInOrOfStatement.awaitModifier, ts.Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules);
                            var func = ts.getContainingFunction(forInOrOfStatement);
                            if (func && func.kind !== 173) {
                                ts.Debug.assert((ts.getFunctionFlags(func) & 2) === 0, "Enclosing function should never be an async function.");
                                var relatedInfo = ts.createDiagnosticForNode(func, ts.Diagnostics.Did_you_mean_to_mark_this_function_as_async);
                                ts.addRelatedInfo(diagnostic, relatedInfo);
                            }
                            diagnostics.add(diagnostic);
                            return true;
                        }
                    }
                    return false;
                }
            }
            if (ts.isForOfStatement(forInOrOfStatement) && !(forInOrOfStatement.flags & 32768) &&
                ts.isIdentifier(forInOrOfStatement.initializer) && forInOrOfStatement.initializer.escapedText === "async") {
                grammarErrorOnNode(forInOrOfStatement.initializer, ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async);
                return false;
            }
            if (forInOrOfStatement.initializer.kind === 258) {
                var variableList = forInOrOfStatement.initializer;
                if (!checkGrammarVariableDeclarationList(variableList)) {
                    var declarations = variableList.declarations;
                    if (!declarations.length) {
                        return false;
                    }
                    if (declarations.length > 1) {
                        var diagnostic = forInOrOfStatement.kind === 246
                            ? ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement
                            : ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement;
                        return grammarErrorOnFirstToken(variableList.declarations[1], diagnostic);
                    }
                    var firstDeclaration = declarations[0];
                    if (firstDeclaration.initializer) {
                        var diagnostic = forInOrOfStatement.kind === 246
                            ? ts.Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer
                            : ts.Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer;
                        return grammarErrorOnNode(firstDeclaration.name, diagnostic);
                    }
                    if (firstDeclaration.type) {
                        var diagnostic = forInOrOfStatement.kind === 246
                            ? ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation
                            : ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation;
                        return grammarErrorOnNode(firstDeclaration, diagnostic);
                    }
                }
            }
            return false;
        }
        function checkGrammarAccessor(accessor) {
            if (!(accessor.flags & 16777216) && (accessor.parent.kind !== 184) && (accessor.parent.kind !== 261)) {
                if (languageVersion < 1) {
                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher);
                }
                if (languageVersion < 2 && ts.isPrivateIdentifier(accessor.name)) {
                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
                }
                if (accessor.body === undefined && !ts.hasSyntacticModifier(accessor, 256)) {
                    return grammarErrorAtPos(accessor, accessor.end - 1, ";".length, ts.Diagnostics._0_expected, "{");
                }
            }
            if (accessor.body) {
                if (ts.hasSyntacticModifier(accessor, 256)) {
                    return grammarErrorOnNode(accessor, ts.Diagnostics.An_abstract_accessor_cannot_have_an_implementation);
                }
                if (accessor.parent.kind === 184 || accessor.parent.kind === 261) {
                    return grammarErrorOnNode(accessor.body, ts.Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts);
                }
            }
            if (accessor.typeParameters) {
                return grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_have_type_parameters);
            }
            if (!doesAccessorHaveCorrectParameterCount(accessor)) {
                return grammarErrorOnNode(accessor.name, accessor.kind === 174 ?
                    ts.Diagnostics.A_get_accessor_cannot_have_parameters :
                    ts.Diagnostics.A_set_accessor_must_have_exactly_one_parameter);
            }
            if (accessor.kind === 175) {
                if (accessor.type) {
                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation);
                }
                var parameter = ts.Debug.checkDefined(ts.getSetAccessorValueParameter(accessor), "Return value does not match parameter count assertion.");
                if (parameter.dotDotDotToken) {
                    return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.A_set_accessor_cannot_have_rest_parameter);
                }
                if (parameter.questionToken) {
                    return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.A_set_accessor_cannot_have_an_optional_parameter);
                }
                if (parameter.initializer) {
                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer);
                }
            }
            return false;
        }
        function doesAccessorHaveCorrectParameterCount(accessor) {
            return getAccessorThisParameter(accessor) || accessor.parameters.length === (accessor.kind === 174 ? 0 : 1);
        }
        function getAccessorThisParameter(accessor) {
            if (accessor.parameters.length === (accessor.kind === 174 ? 1 : 2)) {
                return ts.getThisParameter(accessor);
            }
        }
        function checkGrammarTypeOperatorNode(node) {
            if (node.operator === 156) {
                if (node.type.kind !== 153) {
                    return grammarErrorOnNode(node.type, ts.Diagnostics._0_expected, ts.tokenToString(153));
                }
                var parent = ts.walkUpParenthesizedTypes(node.parent);
                if (ts.isInJSFile(parent) && ts.isJSDocTypeExpression(parent)) {
                    var host_2 = ts.getJSDocHost(parent);
                    if (host_2) {
                        parent = ts.getSingleVariableOfVariableStatement(host_2) || host_2;
                    }
                }
                switch (parent.kind) {
                    case 257:
                        var decl = parent;
                        if (decl.name.kind !== 79) {
                            return grammarErrorOnNode(node, ts.Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name);
                        }
                        if (!ts.isVariableDeclarationInVariableStatement(decl)) {
                            return grammarErrorOnNode(node, ts.Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement);
                        }
                        if (!(decl.parent.flags & 2)) {
                            return grammarErrorOnNode(parent.name, ts.Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const);
                        }
                        break;
                    case 169:
                        if (!ts.isStatic(parent) ||
                            !ts.hasEffectiveReadonlyModifier(parent)) {
                            return grammarErrorOnNode(parent.name, ts.Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly);
                        }
                        break;
                    case 168:
                        if (!ts.hasSyntacticModifier(parent, 64)) {
                            return grammarErrorOnNode(parent.name, ts.Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly);
                        }
                        break;
                    default:
                        return grammarErrorOnNode(node, ts.Diagnostics.unique_symbol_types_are_not_allowed_here);
                }
            }
            else if (node.operator === 146) {
                if (node.type.kind !== 185 && node.type.kind !== 186) {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types, ts.tokenToString(153));
                }
            }
        }
        function checkGrammarForInvalidDynamicName(node, message) {
            if (isNonBindableDynamicName(node)) {
                return grammarErrorOnNode(node, message);
            }
        }
        function checkGrammarMethod(node) {
            if (checkGrammarFunctionLikeDeclaration(node)) {
                return true;
            }
            if (node.kind === 171) {
                if (node.parent.kind === 207) {
                    if (node.modifiers && !(node.modifiers.length === 1 && ts.first(node.modifiers).kind === 132)) {
                        return grammarErrorOnFirstToken(node, ts.Diagnostics.Modifiers_cannot_appear_here);
                    }
                    else if (checkGrammarForInvalidQuestionMark(node.questionToken, ts.Diagnostics.An_object_member_cannot_be_declared_optional)) {
                        return true;
                    }
                    else if (checkGrammarForInvalidExclamationToken(node.exclamationToken, ts.Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context)) {
                        return true;
                    }
                    else if (node.body === undefined) {
                        return grammarErrorAtPos(node, node.end - 1, ";".length, ts.Diagnostics._0_expected, "{");
                    }
                }
                if (checkGrammarForGenerator(node)) {
                    return true;
                }
            }
            if (ts.isClassLike(node.parent)) {
                if (languageVersion < 2 && ts.isPrivateIdentifier(node.name)) {
                    return grammarErrorOnNode(node.name, ts.Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
                }
                if (node.flags & 16777216) {
                    return checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
                }
                else if (node.kind === 171 && !node.body) {
                    return checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
                }
            }
            else if (node.parent.kind === 261) {
                return checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
            }
            else if (node.parent.kind === 184) {
                return checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
            }
        }
        function checkGrammarBreakOrContinueStatement(node) {
            var current = node;
            while (current) {
                if (ts.isFunctionLikeOrClassStaticBlockDeclaration(current)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.Jump_target_cannot_cross_function_boundary);
                }
                switch (current.kind) {
                    case 253:
                        if (node.label && current.label.escapedText === node.label.escapedText) {
                            var isMisplacedContinueLabel = node.kind === 248
                                && !ts.isIterationStatement(current.statement, true);
                            if (isMisplacedContinueLabel) {
                                return grammarErrorOnNode(node, ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
                            }
                            return false;
                        }
                        break;
                    case 252:
                        if (node.kind === 249 && !node.label) {
                            return false;
                        }
                        break;
                    default:
                        if (ts.isIterationStatement(current, false) && !node.label) {
                            return false;
                        }
                        break;
                }
                current = current.parent;
            }
            if (node.label) {
                var message = node.kind === 249
                    ? ts.Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement
                    : ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;
                return grammarErrorOnNode(node, message);
            }
            else {
                var message = node.kind === 249
                    ? ts.Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement
                    : ts.Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;
                return grammarErrorOnNode(node, message);
            }
        }
        function checkGrammarBindingElement(node) {
            if (node.dotDotDotToken) {
                var elements = node.parent.elements;
                if (node !== ts.last(elements)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
                }
                checkGrammarForDisallowedTrailingComma(elements, ts.Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                if (node.propertyName) {
                    return grammarErrorOnNode(node.name, ts.Diagnostics.A_rest_element_cannot_have_a_property_name);
                }
            }
            if (node.dotDotDotToken && node.initializer) {
                return grammarErrorAtPos(node, node.initializer.pos - 1, 1, ts.Diagnostics.A_rest_element_cannot_have_an_initializer);
            }
        }
        function isStringOrNumberLiteralExpression(expr) {
            return ts.isStringOrNumericLiteralLike(expr) ||
                expr.kind === 221 && expr.operator === 40 &&
                    expr.operand.kind === 8;
        }
        function isBigIntLiteralExpression(expr) {
            return expr.kind === 9 ||
                expr.kind === 221 && expr.operator === 40 &&
                    expr.operand.kind === 9;
        }
        function isSimpleLiteralEnumReference(expr) {
            if ((ts.isPropertyAccessExpression(expr) || (ts.isElementAccessExpression(expr) && isStringOrNumberLiteralExpression(expr.argumentExpression))) &&
                ts.isEntityNameExpression(expr.expression)) {
                return !!(checkExpressionCached(expr).flags & 1024);
            }
        }
        function checkAmbientInitializer(node) {
            var initializer = node.initializer;
            if (initializer) {
                var isInvalidInitializer = !(isStringOrNumberLiteralExpression(initializer) ||
                    isSimpleLiteralEnumReference(initializer) ||
                    initializer.kind === 110 || initializer.kind === 95 ||
                    isBigIntLiteralExpression(initializer));
                var isConstOrReadonly = ts.isDeclarationReadonly(node) || ts.isVariableDeclaration(node) && ts.isVarConst(node);
                if (isConstOrReadonly && !node.type) {
                    if (isInvalidInitializer) {
                        return grammarErrorOnNode(initializer, ts.Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference);
                    }
                }
                else {
                    return grammarErrorOnNode(initializer, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
                }
            }
        }
        function checkGrammarVariableDeclaration(node) {
            if (node.parent.parent.kind !== 246 && node.parent.parent.kind !== 247) {
                if (node.flags & 16777216) {
                    checkAmbientInitializer(node);
                }
                else if (!node.initializer) {
                    if (ts.isBindingPattern(node.name) && !ts.isBindingPattern(node.parent)) {
                        return grammarErrorOnNode(node, ts.Diagnostics.A_destructuring_declaration_must_have_an_initializer);
                    }
                    if (ts.isVarConst(node)) {
                        return grammarErrorOnNode(node, ts.Diagnostics.const_declarations_must_be_initialized);
                    }
                }
            }
            if (node.exclamationToken && (node.parent.parent.kind !== 240 || !node.type || node.initializer || node.flags & 16777216)) {
                var message = node.initializer
                    ? ts.Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions
                    : !node.type
                        ? ts.Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations
                        : ts.Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context;
                return grammarErrorOnNode(node.exclamationToken, message);
            }
            if ((moduleKind < ts.ModuleKind.ES2015 || ts.getSourceFileOfNode(node).impliedNodeFormat === ts.ModuleKind.CommonJS) && moduleKind !== ts.ModuleKind.System &&
                !(node.parent.parent.flags & 16777216) && ts.hasSyntacticModifier(node.parent.parent, 1)) {
                checkESModuleMarker(node.name);
            }
            var checkLetConstNames = (ts.isLet(node) || ts.isVarConst(node));
            return checkLetConstNames && checkGrammarNameInLetOrConstDeclarations(node.name);
        }
        function checkESModuleMarker(name) {
            if (name.kind === 79) {
                if (ts.idText(name) === "__esModule") {
                    return grammarErrorOnNodeSkippedOn("noEmit", name, ts.Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules);
                }
            }
            else {
                var elements = name.elements;
                for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
                    var element = elements_2[_i];
                    if (!ts.isOmittedExpression(element)) {
                        return checkESModuleMarker(element.name);
                    }
                }
            }
            return false;
        }
        function checkGrammarNameInLetOrConstDeclarations(name) {
            if (name.kind === 79) {
                if (name.originalKeywordKind === 119) {
                    return grammarErrorOnNode(name, ts.Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations);
                }
            }
            else {
                var elements = name.elements;
                for (var _i = 0, elements_3 = elements; _i < elements_3.length; _i++) {
                    var element = elements_3[_i];
                    if (!ts.isOmittedExpression(element)) {
                        checkGrammarNameInLetOrConstDeclarations(element.name);
                    }
                }
            }
            return false;
        }
        function checkGrammarVariableDeclarationList(declarationList) {
            var declarations = declarationList.declarations;
            if (checkGrammarForDisallowedTrailingComma(declarationList.declarations)) {
                return true;
            }
            if (!declarationList.declarations.length) {
                return grammarErrorAtPos(declarationList, declarations.pos, declarations.end - declarations.pos, ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
            }
            return false;
        }
        function allowLetAndConstDeclarations(parent) {
            switch (parent.kind) {
                case 242:
                case 243:
                case 244:
                case 251:
                case 245:
                case 246:
                case 247:
                    return false;
                case 253:
                    return allowLetAndConstDeclarations(parent.parent);
            }
            return true;
        }
        function checkGrammarForDisallowedLetOrConstStatement(node) {
            if (!allowLetAndConstDeclarations(node.parent)) {
                if (ts.isLet(node.declarationList)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.let_declarations_can_only_be_declared_inside_a_block);
                }
                else if (ts.isVarConst(node.declarationList)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.const_declarations_can_only_be_declared_inside_a_block);
                }
            }
        }
        function checkGrammarMetaProperty(node) {
            var escapedText = node.name.escapedText;
            switch (node.keywordToken) {
                case 103:
                    if (escapedText !== "target") {
                        return grammarErrorOnNode(node.name, ts.Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, node.name.escapedText, ts.tokenToString(node.keywordToken), "target");
                    }
                    break;
                case 100:
                    if (escapedText !== "meta") {
                        return grammarErrorOnNode(node.name, ts.Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, node.name.escapedText, ts.tokenToString(node.keywordToken), "meta");
                    }
                    break;
            }
        }
        function hasParseDiagnostics(sourceFile) {
            return sourceFile.parseDiagnostics.length > 0;
        }
        function grammarErrorOnFirstToken(node, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                var span = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                diagnostics.add(ts.createFileDiagnostic(sourceFile, span.start, span.length, message, arg0, arg1, arg2));
                return true;
            }
            return false;
        }
        function grammarErrorAtPos(nodeForSourceFile, start, length, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(nodeForSourceFile);
            if (!hasParseDiagnostics(sourceFile)) {
                diagnostics.add(ts.createFileDiagnostic(sourceFile, start, length, message, arg0, arg1, arg2));
                return true;
            }
            return false;
        }
        function grammarErrorOnNodeSkippedOn(key, node, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                errorSkippedOn(key, node, message, arg0, arg1, arg2);
                return true;
            }
            return false;
        }
        function grammarErrorOnNode(node, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                diagnostics.add(ts.createDiagnosticForNode(node, message, arg0, arg1, arg2));
                return true;
            }
            return false;
        }
        function checkGrammarConstructorTypeParameters(node) {
            var jsdocTypeParameters = ts.isInJSFile(node) ? ts.getJSDocTypeParameterDeclarations(node) : undefined;
            var range = node.typeParameters || jsdocTypeParameters && ts.firstOrUndefined(jsdocTypeParameters);
            if (range) {
                var pos = range.pos === range.end ? range.pos : ts.skipTrivia(ts.getSourceFileOfNode(node).text, range.pos);
                return grammarErrorAtPos(node, pos, range.end - pos, ts.Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration);
            }
        }
        function checkGrammarConstructorTypeAnnotation(node) {
            var type = node.type || ts.getEffectiveReturnTypeNode(node);
            if (type) {
                return grammarErrorOnNode(type, ts.Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration);
            }
        }
        function checkGrammarProperty(node) {
            if (ts.isComputedPropertyName(node.name) && ts.isBinaryExpression(node.name.expression) && node.name.expression.operatorToken.kind === 101) {
                return grammarErrorOnNode(node.parent.members[0], ts.Diagnostics.A_mapped_type_may_not_declare_properties_or_methods);
            }
            if (ts.isClassLike(node.parent)) {
                if (ts.isStringLiteral(node.name) && node.name.text === "constructor") {
                    return grammarErrorOnNode(node.name, ts.Diagnostics.Classes_may_not_have_a_field_named_constructor);
                }
                if (checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type)) {
                    return true;
                }
                if (languageVersion < 2 && ts.isPrivateIdentifier(node.name)) {
                    return grammarErrorOnNode(node.name, ts.Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
                }
                if (languageVersion < 2 && ts.isAutoAccessorPropertyDeclaration(node)) {
                    return grammarErrorOnNode(node.name, ts.Diagnostics.Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher);
                }
                if (ts.isAutoAccessorPropertyDeclaration(node) && checkGrammarForInvalidQuestionMark(node.questionToken, ts.Diagnostics.An_accessor_property_cannot_be_declared_optional)) {
                    return true;
                }
            }
            else if (node.parent.kind === 261) {
                if (checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)) {
                    return true;
                }
                ts.Debug.assertNode(node, ts.isPropertySignature);
                if (node.initializer) {
                    return grammarErrorOnNode(node.initializer, ts.Diagnostics.An_interface_property_cannot_have_an_initializer);
                }
            }
            else if (ts.isTypeLiteralNode(node.parent)) {
                if (checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)) {
                    return true;
                }
                ts.Debug.assertNode(node, ts.isPropertySignature);
                if (node.initializer) {
                    return grammarErrorOnNode(node.initializer, ts.Diagnostics.A_type_literal_property_cannot_have_an_initializer);
                }
            }
            if (node.flags & 16777216) {
                checkAmbientInitializer(node);
            }
            if (ts.isPropertyDeclaration(node) && node.exclamationToken && (!ts.isClassLike(node.parent) || !node.type || node.initializer ||
                node.flags & 16777216 || ts.isStatic(node) || ts.hasAbstractModifier(node))) {
                var message = node.initializer
                    ? ts.Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions
                    : !node.type
                        ? ts.Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations
                        : ts.Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context;
                return grammarErrorOnNode(node.exclamationToken, message);
            }
        }
        function checkGrammarTopLevelElementForRequiredDeclareModifier(node) {
            if (node.kind === 261 ||
                node.kind === 262 ||
                node.kind === 269 ||
                node.kind === 268 ||
                node.kind === 275 ||
                node.kind === 274 ||
                node.kind === 267 ||
                ts.hasSyntacticModifier(node, 2 | 1 | 1024)) {
                return false;
            }
            return grammarErrorOnFirstToken(node, ts.Diagnostics.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier);
        }
        function checkGrammarTopLevelElementsForRequiredDeclareModifier(file) {
            for (var _i = 0, _a = file.statements; _i < _a.length; _i++) {
                var decl = _a[_i];
                if (ts.isDeclaration(decl) || decl.kind === 240) {
                    if (checkGrammarTopLevelElementForRequiredDeclareModifier(decl)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function checkGrammarSourceFile(node) {
            return !!(node.flags & 16777216) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node);
        }
        function checkGrammarStatementInAmbientContext(node) {
            if (node.flags & 16777216) {
                var links = getNodeLinks(node);
                if (!links.hasReportedStatementInAmbientContext && (ts.isFunctionLike(node.parent) || ts.isAccessor(node.parent))) {
                    return getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, ts.Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts);
                }
                if (node.parent.kind === 238 || node.parent.kind === 265 || node.parent.kind === 308) {
                    var links_2 = getNodeLinks(node.parent);
                    if (!links_2.hasReportedStatementInAmbientContext) {
                        return links_2.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, ts.Diagnostics.Statements_are_not_allowed_in_ambient_contexts);
                    }
                }
                else {
                }
            }
            return false;
        }
        function checkGrammarNumericLiteral(node) {
            if (node.numericLiteralFlags & 32) {
                var diagnosticMessage = void 0;
                if (languageVersion >= 1) {
                    diagnosticMessage = ts.Diagnostics.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0;
                }
                else if (ts.isChildOfNodeWithKind(node, 198)) {
                    diagnosticMessage = ts.Diagnostics.Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0;
                }
                else if (ts.isChildOfNodeWithKind(node, 302)) {
                    diagnosticMessage = ts.Diagnostics.Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0;
                }
                if (diagnosticMessage) {
                    var withMinus = ts.isPrefixUnaryExpression(node.parent) && node.parent.operator === 40;
                    var literal = (withMinus ? "-" : "") + "0o" + node.text;
                    return grammarErrorOnNode(withMinus ? node.parent : node, diagnosticMessage, literal);
                }
            }
            checkNumericLiteralValueSize(node);
            return false;
        }
        function checkNumericLiteralValueSize(node) {
            var isFractional = ts.getTextOfNode(node).indexOf(".") !== -1;
            var isScientific = node.numericLiteralFlags & 16;
            if (isFractional || isScientific) {
                return;
            }
            var value = +node.text;
            if (value <= Math.pow(2, 53) - 1) {
                return;
            }
            addErrorOrSuggestion(false, ts.createDiagnosticForNode(node, ts.Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers));
        }
        function checkGrammarBigIntLiteral(node) {
            var literalType = ts.isLiteralTypeNode(node.parent) ||
                ts.isPrefixUnaryExpression(node.parent) && ts.isLiteralTypeNode(node.parent.parent);
            if (!literalType) {
                if (languageVersion < 7) {
                    if (grammarErrorOnNode(node, ts.Diagnostics.BigInt_literals_are_not_available_when_targeting_lower_than_ES2020)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function grammarErrorAfterFirstToken(node, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                var span = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                diagnostics.add(ts.createFileDiagnostic(sourceFile, ts.textSpanEnd(span), 0, message, arg0, arg1, arg2));
                return true;
            }
            return false;
        }
        function getAmbientModules() {
            if (!ambientModulesCache) {
                ambientModulesCache = [];
                globals.forEach(function (global, sym) {
                    if (ambientModuleSymbolRegex.test(sym)) {
                        ambientModulesCache.push(global);
                    }
                });
            }
            return ambientModulesCache;
        }
        function checkGrammarImportClause(node) {
            var _a;
            if (node.isTypeOnly && node.name && node.namedBindings) {
                return grammarErrorOnNode(node, ts.Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both);
            }
            if (node.isTypeOnly && ((_a = node.namedBindings) === null || _a === void 0 ? void 0 : _a.kind) === 272) {
                return checkGrammarNamedImportsOrExports(node.namedBindings);
            }
            return false;
        }
        function checkGrammarNamedImportsOrExports(namedBindings) {
            return !!ts.forEach(namedBindings.elements, function (specifier) {
                if (specifier.isTypeOnly) {
                    return grammarErrorOnFirstToken(specifier, specifier.kind === 273
                        ? ts.Diagnostics.The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement
                        : ts.Diagnostics.The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement);
                }
            });
        }
        function checkGrammarImportCallExpression(node) {
            if (moduleKind === ts.ModuleKind.ES2015) {
                return grammarErrorOnNode(node, ts.Diagnostics.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext);
            }
            if (node.typeArguments) {
                return grammarErrorOnNode(node, ts.Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments);
            }
            var nodeArguments = node.arguments;
            if (moduleKind !== ts.ModuleKind.ESNext && moduleKind !== ts.ModuleKind.NodeNext && moduleKind !== ts.ModuleKind.Node16) {
                checkGrammarForDisallowedTrailingComma(nodeArguments);
                if (nodeArguments.length > 1) {
                    var assertionArgument = nodeArguments[1];
                    return grammarErrorOnNode(assertionArgument, ts.Diagnostics.Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nodenext);
                }
            }
            if (nodeArguments.length === 0 || nodeArguments.length > 2) {
                return grammarErrorOnNode(node, ts.Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments);
            }
            var spreadElement = ts.find(nodeArguments, ts.isSpreadElement);
            if (spreadElement) {
                return grammarErrorOnNode(spreadElement, ts.Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element);
            }
            return false;
        }
        function findMatchingTypeReferenceOrTypeAliasReference(source, unionTarget) {
            var sourceObjectFlags = ts.getObjectFlags(source);
            if (sourceObjectFlags & (4 | 16) && unionTarget.flags & 1048576) {
                return ts.find(unionTarget.types, function (target) {
                    if (target.flags & 524288) {
                        var overlapObjFlags = sourceObjectFlags & ts.getObjectFlags(target);
                        if (overlapObjFlags & 4) {
                            return source.target === target.target;
                        }
                        if (overlapObjFlags & 16) {
                            return !!source.aliasSymbol && source.aliasSymbol === target.aliasSymbol;
                        }
                    }
                    return false;
                });
            }
        }
        function findBestTypeForObjectLiteral(source, unionTarget) {
            if (ts.getObjectFlags(source) & 128 && someType(unionTarget, isArrayLikeType)) {
                return ts.find(unionTarget.types, function (t) { return !isArrayLikeType(t); });
            }
        }
        function findBestTypeForInvokable(source, unionTarget) {
            var signatureKind = 0;
            var hasSignatures = getSignaturesOfType(source, signatureKind).length > 0 ||
                (signatureKind = 1, getSignaturesOfType(source, signatureKind).length > 0);
            if (hasSignatures) {
                return ts.find(unionTarget.types, function (t) { return getSignaturesOfType(t, signatureKind).length > 0; });
            }
        }
        function findMostOverlappyType(source, unionTarget) {
            var bestMatch;
            if (!(source.flags & (131068 | 406847488))) {
                var matchingCount = 0;
                for (var _i = 0, _a = unionTarget.types; _i < _a.length; _i++) {
                    var target = _a[_i];
                    if (!(target.flags & (131068 | 406847488))) {
                        var overlap = getIntersectionType([getIndexType(source), getIndexType(target)]);
                        if (overlap.flags & 4194304) {
                            return target;
                        }
                        else if (isUnitType(overlap) || overlap.flags & 1048576) {
                            var len = overlap.flags & 1048576 ? ts.countWhere(overlap.types, isUnitType) : 1;
                            if (len >= matchingCount) {
                                bestMatch = target;
                                matchingCount = len;
                            }
                        }
                    }
                }
            }
            return bestMatch;
        }
        function filterPrimitivesIfContainsNonPrimitive(type) {
            if (maybeTypeOfKind(type, 67108864)) {
                var result = filterType(type, function (t) { return !(t.flags & 131068); });
                if (!(result.flags & 131072)) {
                    return result;
                }
            }
            return type;
        }
        function findMatchingDiscriminantType(source, target, isRelatedTo, skipPartial) {
            if (target.flags & 1048576 && source.flags & (2097152 | 524288)) {
                var match = getMatchingUnionConstituentForType(target, source);
                if (match) {
                    return match;
                }
                var sourceProperties = getPropertiesOfType(source);
                if (sourceProperties) {
                    var sourcePropertiesFiltered = findDiscriminantProperties(sourceProperties, target);
                    if (sourcePropertiesFiltered) {
                        return discriminateTypeByDiscriminableItems(target, ts.map(sourcePropertiesFiltered, function (p) { return [function () { return getTypeOfSymbol(p); }, p.escapedName]; }), isRelatedTo, undefined, skipPartial);
                    }
                }
            }
            return undefined;
        }
    }
    ts.createTypeChecker = createTypeChecker;
    function isNotAccessor(declaration) {
        return !ts.isAccessor(declaration);
    }
    function isNotOverload(declaration) {
        return (declaration.kind !== 259 && declaration.kind !== 171) ||
            !!declaration.body;
    }
    function isDeclarationNameOrImportPropertyName(name) {
        switch (name.parent.kind) {
            case 273:
            case 278:
                return ts.isIdentifier(name);
            default:
                return ts.isDeclarationName(name);
        }
    }
    var JsxNames;
    (function (JsxNames) {
        JsxNames.JSX = "JSX";
        JsxNames.IntrinsicElements = "IntrinsicElements";
        JsxNames.ElementClass = "ElementClass";
        JsxNames.ElementAttributesPropertyNameContainer = "ElementAttributesProperty";
        JsxNames.ElementChildrenAttributeNameContainer = "ElementChildrenAttribute";
        JsxNames.Element = "Element";
        JsxNames.IntrinsicAttributes = "IntrinsicAttributes";
        JsxNames.IntrinsicClassAttributes = "IntrinsicClassAttributes";
        JsxNames.LibraryManagedAttributes = "LibraryManagedAttributes";
    })(JsxNames || (JsxNames = {}));
    function getIterationTypesKeyFromIterationTypeKind(typeKind) {
        switch (typeKind) {
            case 0: return "yieldType";
            case 1: return "returnType";
            case 2: return "nextType";
        }
    }
    function signatureHasRestParameter(s) {
        return !!(s.flags & 1);
    }
    ts.signatureHasRestParameter = signatureHasRestParameter;
    function signatureHasLiteralTypes(s) {
        return !!(s.flags & 2);
    }
    ts.signatureHasLiteralTypes = signatureHasLiteralTypes;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var _a;
    function visitNode(node, visitor, test, lift) {
        if (node === undefined || visitor === undefined) {
            return node;
        }
        var visited = visitor(node);
        if (visited === node) {
            return node;
        }
        var visitedNode;
        if (visited === undefined) {
            return undefined;
        }
        else if (ts.isArray(visited)) {
            visitedNode = (lift || extractSingleNode)(visited);
        }
        else {
            visitedNode = visited;
        }
        ts.Debug.assertNode(visitedNode, test);
        return visitedNode;
    }
    ts.visitNode = visitNode;
    function visitNodes(nodes, visitor, test, start, count) {
        if (nodes === undefined || visitor === undefined) {
            return nodes;
        }
        var length = nodes.length;
        if (start === undefined || start < 0) {
            start = 0;
        }
        if (count === undefined || count > length - start) {
            count = length - start;
        }
        var hasTrailingComma;
        var pos = -1;
        var end = -1;
        if (start > 0 || count < length) {
            hasTrailingComma = nodes.hasTrailingComma && start + count === length;
        }
        else {
            pos = nodes.pos;
            end = nodes.end;
            hasTrailingComma = nodes.hasTrailingComma;
        }
        var updated = visitArrayWorker(nodes, visitor, test, start, count);
        if (updated !== nodes) {
            var updatedArray = ts.factory.createNodeArray(updated, hasTrailingComma);
            ts.setTextRangePosEnd(updatedArray, pos, end);
            return updatedArray;
        }
        return nodes;
    }
    ts.visitNodes = visitNodes;
    function visitArray(nodes, visitor, test, start, count) {
        if (nodes === undefined) {
            return nodes;
        }
        var length = nodes.length;
        if (start === undefined || start < 0) {
            start = 0;
        }
        if (count === undefined || count > length - start) {
            count = length - start;
        }
        return visitArrayWorker(nodes, visitor, test, start, count);
    }
    ts.visitArray = visitArray;
    function visitArrayWorker(nodes, visitor, test, start, count) {
        var updated;
        var length = nodes.length;
        if (start > 0 || count < length) {
            updated = [];
        }
        for (var i = 0; i < count; i++) {
            var node = nodes[i + start];
            var visited = node !== undefined ? visitor(node) : undefined;
            if (updated !== undefined || visited === undefined || visited !== node) {
                if (updated === undefined) {
                    updated = nodes.slice(0, i);
                }
                if (visited) {
                    if (ts.isArray(visited)) {
                        for (var _i = 0, visited_1 = visited; _i < visited_1.length; _i++) {
                            var visitedNode = visited_1[_i];
                            void ts.Debug.assertNode(visitedNode, test);
                            updated.push(visitedNode);
                        }
                    }
                    else {
                        void ts.Debug.assertNode(visited, test);
                        updated.push(visited);
                    }
                }
            }
        }
        return updated !== null && updated !== void 0 ? updated : nodes;
    }
    function visitLexicalEnvironment(statements, visitor, context, start, ensureUseStrict, nodesVisitor) {
        if (nodesVisitor === void 0) { nodesVisitor = visitNodes; }
        context.startLexicalEnvironment();
        statements = nodesVisitor(statements, visitor, ts.isStatement, start);
        if (ensureUseStrict)
            statements = context.factory.ensureUseStrict(statements);
        return ts.factory.mergeLexicalEnvironment(statements, context.endLexicalEnvironment());
    }
    ts.visitLexicalEnvironment = visitLexicalEnvironment;
    function visitParameterList(nodes, visitor, context, nodesVisitor) {
        if (nodesVisitor === void 0) { nodesVisitor = visitNodes; }
        var updated;
        context.startLexicalEnvironment();
        if (nodes) {
            context.setLexicalEnvironmentFlags(1, true);
            updated = nodesVisitor(nodes, visitor, ts.isParameterDeclaration);
            if (context.getLexicalEnvironmentFlags() & 2 &&
                ts.getEmitScriptTarget(context.getCompilerOptions()) >= 2) {
                updated = addDefaultValueAssignmentsIfNeeded(updated, context);
            }
            context.setLexicalEnvironmentFlags(1, false);
        }
        context.suspendLexicalEnvironment();
        return updated;
    }
    ts.visitParameterList = visitParameterList;
    function addDefaultValueAssignmentsIfNeeded(parameters, context) {
        var result;
        for (var i = 0; i < parameters.length; i++) {
            var parameter = parameters[i];
            var updated = addDefaultValueAssignmentIfNeeded(parameter, context);
            if (result || updated !== parameter) {
                if (!result)
                    result = parameters.slice(0, i);
                result[i] = updated;
            }
        }
        if (result) {
            return ts.setTextRange(context.factory.createNodeArray(result, parameters.hasTrailingComma), parameters);
        }
        return parameters;
    }
    function addDefaultValueAssignmentIfNeeded(parameter, context) {
        return parameter.dotDotDotToken ? parameter :
            ts.isBindingPattern(parameter.name) ? addDefaultValueAssignmentForBindingPattern(parameter, context) :
                parameter.initializer ? addDefaultValueAssignmentForInitializer(parameter, parameter.name, parameter.initializer, context) :
                    parameter;
    }
    function addDefaultValueAssignmentForBindingPattern(parameter, context) {
        var factory = context.factory;
        context.addInitializationStatement(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
            factory.createVariableDeclaration(parameter.name, undefined, parameter.type, parameter.initializer ?
                factory.createConditionalExpression(factory.createStrictEquality(factory.getGeneratedNameForNode(parameter), factory.createVoidZero()), undefined, parameter.initializer, undefined, factory.getGeneratedNameForNode(parameter)) :
                factory.getGeneratedNameForNode(parameter)),
        ])));
        return factory.updateParameterDeclaration(parameter, parameter.modifiers, parameter.dotDotDotToken, factory.getGeneratedNameForNode(parameter), parameter.questionToken, parameter.type, undefined);
    }
    function addDefaultValueAssignmentForInitializer(parameter, name, initializer, context) {
        var factory = context.factory;
        context.addInitializationStatement(factory.createIfStatement(factory.createTypeCheck(factory.cloneNode(name), "undefined"), ts.setEmitFlags(ts.setTextRange(factory.createBlock([
            factory.createExpressionStatement(ts.setEmitFlags(ts.setTextRange(factory.createAssignment(ts.setEmitFlags(factory.cloneNode(name), 48), ts.setEmitFlags(initializer, 48 | ts.getEmitFlags(initializer) | 1536)), parameter), 1536))
        ]), parameter), 1 | 32 | 384 | 1536)));
        return factory.updateParameterDeclaration(parameter, parameter.modifiers, parameter.dotDotDotToken, parameter.name, parameter.questionToken, parameter.type, undefined);
    }
    function visitFunctionBody(node, visitor, context, nodeVisitor) {
        if (nodeVisitor === void 0) { nodeVisitor = visitNode; }
        context.resumeLexicalEnvironment();
        var updated = nodeVisitor(node, visitor, ts.isConciseBody);
        var declarations = context.endLexicalEnvironment();
        if (ts.some(declarations)) {
            if (!updated) {
                return context.factory.createBlock(declarations);
            }
            var block = context.factory.converters.convertToFunctionBlock(updated);
            var statements = ts.factory.mergeLexicalEnvironment(block.statements, declarations);
            return context.factory.updateBlock(block, statements);
        }
        return updated;
    }
    ts.visitFunctionBody = visitFunctionBody;
    function visitIterationBody(body, visitor, context, nodeVisitor) {
        if (nodeVisitor === void 0) { nodeVisitor = visitNode; }
        context.startBlockScope();
        var updated = nodeVisitor(body, visitor, ts.isStatement, context.factory.liftToBlock);
        var declarations = context.endBlockScope();
        if (ts.some(declarations)) {
            if (ts.isBlock(updated)) {
                declarations.push.apply(declarations, updated.statements);
                return context.factory.updateBlock(updated, declarations);
            }
            declarations.push(updated);
            return context.factory.createBlock(declarations);
        }
        return updated;
    }
    ts.visitIterationBody = visitIterationBody;
    function visitEachChild(node, visitor, context, nodesVisitor, tokenVisitor, nodeVisitor) {
        if (nodesVisitor === void 0) { nodesVisitor = visitNodes; }
        if (nodeVisitor === void 0) { nodeVisitor = visitNode; }
        if (node === undefined) {
            return undefined;
        }
        var fn = visitEachChildTable[node.kind];
        return fn === undefined ? node : fn(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor);
    }
    ts.visitEachChild = visitEachChild;
    var visitEachChildTable = (_a = {},
        _a[79] = function visitEachChildOfIdentifier(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateIdentifier(node, nodesVisitor(node.typeArguments, visitor, ts.isTypeNodeOrTypeParameterDeclaration));
        },
        _a[163] = function visitEachChildOfQualifiedName(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateQualifiedName(node, nodeVisitor(node.left, visitor, ts.isEntityName), nodeVisitor(node.right, visitor, ts.isIdentifier));
        },
        _a[164] = function visitEachChildOfComputedPropertyName(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateComputedPropertyName(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[165] = function visitEachChildOfTypeParameterDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTypeParameterDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.constraint, visitor, ts.isTypeNode), nodeVisitor(node.default, visitor, ts.isTypeNode));
        },
        _a[166] = function visitEachChildOfParameterDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateParameterDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifierLike), nodeVisitor(node.dotDotDotToken, tokenVisitor, ts.isDotDotDotToken), nodeVisitor(node.name, visitor, ts.isBindingName), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionToken), nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.initializer, visitor, ts.isExpression));
        },
        _a[167] = function visitEachChildOfDecorator(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateDecorator(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[168] = function visitEachChildOfPropertySignature(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updatePropertySignature(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.questionToken, tokenVisitor, ts.isToken), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[169] = function visitEachChildOfPropertyDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
            var _a;
            return context.factory.updatePropertyDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifierLike), nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor((_a = node.questionToken) !== null && _a !== void 0 ? _a : node.exclamationToken, tokenVisitor, ts.isQuestionOrExclamationToken), nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.initializer, visitor, ts.isExpression));
        },
        _a[170] = function visitEachChildOfMethodSignature(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateMethodSignature(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionToken), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[171] = function visitEachChildOfMethodDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateMethodDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifierLike), nodeVisitor(node.asteriskToken, tokenVisitor, ts.isAsteriskToken), nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionToken), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context, nodeVisitor));
        },
        _a[173] = function visitEachChildOfConstructorDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateConstructorDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitFunctionBody(node.body, visitor, context, nodeVisitor));
        },
        _a[174] = function visitEachChildOfGetAccessorDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateGetAccessorDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifierLike), nodeVisitor(node.name, visitor, ts.isPropertyName), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context, nodeVisitor));
        },
        _a[175] = function visitEachChildOfSetAccessorDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateSetAccessorDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifierLike), nodeVisitor(node.name, visitor, ts.isPropertyName), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitFunctionBody(node.body, visitor, context, nodeVisitor));
        },
        _a[172] = function visitEachChildOfClassStaticBlockDeclaration(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            context.startLexicalEnvironment();
            context.suspendLexicalEnvironment();
            return context.factory.updateClassStaticBlockDeclaration(node, visitFunctionBody(node.body, visitor, context, nodeVisitor));
        },
        _a[176] = function visitEachChildOfCallSignatureDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateCallSignature(node, nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[177] = function visitEachChildOfConstructSignatureDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateConstructSignature(node, nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[178] = function visitEachChildOfIndexSignatureDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateIndexSignature(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[179] = function visitEachChildOfTypePredicateNode(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTypePredicateNode(node, nodeVisitor(node.assertsModifier, visitor, ts.isAssertsKeyword), nodeVisitor(node.parameterName, visitor, ts.isIdentifierOrThisTypeNode), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[180] = function visitEachChildOfTypeReferenceNode(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTypeReferenceNode(node, nodeVisitor(node.typeName, visitor, ts.isEntityName), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode));
        },
        _a[181] = function visitEachChildOfFunctionTypeNode(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateFunctionTypeNode(node, nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[182] = function visitEachChildOfConstructorTypeNode(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateConstructorTypeNode(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[183] = function visitEachChildOfTypeQueryNode(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTypeQueryNode(node, nodeVisitor(node.exprName, visitor, ts.isEntityName), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode));
        },
        _a[184] = function visitEachChildOfTypeLiteralNode(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateTypeLiteralNode(node, nodesVisitor(node.members, visitor, ts.isTypeElement));
        },
        _a[185] = function visitEachChildOfArrayTypeNode(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateArrayTypeNode(node, nodeVisitor(node.elementType, visitor, ts.isTypeNode));
        },
        _a[186] = function visitEachChildOfTupleTypeNode(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateTupleTypeNode(node, nodesVisitor(node.elements, visitor, ts.isTypeNode));
        },
        _a[187] = function visitEachChildOfOptionalTypeNode(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateOptionalTypeNode(node, nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[188] = function visitEachChildOfRestTypeNode(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateRestTypeNode(node, nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[189] = function visitEachChildOfUnionTypeNode(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateUnionTypeNode(node, nodesVisitor(node.types, visitor, ts.isTypeNode));
        },
        _a[190] = function visitEachChildOfIntersectionTypeNode(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateIntersectionTypeNode(node, nodesVisitor(node.types, visitor, ts.isTypeNode));
        },
        _a[191] = function visitEachChildOfConditionalTypeNode(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateConditionalTypeNode(node, nodeVisitor(node.checkType, visitor, ts.isTypeNode), nodeVisitor(node.extendsType, visitor, ts.isTypeNode), nodeVisitor(node.trueType, visitor, ts.isTypeNode), nodeVisitor(node.falseType, visitor, ts.isTypeNode));
        },
        _a[192] = function visitEachChildOfInferTypeNode(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateInferTypeNode(node, nodeVisitor(node.typeParameter, visitor, ts.isTypeParameterDeclaration));
        },
        _a[202] = function visitEachChildOfImportTypeNode(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateImportTypeNode(node, nodeVisitor(node.argument, visitor, ts.isTypeNode), nodeVisitor(node.assertions, visitor, ts.isImportTypeAssertionContainer), nodeVisitor(node.qualifier, visitor, ts.isEntityName), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), node.isTypeOf);
        },
        _a[298] = function visitEachChildOfImportTypeAssertionContainer(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateImportTypeAssertionContainer(node, nodeVisitor(node.assertClause, visitor, ts.isAssertClause), node.multiLine);
        },
        _a[199] = function visitEachChildOfNamedTupleMember(node, visitor, context, _nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateNamedTupleMember(node, nodeVisitor(node.dotDotDotToken, tokenVisitor, ts.isDotDotDotToken), nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionToken), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[193] = function visitEachChildOfParenthesizedType(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateParenthesizedType(node, nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[195] = function visitEachChildOfTypeOperatorNode(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTypeOperatorNode(node, nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[196] = function visitEachChildOfIndexedAccessType(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateIndexedAccessTypeNode(node, nodeVisitor(node.objectType, visitor, ts.isTypeNode), nodeVisitor(node.indexType, visitor, ts.isTypeNode));
        },
        _a[197] = function visitEachChildOfMappedType(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateMappedTypeNode(node, nodeVisitor(node.readonlyToken, tokenVisitor, ts.isReadonlyKeywordOrPlusOrMinusToken), nodeVisitor(node.typeParameter, visitor, ts.isTypeParameterDeclaration), nodeVisitor(node.nameType, visitor, ts.isTypeNode), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionOrPlusOrMinusToken), nodeVisitor(node.type, visitor, ts.isTypeNode), nodesVisitor(node.members, visitor, ts.isTypeElement));
        },
        _a[198] = function visitEachChildOfLiteralTypeNode(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateLiteralTypeNode(node, nodeVisitor(node.literal, visitor, ts.isExpression));
        },
        _a[200] = function visitEachChildOfTemplateLiteralType(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTemplateLiteralType(node, nodeVisitor(node.head, visitor, ts.isTemplateHead), nodesVisitor(node.templateSpans, visitor, ts.isTemplateLiteralTypeSpan));
        },
        _a[201] = function visitEachChildOfTemplateLiteralTypeSpan(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTemplateLiteralTypeSpan(node, nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.literal, visitor, ts.isTemplateMiddleOrTemplateTail));
        },
        _a[203] = function visitEachChildOfObjectBindingPattern(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateObjectBindingPattern(node, nodesVisitor(node.elements, visitor, ts.isBindingElement));
        },
        _a[204] = function visitEachChildOfArrayBindingPattern(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateArrayBindingPattern(node, nodesVisitor(node.elements, visitor, ts.isArrayBindingElement));
        },
        _a[205] = function visitEachChildOfBindingElement(node, visitor, context, _nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateBindingElement(node, nodeVisitor(node.dotDotDotToken, tokenVisitor, ts.isDotDotDotToken), nodeVisitor(node.propertyName, visitor, ts.isPropertyName), nodeVisitor(node.name, visitor, ts.isBindingName), nodeVisitor(node.initializer, visitor, ts.isExpression));
        },
        _a[206] = function visitEachChildOfArrayLiteralExpression(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateArrayLiteralExpression(node, nodesVisitor(node.elements, visitor, ts.isExpression));
        },
        _a[207] = function visitEachChildOfObjectLiteralExpression(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateObjectLiteralExpression(node, nodesVisitor(node.properties, visitor, ts.isObjectLiteralElementLike));
        },
        _a[208] = function visitEachChildOfPropertyAccessExpression(node, visitor, context, _nodesVisitor, nodeVisitor, tokenVisitor) {
            return ts.isPropertyAccessChain(node) ?
                context.factory.updatePropertyAccessChain(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.questionDotToken, tokenVisitor, ts.isQuestionDotToken), nodeVisitor(node.name, visitor, ts.isMemberName)) :
                context.factory.updatePropertyAccessExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.name, visitor, ts.isMemberName));
        },
        _a[209] = function visitEachChildOfElementAccessExpression(node, visitor, context, _nodesVisitor, nodeVisitor, tokenVisitor) {
            return ts.isElementAccessChain(node) ?
                context.factory.updateElementAccessChain(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.questionDotToken, tokenVisitor, ts.isQuestionDotToken), nodeVisitor(node.argumentExpression, visitor, ts.isExpression)) :
                context.factory.updateElementAccessExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.argumentExpression, visitor, ts.isExpression));
        },
        _a[210] = function visitEachChildOfCallExpression(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
            return ts.isCallChain(node) ?
                context.factory.updateCallChain(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.questionDotToken, tokenVisitor, ts.isQuestionDotToken), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodesVisitor(node.arguments, visitor, ts.isExpression)) :
                context.factory.updateCallExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodesVisitor(node.arguments, visitor, ts.isExpression));
        },
        _a[211] = function visitEachChildOfNewExpression(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateNewExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodesVisitor(node.arguments, visitor, ts.isExpression));
        },
        _a[212] = function visitEachChildOfTaggedTemplateExpression(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTaggedTemplateExpression(node, nodeVisitor(node.tag, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodeVisitor(node.template, visitor, ts.isTemplateLiteral));
        },
        _a[213] = function visitEachChildOfTypeAssertionExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTypeAssertion(node, nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[214] = function visitEachChildOfParenthesizedExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateParenthesizedExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[215] = function visitEachChildOfFunctionExpression(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateFunctionExpression(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.asteriskToken, tokenVisitor, ts.isAsteriskToken), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context, nodeVisitor));
        },
        _a[216] = function visitEachChildOfArrowFunction(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateArrowFunction(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.equalsGreaterThanToken, tokenVisitor, ts.isEqualsGreaterThanToken), visitFunctionBody(node.body, visitor, context, nodeVisitor));
        },
        _a[217] = function visitEachChildOfDeleteExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateDeleteExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[218] = function visitEachChildOfTypeOfExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTypeOfExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[219] = function visitEachChildOfVoidExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateVoidExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[220] = function visitEachChildOfAwaitExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateAwaitExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[221] = function visitEachChildOfPrefixUnaryExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updatePrefixUnaryExpression(node, nodeVisitor(node.operand, visitor, ts.isExpression));
        },
        _a[222] = function visitEachChildOfPostfixUnaryExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updatePostfixUnaryExpression(node, nodeVisitor(node.operand, visitor, ts.isExpression));
        },
        _a[223] = function visitEachChildOfBinaryExpression(node, visitor, context, _nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateBinaryExpression(node, nodeVisitor(node.left, visitor, ts.isExpression), nodeVisitor(node.operatorToken, tokenVisitor, ts.isBinaryOperatorToken), nodeVisitor(node.right, visitor, ts.isExpression));
        },
        _a[224] = function visitEachChildOfConditionalExpression(node, visitor, context, _nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateConditionalExpression(node, nodeVisitor(node.condition, visitor, ts.isExpression), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionToken), nodeVisitor(node.whenTrue, visitor, ts.isExpression), nodeVisitor(node.colonToken, tokenVisitor, ts.isColonToken), nodeVisitor(node.whenFalse, visitor, ts.isExpression));
        },
        _a[225] = function visitEachChildOfTemplateExpression(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTemplateExpression(node, nodeVisitor(node.head, visitor, ts.isTemplateHead), nodesVisitor(node.templateSpans, visitor, ts.isTemplateSpan));
        },
        _a[226] = function visitEachChildOfYieldExpression(node, visitor, context, _nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateYieldExpression(node, nodeVisitor(node.asteriskToken, tokenVisitor, ts.isAsteriskToken), nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[227] = function visitEachChildOfSpreadElement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateSpreadElement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[228] = function visitEachChildOfClassExpression(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateClassExpression(node, nodesVisitor(node.modifiers, visitor, ts.isModifierLike), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.heritageClauses, visitor, ts.isHeritageClause), nodesVisitor(node.members, visitor, ts.isClassElement));
        },
        _a[230] = function visitEachChildOfExpressionWithTypeArguments(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateExpressionWithTypeArguments(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode));
        },
        _a[231] = function visitEachChildOfAsExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateAsExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[235] = function visitEachChildOfSatisfiesExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateSatisfiesExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[232] = function visitEachChildOfNonNullExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return ts.isOptionalChain(node) ?
                context.factory.updateNonNullChain(node, nodeVisitor(node.expression, visitor, ts.isExpression)) :
                context.factory.updateNonNullExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[233] = function visitEachChildOfMetaProperty(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateMetaProperty(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
        },
        _a[236] = function visitEachChildOfTemplateSpan(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTemplateSpan(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.literal, visitor, ts.isTemplateMiddleOrTemplateTail));
        },
        _a[238] = function visitEachChildOfBlock(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateBlock(node, nodesVisitor(node.statements, visitor, ts.isStatement));
        },
        _a[240] = function visitEachChildOfVariableStatement(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateVariableStatement(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.declarationList, visitor, ts.isVariableDeclarationList));
        },
        _a[241] = function visitEachChildOfExpressionStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateExpressionStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[242] = function visitEachChildOfIfStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateIfStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.thenStatement, visitor, ts.isStatement, context.factory.liftToBlock), nodeVisitor(node.elseStatement, visitor, ts.isStatement, context.factory.liftToBlock));
        },
        _a[243] = function visitEachChildOfDoStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateDoStatement(node, visitIterationBody(node.statement, visitor, context, nodeVisitor), nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[244] = function visitEachChildOfWhileStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateWhileStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context, nodeVisitor));
        },
        _a[245] = function visitEachChildOfForStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateForStatement(node, nodeVisitor(node.initializer, visitor, ts.isForInitializer), nodeVisitor(node.condition, visitor, ts.isExpression), nodeVisitor(node.incrementor, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context, nodeVisitor));
        },
        _a[246] = function visitEachChildOfForInStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateForInStatement(node, nodeVisitor(node.initializer, visitor, ts.isForInitializer), nodeVisitor(node.expression, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context, nodeVisitor));
        },
        _a[247] = function visitEachChildOfForOfStatement(node, visitor, context, _nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateForOfStatement(node, nodeVisitor(node.awaitModifier, tokenVisitor, ts.isAwaitKeyword), nodeVisitor(node.initializer, visitor, ts.isForInitializer), nodeVisitor(node.expression, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context, nodeVisitor));
        },
        _a[248] = function visitEachChildOfContinueStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateContinueStatement(node, nodeVisitor(node.label, visitor, ts.isIdentifier));
        },
        _a[249] = function visitEachChildOfBreakStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateBreakStatement(node, nodeVisitor(node.label, visitor, ts.isIdentifier));
        },
        _a[250] = function visitEachChildOfReturnStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateReturnStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[251] = function visitEachChildOfWithStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateWithStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.statement, visitor, ts.isStatement, context.factory.liftToBlock));
        },
        _a[252] = function visitEachChildOfSwitchStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateSwitchStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.caseBlock, visitor, ts.isCaseBlock));
        },
        _a[253] = function visitEachChildOfLabeledStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateLabeledStatement(node, nodeVisitor(node.label, visitor, ts.isIdentifier), nodeVisitor(node.statement, visitor, ts.isStatement, context.factory.liftToBlock));
        },
        _a[254] = function visitEachChildOfThrowStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateThrowStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[255] = function visitEachChildOfTryStatement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTryStatement(node, nodeVisitor(node.tryBlock, visitor, ts.isBlock), nodeVisitor(node.catchClause, visitor, ts.isCatchClause), nodeVisitor(node.finallyBlock, visitor, ts.isBlock));
        },
        _a[257] = function visitEachChildOfVariableDeclaration(node, visitor, context, _nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateVariableDeclaration(node, nodeVisitor(node.name, visitor, ts.isBindingName), nodeVisitor(node.exclamationToken, tokenVisitor, ts.isExclamationToken), nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.initializer, visitor, ts.isExpression));
        },
        _a[258] = function visitEachChildOfVariableDeclarationList(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateVariableDeclarationList(node, nodesVisitor(node.declarations, visitor, ts.isVariableDeclaration));
        },
        _a[259] = function visitEachChildOfFunctionDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, tokenVisitor) {
            return context.factory.updateFunctionDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.asteriskToken, tokenVisitor, ts.isAsteriskToken), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context, nodeVisitor));
        },
        _a[260] = function visitEachChildOfClassDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateClassDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifierLike), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.heritageClauses, visitor, ts.isHeritageClause), nodesVisitor(node.members, visitor, ts.isClassElement));
        },
        _a[261] = function visitEachChildOfInterfaceDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateInterfaceDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.heritageClauses, visitor, ts.isHeritageClause), nodesVisitor(node.members, visitor, ts.isTypeElement));
        },
        _a[262] = function visitEachChildOfTypeAliasDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateTypeAliasDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
        },
        _a[263] = function visitEachChildOfEnumDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateEnumDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.members, visitor, ts.isEnumMember));
        },
        _a[264] = function visitEachChildOfModuleDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateModuleDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isModuleName), nodeVisitor(node.body, visitor, ts.isModuleBody));
        },
        _a[265] = function visitEachChildOfModuleBlock(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateModuleBlock(node, nodesVisitor(node.statements, visitor, ts.isStatement));
        },
        _a[266] = function visitEachChildOfCaseBlock(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateCaseBlock(node, nodesVisitor(node.clauses, visitor, ts.isCaseOrDefaultClause));
        },
        _a[267] = function visitEachChildOfNamespaceExportDeclaration(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateNamespaceExportDeclaration(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
        },
        _a[268] = function visitEachChildOfImportEqualsDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateImportEqualsDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), node.isTypeOnly, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.moduleReference, visitor, ts.isModuleReference));
        },
        _a[269] = function visitEachChildOfImportDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateImportDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.importClause, visitor, ts.isImportClause), nodeVisitor(node.moduleSpecifier, visitor, ts.isExpression), nodeVisitor(node.assertClause, visitor, ts.isAssertClause));
        },
        _a[296] = function visitEachChildOfAssertClause(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateAssertClause(node, nodesVisitor(node.elements, visitor, ts.isAssertEntry), node.multiLine);
        },
        _a[297] = function visitEachChildOfAssertEntry(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateAssertEntry(node, nodeVisitor(node.name, visitor, ts.isAssertionKey), nodeVisitor(node.value, visitor, ts.isExpression));
        },
        _a[270] = function visitEachChildOfImportClause(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateImportClause(node, node.isTypeOnly, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.namedBindings, visitor, ts.isNamedImportBindings));
        },
        _a[271] = function visitEachChildOfNamespaceImport(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateNamespaceImport(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
        },
        _a[277] = function visitEachChildOfNamespaceExport(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateNamespaceExport(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
        },
        _a[272] = function visitEachChildOfNamedImports(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateNamedImports(node, nodesVisitor(node.elements, visitor, ts.isImportSpecifier));
        },
        _a[273] = function visitEachChildOfImportSpecifier(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateImportSpecifier(node, node.isTypeOnly, nodeVisitor(node.propertyName, visitor, ts.isIdentifier), nodeVisitor(node.name, visitor, ts.isIdentifier));
        },
        _a[274] = function visitEachChildOfExportAssignment(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateExportAssignment(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[275] = function visitEachChildOfExportDeclaration(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateExportDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), node.isTypeOnly, nodeVisitor(node.exportClause, visitor, ts.isNamedExportBindings), nodeVisitor(node.moduleSpecifier, visitor, ts.isExpression), nodeVisitor(node.assertClause, visitor, ts.isAssertClause));
        },
        _a[276] = function visitEachChildOfNamedExports(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateNamedExports(node, nodesVisitor(node.elements, visitor, ts.isExportSpecifier));
        },
        _a[278] = function visitEachChildOfExportSpecifier(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateExportSpecifier(node, node.isTypeOnly, nodeVisitor(node.propertyName, visitor, ts.isIdentifier), nodeVisitor(node.name, visitor, ts.isIdentifier));
        },
        _a[280] = function visitEachChildOfExternalModuleReference(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateExternalModuleReference(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[281] = function visitEachChildOfJsxElement(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateJsxElement(node, nodeVisitor(node.openingElement, visitor, ts.isJsxOpeningElement), nodesVisitor(node.children, visitor, ts.isJsxChild), nodeVisitor(node.closingElement, visitor, ts.isJsxClosingElement));
        },
        _a[282] = function visitEachChildOfJsxSelfClosingElement(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateJsxSelfClosingElement(node, nodeVisitor(node.tagName, visitor, ts.isJsxTagNameExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodeVisitor(node.attributes, visitor, ts.isJsxAttributes));
        },
        _a[283] = function visitEachChildOfJsxOpeningElement(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateJsxOpeningElement(node, nodeVisitor(node.tagName, visitor, ts.isJsxTagNameExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodeVisitor(node.attributes, visitor, ts.isJsxAttributes));
        },
        _a[284] = function visitEachChildOfJsxClosingElement(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateJsxClosingElement(node, nodeVisitor(node.tagName, visitor, ts.isJsxTagNameExpression));
        },
        _a[285] = function visitEachChildOfJsxFragment(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateJsxFragment(node, nodeVisitor(node.openingFragment, visitor, ts.isJsxOpeningFragment), nodesVisitor(node.children, visitor, ts.isJsxChild), nodeVisitor(node.closingFragment, visitor, ts.isJsxClosingFragment));
        },
        _a[288] = function visitEachChildOfJsxAttribute(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateJsxAttribute(node, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.initializer, visitor, ts.isStringLiteralOrJsxExpression));
        },
        _a[289] = function visitEachChildOfJsxAttributes(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateJsxAttributes(node, nodesVisitor(node.properties, visitor, ts.isJsxAttributeLike));
        },
        _a[290] = function visitEachChildOfJsxSpreadAttribute(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateJsxSpreadAttribute(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[291] = function visitEachChildOfJsxExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateJsxExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[292] = function visitEachChildOfCaseClause(node, visitor, context, nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateCaseClause(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.statements, visitor, ts.isStatement));
        },
        _a[293] = function visitEachChildOfDefaultClause(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateDefaultClause(node, nodesVisitor(node.statements, visitor, ts.isStatement));
        },
        _a[294] = function visitEachChildOfHeritageClause(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateHeritageClause(node, nodesVisitor(node.types, visitor, ts.isExpressionWithTypeArguments));
        },
        _a[295] = function visitEachChildOfCatchClause(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateCatchClause(node, nodeVisitor(node.variableDeclaration, visitor, ts.isVariableDeclaration), nodeVisitor(node.block, visitor, ts.isBlock));
        },
        _a[299] = function visitEachChildOfPropertyAssignment(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updatePropertyAssignment(node, nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.initializer, visitor, ts.isExpression));
        },
        _a[300] = function visitEachChildOfShorthandPropertyAssignment(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateShorthandPropertyAssignment(node, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.objectAssignmentInitializer, visitor, ts.isExpression));
        },
        _a[301] = function visitEachChildOfSpreadAssignment(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateSpreadAssignment(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[302] = function visitEachChildOfEnumMember(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updateEnumMember(node, nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.initializer, visitor, ts.isExpression));
        },
        _a[308] = function visitEachChildOfSourceFile(node, visitor, context, _nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateSourceFile(node, visitLexicalEnvironment(node.statements, visitor, context));
        },
        _a[353] = function visitEachChildOfPartiallyEmittedExpression(node, visitor, context, _nodesVisitor, nodeVisitor, _tokenVisitor) {
            return context.factory.updatePartiallyEmittedExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
        },
        _a[354] = function visitEachChildOfCommaListExpression(node, visitor, context, nodesVisitor, _nodeVisitor, _tokenVisitor) {
            return context.factory.updateCommaListExpression(node, nodesVisitor(node.elements, visitor, ts.isExpression));
        },
        _a);
    function extractSingleNode(nodes) {
        ts.Debug.assert(nodes.length <= 1, "Too many nodes written to output.");
        return ts.singleOrUndefined(nodes);
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createSourceMapGenerator(host, file, sourceRoot, sourcesDirectoryPath, generatorOptions) {
        var _a = generatorOptions.extendedDiagnostics
            ? ts.performance.createTimer("Source Map", "beforeSourcemap", "afterSourcemap")
            : ts.performance.nullTimer, enter = _a.enter, exit = _a.exit;
        var rawSources = [];
        var sources = [];
        var sourceToSourceIndexMap = new ts.Map();
        var sourcesContent;
        var names = [];
        var nameToNameIndexMap;
        var mappingCharCodes = [];
        var mappings = "";
        var lastGeneratedLine = 0;
        var lastGeneratedCharacter = 0;
        var lastSourceIndex = 0;
        var lastSourceLine = 0;
        var lastSourceCharacter = 0;
        var lastNameIndex = 0;
        var hasLast = false;
        var pendingGeneratedLine = 0;
        var pendingGeneratedCharacter = 0;
        var pendingSourceIndex = 0;
        var pendingSourceLine = 0;
        var pendingSourceCharacter = 0;
        var pendingNameIndex = 0;
        var hasPending = false;
        var hasPendingSource = false;
        var hasPendingName = false;
        return {
            getSources: function () { return rawSources; },
            addSource: addSource,
            setSourceContent: setSourceContent,
            addName: addName,
            addMapping: addMapping,
            appendSourceMap: appendSourceMap,
            toJSON: toJSON,
            toString: function () { return JSON.stringify(toJSON()); }
        };
        function addSource(fileName) {
            enter();
            var source = ts.getRelativePathToDirectoryOrUrl(sourcesDirectoryPath, fileName, host.getCurrentDirectory(), host.getCanonicalFileName, true);
            var sourceIndex = sourceToSourceIndexMap.get(source);
            if (sourceIndex === undefined) {
                sourceIndex = sources.length;
                sources.push(source);
                rawSources.push(fileName);
                sourceToSourceIndexMap.set(source, sourceIndex);
            }
            exit();
            return sourceIndex;
        }
        function setSourceContent(sourceIndex, content) {
            enter();
            if (content !== null) {
                if (!sourcesContent)
                    sourcesContent = [];
                while (sourcesContent.length < sourceIndex) {
                    sourcesContent.push(null);
                }
                sourcesContent[sourceIndex] = content;
            }
            exit();
        }
        function addName(name) {
            enter();
            if (!nameToNameIndexMap)
                nameToNameIndexMap = new ts.Map();
            var nameIndex = nameToNameIndexMap.get(name);
            if (nameIndex === undefined) {
                nameIndex = names.length;
                names.push(name);
                nameToNameIndexMap.set(name, nameIndex);
            }
            exit();
            return nameIndex;
        }
        function isNewGeneratedPosition(generatedLine, generatedCharacter) {
            return !hasPending
                || pendingGeneratedLine !== generatedLine
                || pendingGeneratedCharacter !== generatedCharacter;
        }
        function isBacktrackingSourcePosition(sourceIndex, sourceLine, sourceCharacter) {
            return sourceIndex !== undefined
                && sourceLine !== undefined
                && sourceCharacter !== undefined
                && pendingSourceIndex === sourceIndex
                && (pendingSourceLine > sourceLine
                    || pendingSourceLine === sourceLine && pendingSourceCharacter > sourceCharacter);
        }
        function addMapping(generatedLine, generatedCharacter, sourceIndex, sourceLine, sourceCharacter, nameIndex) {
            ts.Debug.assert(generatedLine >= pendingGeneratedLine, "generatedLine cannot backtrack");
            ts.Debug.assert(generatedCharacter >= 0, "generatedCharacter cannot be negative");
            ts.Debug.assert(sourceIndex === undefined || sourceIndex >= 0, "sourceIndex cannot be negative");
            ts.Debug.assert(sourceLine === undefined || sourceLine >= 0, "sourceLine cannot be negative");
            ts.Debug.assert(sourceCharacter === undefined || sourceCharacter >= 0, "sourceCharacter cannot be negative");
            enter();
            if (isNewGeneratedPosition(generatedLine, generatedCharacter) ||
                isBacktrackingSourcePosition(sourceIndex, sourceLine, sourceCharacter)) {
                commitPendingMapping();
                pendingGeneratedLine = generatedLine;
                pendingGeneratedCharacter = generatedCharacter;
                hasPendingSource = false;
                hasPendingName = false;
                hasPending = true;
            }
            if (sourceIndex !== undefined && sourceLine !== undefined && sourceCharacter !== undefined) {
                pendingSourceIndex = sourceIndex;
                pendingSourceLine = sourceLine;
                pendingSourceCharacter = sourceCharacter;
                hasPendingSource = true;
                if (nameIndex !== undefined) {
                    pendingNameIndex = nameIndex;
                    hasPendingName = true;
                }
            }
            exit();
        }
        function appendSourceMap(generatedLine, generatedCharacter, map, sourceMapPath, start, end) {
            ts.Debug.assert(generatedLine >= pendingGeneratedLine, "generatedLine cannot backtrack");
            ts.Debug.assert(generatedCharacter >= 0, "generatedCharacter cannot be negative");
            enter();
            var sourceIndexToNewSourceIndexMap = [];
            var nameIndexToNewNameIndexMap;
            var mappingIterator = decodeMappings(map.mappings);
            for (var iterResult = mappingIterator.next(); !iterResult.done; iterResult = mappingIterator.next()) {
                var raw = iterResult.value;
                if (end && (raw.generatedLine > end.line ||
                    (raw.generatedLine === end.line && raw.generatedCharacter > end.character))) {
                    break;
                }
                if (start && (raw.generatedLine < start.line ||
                    (start.line === raw.generatedLine && raw.generatedCharacter < start.character))) {
                    continue;
                }
                var newSourceIndex = void 0;
                var newSourceLine = void 0;
                var newSourceCharacter = void 0;
                var newNameIndex = void 0;
                if (raw.sourceIndex !== undefined) {
                    newSourceIndex = sourceIndexToNewSourceIndexMap[raw.sourceIndex];
                    if (newSourceIndex === undefined) {
                        var rawPath = map.sources[raw.sourceIndex];
                        var relativePath = map.sourceRoot ? ts.combinePaths(map.sourceRoot, rawPath) : rawPath;
                        var combinedPath = ts.combinePaths(ts.getDirectoryPath(sourceMapPath), relativePath);
                        sourceIndexToNewSourceIndexMap[raw.sourceIndex] = newSourceIndex = addSource(combinedPath);
                        if (map.sourcesContent && typeof map.sourcesContent[raw.sourceIndex] === "string") {
                            setSourceContent(newSourceIndex, map.sourcesContent[raw.sourceIndex]);
                        }
                    }
                    newSourceLine = raw.sourceLine;
                    newSourceCharacter = raw.sourceCharacter;
                    if (map.names && raw.nameIndex !== undefined) {
                        if (!nameIndexToNewNameIndexMap)
                            nameIndexToNewNameIndexMap = [];
                        newNameIndex = nameIndexToNewNameIndexMap[raw.nameIndex];
                        if (newNameIndex === undefined) {
                            nameIndexToNewNameIndexMap[raw.nameIndex] = newNameIndex = addName(map.names[raw.nameIndex]);
                        }
                    }
                }
                var rawGeneratedLine = raw.generatedLine - (start ? start.line : 0);
                var newGeneratedLine = rawGeneratedLine + generatedLine;
                var rawGeneratedCharacter = start && start.line === raw.generatedLine ? raw.generatedCharacter - start.character : raw.generatedCharacter;
                var newGeneratedCharacter = rawGeneratedLine === 0 ? rawGeneratedCharacter + generatedCharacter : rawGeneratedCharacter;
                addMapping(newGeneratedLine, newGeneratedCharacter, newSourceIndex, newSourceLine, newSourceCharacter, newNameIndex);
            }
            exit();
        }
        function shouldCommitMapping() {
            return !hasLast
                || lastGeneratedLine !== pendingGeneratedLine
                || lastGeneratedCharacter !== pendingGeneratedCharacter
                || lastSourceIndex !== pendingSourceIndex
                || lastSourceLine !== pendingSourceLine
                || lastSourceCharacter !== pendingSourceCharacter
                || lastNameIndex !== pendingNameIndex;
        }
        function appendMappingCharCode(charCode) {
            mappingCharCodes.push(charCode);
            if (mappingCharCodes.length >= 1024) {
                flushMappingBuffer();
            }
        }
        function commitPendingMapping() {
            if (!hasPending || !shouldCommitMapping()) {
                return;
            }
            enter();
            if (lastGeneratedLine < pendingGeneratedLine) {
                do {
                    appendMappingCharCode(59);
                    lastGeneratedLine++;
                } while (lastGeneratedLine < pendingGeneratedLine);
                lastGeneratedCharacter = 0;
            }
            else {
                ts.Debug.assertEqual(lastGeneratedLine, pendingGeneratedLine, "generatedLine cannot backtrack");
                if (hasLast) {
                    appendMappingCharCode(44);
                }
            }
            appendBase64VLQ(pendingGeneratedCharacter - lastGeneratedCharacter);
            lastGeneratedCharacter = pendingGeneratedCharacter;
            if (hasPendingSource) {
                appendBase64VLQ(pendingSourceIndex - lastSourceIndex);
                lastSourceIndex = pendingSourceIndex;
                appendBase64VLQ(pendingSourceLine - lastSourceLine);
                lastSourceLine = pendingSourceLine;
                appendBase64VLQ(pendingSourceCharacter - lastSourceCharacter);
                lastSourceCharacter = pendingSourceCharacter;
                if (hasPendingName) {
                    appendBase64VLQ(pendingNameIndex - lastNameIndex);
                    lastNameIndex = pendingNameIndex;
                }
            }
            hasLast = true;
            exit();
        }
        function flushMappingBuffer() {
            if (mappingCharCodes.length > 0) {
                mappings += String.fromCharCode.apply(undefined, mappingCharCodes);
                mappingCharCodes.length = 0;
            }
        }
        function toJSON() {
            commitPendingMapping();
            flushMappingBuffer();
            return {
                version: 3,
                file: file,
                sourceRoot: sourceRoot,
                sources: sources,
                names: names,
                mappings: mappings,
                sourcesContent: sourcesContent,
            };
        }
        function appendBase64VLQ(inValue) {
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            }
            else {
                inValue = inValue << 1;
            }
            do {
                var currentDigit = inValue & 31;
                inValue = inValue >> 5;
                if (inValue > 0) {
                    currentDigit = currentDigit | 32;
                }
                appendMappingCharCode(base64FormatEncode(currentDigit));
            } while (inValue > 0);
        }
    }
    ts.createSourceMapGenerator = createSourceMapGenerator;
    var sourceMapCommentRegExp = /^\/\/[@#] source[M]appingURL=(.+)\r?\n?$/;
    var whitespaceOrMapCommentRegExp = /^\s*(\/\/[@#] .*)?$/;
    function getLineInfo(text, lineStarts) {
        return {
            getLineCount: function () { return lineStarts.length; },
            getLineText: function (line) { return text.substring(lineStarts[line], lineStarts[line + 1]); }
        };
    }
    ts.getLineInfo = getLineInfo;
    function tryGetSourceMappingURL(lineInfo) {
        for (var index = lineInfo.getLineCount() - 1; index >= 0; index--) {
            var line = lineInfo.getLineText(index);
            var comment = sourceMapCommentRegExp.exec(line);
            if (comment) {
                return ts.trimStringEnd(comment[1]);
            }
            else if (!line.match(whitespaceOrMapCommentRegExp)) {
                break;
            }
        }
    }
    ts.tryGetSourceMappingURL = tryGetSourceMappingURL;
    function isStringOrNull(x) {
        return typeof x === "string" || x === null;
    }
    function isRawSourceMap(x) {
        return x !== null
            && typeof x === "object"
            && x.version === 3
            && typeof x.file === "string"
            && typeof x.mappings === "string"
            && ts.isArray(x.sources) && ts.every(x.sources, ts.isString)
            && (x.sourceRoot === undefined || x.sourceRoot === null || typeof x.sourceRoot === "string")
            && (x.sourcesContent === undefined || x.sourcesContent === null || ts.isArray(x.sourcesContent) && ts.every(x.sourcesContent, isStringOrNull))
            && (x.names === undefined || x.names === null || ts.isArray(x.names) && ts.every(x.names, ts.isString));
    }
    ts.isRawSourceMap = isRawSourceMap;
    function tryParseRawSourceMap(text) {
        try {
            var parsed = JSON.parse(text);
            if (isRawSourceMap(parsed)) {
                return parsed;
            }
        }
        catch (_a) {
        }
        return undefined;
    }
    ts.tryParseRawSourceMap = tryParseRawSourceMap;
    function decodeMappings(mappings) {
        var done = false;
        var pos = 0;
        var generatedLine = 0;
        var generatedCharacter = 0;
        var sourceIndex = 0;
        var sourceLine = 0;
        var sourceCharacter = 0;
        var nameIndex = 0;
        var error;
        return {
            get pos() { return pos; },
            get error() { return error; },
            get state() { return captureMapping(true, true); },
            next: function () {
                while (!done && pos < mappings.length) {
                    var ch = mappings.charCodeAt(pos);
                    if (ch === 59) {
                        generatedLine++;
                        generatedCharacter = 0;
                        pos++;
                        continue;
                    }
                    if (ch === 44) {
                        pos++;
                        continue;
                    }
                    var hasSource = false;
                    var hasName = false;
                    generatedCharacter += base64VLQFormatDecode();
                    if (hasReportedError())
                        return stopIterating();
                    if (generatedCharacter < 0)
                        return setErrorAndStopIterating("Invalid generatedCharacter found");
                    if (!isSourceMappingSegmentEnd()) {
                        hasSource = true;
                        sourceIndex += base64VLQFormatDecode();
                        if (hasReportedError())
                            return stopIterating();
                        if (sourceIndex < 0)
                            return setErrorAndStopIterating("Invalid sourceIndex found");
                        if (isSourceMappingSegmentEnd())
                            return setErrorAndStopIterating("Unsupported Format: No entries after sourceIndex");
                        sourceLine += base64VLQFormatDecode();
                        if (hasReportedError())
                            return stopIterating();
                        if (sourceLine < 0)
                            return setErrorAndStopIterating("Invalid sourceLine found");
                        if (isSourceMappingSegmentEnd())
                            return setErrorAndStopIterating("Unsupported Format: No entries after sourceLine");
                        sourceCharacter += base64VLQFormatDecode();
                        if (hasReportedError())
                            return stopIterating();
                        if (sourceCharacter < 0)
                            return setErrorAndStopIterating("Invalid sourceCharacter found");
                        if (!isSourceMappingSegmentEnd()) {
                            hasName = true;
                            nameIndex += base64VLQFormatDecode();
                            if (hasReportedError())
                                return stopIterating();
                            if (nameIndex < 0)
                                return setErrorAndStopIterating("Invalid nameIndex found");
                            if (!isSourceMappingSegmentEnd())
                                return setErrorAndStopIterating("Unsupported Error Format: Entries after nameIndex");
                        }
                    }
                    return { value: captureMapping(hasSource, hasName), done: done };
                }
                return stopIterating();
            }
        };
        function captureMapping(hasSource, hasName) {
            return {
                generatedLine: generatedLine,
                generatedCharacter: generatedCharacter,
                sourceIndex: hasSource ? sourceIndex : undefined,
                sourceLine: hasSource ? sourceLine : undefined,
                sourceCharacter: hasSource ? sourceCharacter : undefined,
                nameIndex: hasName ? nameIndex : undefined
            };
        }
        function stopIterating() {
            done = true;
            return { value: undefined, done: true };
        }
        function setError(message) {
            if (error === undefined) {
                error = message;
            }
        }
        function setErrorAndStopIterating(message) {
            setError(message);
            return stopIterating();
        }
        function hasReportedError() {
            return error !== undefined;
        }
        function isSourceMappingSegmentEnd() {
            return (pos === mappings.length ||
                mappings.charCodeAt(pos) === 44 ||
                mappings.charCodeAt(pos) === 59);
        }
        function base64VLQFormatDecode() {
            var moreDigits = true;
            var shiftCount = 0;
            var value = 0;
            for (; moreDigits; pos++) {
                if (pos >= mappings.length)
                    return setError("Error in decoding base64VLQFormatDecode, past the mapping string"), -1;
                var currentByte = base64FormatDecode(mappings.charCodeAt(pos));
                if (currentByte === -1)
                    return setError("Invalid character in VLQ"), -1;
                moreDigits = (currentByte & 32) !== 0;
                value = value | ((currentByte & 31) << shiftCount);
                shiftCount += 5;
            }
            if ((value & 1) === 0) {
                value = value >> 1;
            }
            else {
                value = value >> 1;
                value = -value;
            }
            return value;
        }
    }
    ts.decodeMappings = decodeMappings;
    function sameMapping(left, right) {
        return left === right
            || left.generatedLine === right.generatedLine
                && left.generatedCharacter === right.generatedCharacter
                && left.sourceIndex === right.sourceIndex
                && left.sourceLine === right.sourceLine
                && left.sourceCharacter === right.sourceCharacter
                && left.nameIndex === right.nameIndex;
    }
    ts.sameMapping = sameMapping;
    function isSourceMapping(mapping) {
        return mapping.sourceIndex !== undefined
            && mapping.sourceLine !== undefined
            && mapping.sourceCharacter !== undefined;
    }
    ts.isSourceMapping = isSourceMapping;
    function base64FormatEncode(value) {
        return value >= 0 && value < 26 ? 65 + value :
            value >= 26 && value < 52 ? 97 + value - 26 :
                value >= 52 && value < 62 ? 48 + value - 52 :
                    value === 62 ? 43 :
                        value === 63 ? 47 :
                            ts.Debug.fail("".concat(value, ": not a base64 value"));
    }
    function base64FormatDecode(ch) {
        return ch >= 65 && ch <= 90 ? ch - 65 :
            ch >= 97 && ch <= 122 ? ch - 97 + 26 :
                ch >= 48 && ch <= 57 ? ch - 48 + 52 :
                    ch === 43 ? 62 :
                        ch === 47 ? 63 :
                            -1;
    }
    function isSourceMappedPosition(value) {
        return value.sourceIndex !== undefined
            && value.sourcePosition !== undefined;
    }
    function sameMappedPosition(left, right) {
        return left.generatedPosition === right.generatedPosition
            && left.sourceIndex === right.sourceIndex
            && left.sourcePosition === right.sourcePosition;
    }
    function compareSourcePositions(left, right) {
        ts.Debug.assert(left.sourceIndex === right.sourceIndex);
        return ts.compareValues(left.sourcePosition, right.sourcePosition);
    }
    function compareGeneratedPositions(left, right) {
        return ts.compareValues(left.generatedPosition, right.generatedPosition);
    }
    function getSourcePositionOfMapping(value) {
        return value.sourcePosition;
    }
    function getGeneratedPositionOfMapping(value) {
        return value.generatedPosition;
    }
    function createDocumentPositionMapper(host, map, mapPath) {
        var mapDirectory = ts.getDirectoryPath(mapPath);
        var sourceRoot = map.sourceRoot ? ts.getNormalizedAbsolutePath(map.sourceRoot, mapDirectory) : mapDirectory;
        var generatedAbsoluteFilePath = ts.getNormalizedAbsolutePath(map.file, mapDirectory);
        var generatedFile = host.getSourceFileLike(generatedAbsoluteFilePath);
        var sourceFileAbsolutePaths = map.sources.map(function (source) { return ts.getNormalizedAbsolutePath(source, sourceRoot); });
        var sourceToSourceIndexMap = new ts.Map(sourceFileAbsolutePaths.map(function (source, i) { return [host.getCanonicalFileName(source), i]; }));
        var decodedMappings;
        var generatedMappings;
        var sourceMappings;
        return {
            getSourcePosition: getSourcePosition,
            getGeneratedPosition: getGeneratedPosition
        };
        function processMapping(mapping) {
            var generatedPosition = generatedFile !== undefined
                ? ts.getPositionOfLineAndCharacter(generatedFile, mapping.generatedLine, mapping.generatedCharacter, true)
                : -1;
            var source;
            var sourcePosition;
            if (isSourceMapping(mapping)) {
                var sourceFile = host.getSourceFileLike(sourceFileAbsolutePaths[mapping.sourceIndex]);
                source = map.sources[mapping.sourceIndex];
                sourcePosition = sourceFile !== undefined
                    ? ts.getPositionOfLineAndCharacter(sourceFile, mapping.sourceLine, mapping.sourceCharacter, true)
                    : -1;
            }
            return {
                generatedPosition: generatedPosition,
                source: source,
                sourceIndex: mapping.sourceIndex,
                sourcePosition: sourcePosition,
                nameIndex: mapping.nameIndex
            };
        }
        function getDecodedMappings() {
            if (decodedMappings === undefined) {
                var decoder = decodeMappings(map.mappings);
                var mappings = ts.arrayFrom(decoder, processMapping);
                if (decoder.error !== undefined) {
                    if (host.log) {
                        host.log("Encountered error while decoding sourcemap: ".concat(decoder.error));
                    }
                    decodedMappings = ts.emptyArray;
                }
                else {
                    decodedMappings = mappings;
                }
            }
            return decodedMappings;
        }
        function getSourceMappings(sourceIndex) {
            if (sourceMappings === undefined) {
                var lists = [];
                for (var _i = 0, _a = getDecodedMappings(); _i < _a.length; _i++) {
                    var mapping = _a[_i];
                    if (!isSourceMappedPosition(mapping))
                        continue;
                    var list = lists[mapping.sourceIndex];
                    if (!list)
                        lists[mapping.sourceIndex] = list = [];
                    list.push(mapping);
                }
                sourceMappings = lists.map(function (list) { return ts.sortAndDeduplicate(list, compareSourcePositions, sameMappedPosition); });
            }
            return sourceMappings[sourceIndex];
        }
        function getGeneratedMappings() {
            if (generatedMappings === undefined) {
                var list = [];
                for (var _i = 0, _a = getDecodedMappings(); _i < _a.length; _i++) {
                    var mapping = _a[_i];
                    list.push(mapping);
                }
                generatedMappings = ts.sortAndDeduplicate(list, compareGeneratedPositions, sameMappedPosition);
            }
            return generatedMappings;
        }
        function getGeneratedPosition(loc) {
            var sourceIndex = sourceToSourceIndexMap.get(host.getCanonicalFileName(loc.fileName));
            if (sourceIndex === undefined)
                return loc;
            var sourceMappings = getSourceMappings(sourceIndex);
            if (!ts.some(sourceMappings))
                return loc;
            var targetIndex = ts.binarySearchKey(sourceMappings, loc.pos, getSourcePositionOfMapping, ts.compareValues);
            if (targetIndex < 0) {
                targetIndex = ~targetIndex;
            }
            var mapping = sourceMappings[targetIndex];
            if (mapping === undefined || mapping.sourceIndex !== sourceIndex) {
                return loc;
            }
            return { fileName: generatedAbsoluteFilePath, pos: mapping.generatedPosition };
        }
        function getSourcePosition(loc) {
            var generatedMappings = getGeneratedMappings();
            if (!ts.some(generatedMappings))
                return loc;
            var targetIndex = ts.binarySearchKey(generatedMappings, loc.pos, getGeneratedPositionOfMapping, ts.compareValues);
            if (targetIndex < 0) {
                targetIndex = ~targetIndex;
            }
            var mapping = generatedMappings[targetIndex];
            if (mapping === undefined || !isSourceMappedPosition(mapping)) {
                return loc;
            }
            return { fileName: sourceFileAbsolutePaths[mapping.sourceIndex], pos: mapping.sourcePosition };
        }
    }
    ts.createDocumentPositionMapper = createDocumentPositionMapper;
    ts.identitySourceMapConsumer = {
        getSourcePosition: ts.identity,
        getGeneratedPosition: ts.identity
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    function getOriginalNodeId(node) {
        node = ts.getOriginalNode(node);
        return node ? ts.getNodeId(node) : 0;
    }
    ts.getOriginalNodeId = getOriginalNodeId;
    function containsDefaultReference(node) {
        if (!node)
            return false;
        if (!ts.isNamedImports(node))
            return false;
        return ts.some(node.elements, isNamedDefaultReference);
    }
    function isNamedDefaultReference(e) {
        return e.propertyName !== undefined && e.propertyName.escapedText === "default";
    }
    function chainBundle(context, transformSourceFile) {
        return transformSourceFileOrBundle;
        function transformSourceFileOrBundle(node) {
            return node.kind === 308 ? transformSourceFile(node) : transformBundle(node);
        }
        function transformBundle(node) {
            return context.factory.createBundle(ts.map(node.sourceFiles, transformSourceFile), node.prepends);
        }
    }
    ts.chainBundle = chainBundle;
    function getExportNeedsImportStarHelper(node) {
        return !!ts.getNamespaceDeclarationNode(node);
    }
    ts.getExportNeedsImportStarHelper = getExportNeedsImportStarHelper;
    function getImportNeedsImportStarHelper(node) {
        if (!!ts.getNamespaceDeclarationNode(node)) {
            return true;
        }
        var bindings = node.importClause && node.importClause.namedBindings;
        if (!bindings) {
            return false;
        }
        if (!ts.isNamedImports(bindings))
            return false;
        var defaultRefCount = 0;
        for (var _i = 0, _a = bindings.elements; _i < _a.length; _i++) {
            var binding = _a[_i];
            if (isNamedDefaultReference(binding)) {
                defaultRefCount++;
            }
        }
        return (defaultRefCount > 0 && defaultRefCount !== bindings.elements.length) || (!!(bindings.elements.length - defaultRefCount) && ts.isDefaultImport(node));
    }
    ts.getImportNeedsImportStarHelper = getImportNeedsImportStarHelper;
    function getImportNeedsImportDefaultHelper(node) {
        return !getImportNeedsImportStarHelper(node) && (ts.isDefaultImport(node) || (!!node.importClause && ts.isNamedImports(node.importClause.namedBindings) && containsDefaultReference(node.importClause.namedBindings)));
    }
    ts.getImportNeedsImportDefaultHelper = getImportNeedsImportDefaultHelper;
    function collectExternalModuleInfo(context, sourceFile, resolver, compilerOptions) {
        var externalImports = [];
        var exportSpecifiers = ts.createMultiMap();
        var exportedBindings = [];
        var uniqueExports = new ts.Map();
        var exportedNames;
        var hasExportDefault = false;
        var exportEquals;
        var hasExportStarsToExportValues = false;
        var hasImportStar = false;
        var hasImportDefault = false;
        for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {
            var node = _a[_i];
            switch (node.kind) {
                case 269:
                    externalImports.push(node);
                    if (!hasImportStar && getImportNeedsImportStarHelper(node)) {
                        hasImportStar = true;
                    }
                    if (!hasImportDefault && getImportNeedsImportDefaultHelper(node)) {
                        hasImportDefault = true;
                    }
                    break;
                case 268:
                    if (node.moduleReference.kind === 280) {
                        externalImports.push(node);
                    }
                    break;
                case 275:
                    if (node.moduleSpecifier) {
                        if (!node.exportClause) {
                            externalImports.push(node);
                            hasExportStarsToExportValues = true;
                        }
                        else {
                            externalImports.push(node);
                            if (ts.isNamedExports(node.exportClause)) {
                                addExportedNamesForExportDeclaration(node);
                            }
                            else {
                                var name = node.exportClause.name;
                                if (!uniqueExports.get(ts.idText(name))) {
                                    multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), name);
                                    uniqueExports.set(ts.idText(name), true);
                                    exportedNames = ts.append(exportedNames, name);
                                }
                                hasImportStar = true;
                            }
                        }
                    }
                    else {
                        addExportedNamesForExportDeclaration(node);
                    }
                    break;
                case 274:
                    if (node.isExportEquals && !exportEquals) {
                        exportEquals = node;
                    }
                    break;
                case 240:
                    if (ts.hasSyntacticModifier(node, 1)) {
                        for (var _b = 0, _c = node.declarationList.declarations; _b < _c.length; _b++) {
                            var decl = _c[_b];
                            exportedNames = collectExportedVariableInfo(decl, uniqueExports, exportedNames);
                        }
                    }
                    break;
                case 259:
                    if (ts.hasSyntacticModifier(node, 1)) {
                        if (ts.hasSyntacticModifier(node, 1024)) {
                            if (!hasExportDefault) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), context.factory.getDeclarationName(node));
                                hasExportDefault = true;
                            }
                        }
                        else {
                            var name = node.name;
                            if (!uniqueExports.get(ts.idText(name))) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), name);
                                uniqueExports.set(ts.idText(name), true);
                                exportedNames = ts.append(exportedNames, name);
                            }
                        }
                    }
                    break;
                case 260:
                    if (ts.hasSyntacticModifier(node, 1)) {
                        if (ts.hasSyntacticModifier(node, 1024)) {
                            if (!hasExportDefault) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), context.factory.getDeclarationName(node));
                                hasExportDefault = true;
                            }
                        }
                        else {
                            var name = node.name;
                            if (name && !uniqueExports.get(ts.idText(name))) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), name);
                                uniqueExports.set(ts.idText(name), true);
                                exportedNames = ts.append(exportedNames, name);
                            }
                        }
                    }
                    break;
            }
        }
        var externalHelpersImportDeclaration = ts.createExternalHelpersImportDeclarationIfNeeded(context.factory, context.getEmitHelperFactory(), sourceFile, compilerOptions, hasExportStarsToExportValues, hasImportStar, hasImportDefault);
        if (externalHelpersImportDeclaration) {
            externalImports.unshift(externalHelpersImportDeclaration);
        }
        return { externalImports: externalImports, exportSpecifiers: exportSpecifiers, exportEquals: exportEquals, hasExportStarsToExportValues: hasExportStarsToExportValues, exportedBindings: exportedBindings, exportedNames: exportedNames, externalHelpersImportDeclaration: externalHelpersImportDeclaration };
        function addExportedNamesForExportDeclaration(node) {
            for (var _i = 0, _a = ts.cast(node.exportClause, ts.isNamedExports).elements; _i < _a.length; _i++) {
                var specifier = _a[_i];
                if (!uniqueExports.get(ts.idText(specifier.name))) {
                    var name = specifier.propertyName || specifier.name;
                    if (!node.moduleSpecifier) {
                        exportSpecifiers.add(ts.idText(name), specifier);
                    }
                    var decl = resolver.getReferencedImportDeclaration(name)
                        || resolver.getReferencedValueDeclaration(name);
                    if (decl) {
                        multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(decl), specifier.name);
                    }
                    uniqueExports.set(ts.idText(specifier.name), true);
                    exportedNames = ts.append(exportedNames, specifier.name);
                }
            }
        }
    }
    ts.collectExternalModuleInfo = collectExternalModuleInfo;
    function collectExportedVariableInfo(decl, uniqueExports, exportedNames) {
        if (ts.isBindingPattern(decl.name)) {
            for (var _i = 0, _a = decl.name.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                if (!ts.isOmittedExpression(element)) {
                    exportedNames = collectExportedVariableInfo(element, uniqueExports, exportedNames);
                }
            }
        }
        else if (!ts.isGeneratedIdentifier(decl.name)) {
            var text = ts.idText(decl.name);
            if (!uniqueExports.get(text)) {
                uniqueExports.set(text, true);
                exportedNames = ts.append(exportedNames, decl.name);
            }
        }
        return exportedNames;
    }
    function multiMapSparseArrayAdd(map, key, value) {
        var values = map[key];
        if (values) {
            values.push(value);
        }
        else {
            map[key] = values = [value];
        }
        return values;
    }
    function isSimpleCopiableExpression(expression) {
        return ts.isStringLiteralLike(expression) ||
            expression.kind === 8 ||
            ts.isKeyword(expression.kind) ||
            ts.isIdentifier(expression);
    }
    ts.isSimpleCopiableExpression = isSimpleCopiableExpression;
    function isSimpleInlineableExpression(expression) {
        return !ts.isIdentifier(expression) && isSimpleCopiableExpression(expression);
    }
    ts.isSimpleInlineableExpression = isSimpleInlineableExpression;
    function isCompoundAssignment(kind) {
        return kind >= 64
            && kind <= 78;
    }
    ts.isCompoundAssignment = isCompoundAssignment;
    function getNonAssignmentOperatorForCompoundAssignment(kind) {
        switch (kind) {
            case 64: return 39;
            case 65: return 40;
            case 66: return 41;
            case 67: return 42;
            case 68: return 43;
            case 69: return 44;
            case 70: return 47;
            case 71: return 48;
            case 72: return 49;
            case 73: return 50;
            case 74: return 51;
            case 78: return 52;
            case 75: return 56;
            case 76: return 55;
            case 77: return 60;
        }
    }
    ts.getNonAssignmentOperatorForCompoundAssignment = getNonAssignmentOperatorForCompoundAssignment;
    function getSuperCallFromStatement(statement) {
        if (!ts.isExpressionStatement(statement)) {
            return undefined;
        }
        var expression = ts.skipParentheses(statement.expression);
        return ts.isSuperCall(expression)
            ? expression
            : undefined;
    }
    ts.getSuperCallFromStatement = getSuperCallFromStatement;
    function findSuperStatementIndex(statements, indexAfterLastPrologueStatement) {
        for (var i = indexAfterLastPrologueStatement; i < statements.length; i += 1) {
            var statement = statements[i];
            if (getSuperCallFromStatement(statement)) {
                return i;
            }
        }
        return -1;
    }
    ts.findSuperStatementIndex = findSuperStatementIndex;
    function getProperties(node, requireInitializer, isStatic) {
        return ts.filter(node.members, function (m) { return isInitializedOrStaticProperty(m, requireInitializer, isStatic); });
    }
    ts.getProperties = getProperties;
    function isStaticPropertyDeclarationOrClassStaticBlockDeclaration(element) {
        return isStaticPropertyDeclaration(element) || ts.isClassStaticBlockDeclaration(element);
    }
    function getStaticPropertiesAndClassStaticBlock(node) {
        return ts.filter(node.members, isStaticPropertyDeclarationOrClassStaticBlockDeclaration);
    }
    ts.getStaticPropertiesAndClassStaticBlock = getStaticPropertiesAndClassStaticBlock;
    function isInitializedOrStaticProperty(member, requireInitializer, isStatic) {
        return ts.isPropertyDeclaration(member)
            && (!!member.initializer || !requireInitializer)
            && ts.hasStaticModifier(member) === isStatic;
    }
    function isStaticPropertyDeclaration(member) {
        return ts.isPropertyDeclaration(member) && ts.hasStaticModifier(member);
    }
    function isInitializedProperty(member) {
        return member.kind === 169
            && member.initializer !== undefined;
    }
    ts.isInitializedProperty = isInitializedProperty;
    function isNonStaticMethodOrAccessorWithPrivateName(member) {
        return !ts.isStatic(member) && (ts.isMethodOrAccessor(member) || ts.isAutoAccessorPropertyDeclaration(member)) && ts.isPrivateIdentifier(member.name);
    }
    ts.isNonStaticMethodOrAccessorWithPrivateName = isNonStaticMethodOrAccessorWithPrivateName;
    function getDecoratorsOfParameters(node) {
        var decorators;
        if (node) {
            var parameters = node.parameters;
            var firstParameterIsThis = parameters.length > 0 && ts.parameterIsThisKeyword(parameters[0]);
            var firstParameterOffset = firstParameterIsThis ? 1 : 0;
            var numParameters = firstParameterIsThis ? parameters.length - 1 : parameters.length;
            for (var i = 0; i < numParameters; i++) {
                var parameter = parameters[i + firstParameterOffset];
                if (decorators || ts.hasDecorators(parameter)) {
                    if (!decorators) {
                        decorators = new Array(numParameters);
                    }
                    decorators[i] = ts.getDecorators(parameter);
                }
            }
        }
        return decorators;
    }
    function getAllDecoratorsOfClass(node) {
        var decorators = ts.getDecorators(node);
        var parameters = getDecoratorsOfParameters(ts.getFirstConstructorWithBody(node));
        if (!ts.some(decorators) && !ts.some(parameters)) {
            return undefined;
        }
        return {
            decorators: decorators,
            parameters: parameters
        };
    }
    ts.getAllDecoratorsOfClass = getAllDecoratorsOfClass;
    function getAllDecoratorsOfClassElement(member, parent) {
        switch (member.kind) {
            case 174:
            case 175:
                return getAllDecoratorsOfAccessors(member, parent);
            case 171:
                return getAllDecoratorsOfMethod(member);
            case 169:
                return getAllDecoratorsOfProperty(member);
            default:
                return undefined;
        }
    }
    ts.getAllDecoratorsOfClassElement = getAllDecoratorsOfClassElement;
    function getAllDecoratorsOfAccessors(accessor, parent) {
        if (!accessor.body) {
            return undefined;
        }
        var _a = ts.getAllAccessorDeclarations(parent.members, accessor), firstAccessor = _a.firstAccessor, secondAccessor = _a.secondAccessor, getAccessor = _a.getAccessor, setAccessor = _a.setAccessor;
        var firstAccessorWithDecorators = ts.hasDecorators(firstAccessor) ? firstAccessor :
            secondAccessor && ts.hasDecorators(secondAccessor) ? secondAccessor :
                undefined;
        if (!firstAccessorWithDecorators || accessor !== firstAccessorWithDecorators) {
            return undefined;
        }
        var decorators = ts.getDecorators(firstAccessorWithDecorators);
        var parameters = getDecoratorsOfParameters(setAccessor);
        if (!ts.some(decorators) && !ts.some(parameters)) {
            return undefined;
        }
        return {
            decorators: decorators,
            parameters: parameters,
            getDecorators: getAccessor && ts.getDecorators(getAccessor),
            setDecorators: setAccessor && ts.getDecorators(setAccessor)
        };
    }
    function getAllDecoratorsOfMethod(method) {
        if (!method.body) {
            return undefined;
        }
        var decorators = ts.getDecorators(method);
        var parameters = getDecoratorsOfParameters(method);
        if (!ts.some(decorators) && !ts.some(parameters)) {
            return undefined;
        }
        return { decorators: decorators, parameters: parameters };
    }
    function getAllDecoratorsOfProperty(property) {
        var decorators = ts.getDecorators(property);
        if (!ts.some(decorators)) {
            return undefined;
        }
        return { decorators: decorators };
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function flattenDestructuringAssignment(node, visitor, context, level, needsValue, createAssignmentCallback) {
        var location = node;
        var value;
        if (ts.isDestructuringAssignment(node)) {
            value = node.right;
            while (ts.isEmptyArrayLiteral(node.left) || ts.isEmptyObjectLiteral(node.left)) {
                if (ts.isDestructuringAssignment(value)) {
                    location = node = value;
                    value = node.right;
                }
                else {
                    return ts.visitNode(value, visitor, ts.isExpression);
                }
            }
        }
        var expressions;
        var flattenContext = {
            context: context,
            level: level,
            downlevelIteration: !!context.getCompilerOptions().downlevelIteration,
            hoistTempVariables: true,
            emitExpression: emitExpression,
            emitBindingOrAssignment: emitBindingOrAssignment,
            createArrayBindingOrAssignmentPattern: function (elements) { return makeArrayAssignmentPattern(context.factory, elements); },
            createObjectBindingOrAssignmentPattern: function (elements) { return makeObjectAssignmentPattern(context.factory, elements); },
            createArrayBindingOrAssignmentElement: makeAssignmentElement,
            visitor: visitor
        };
        if (value) {
            value = ts.visitNode(value, visitor, ts.isExpression);
            if (ts.isIdentifier(value) && bindingOrAssignmentElementAssignsToName(node, value.escapedText) ||
                bindingOrAssignmentElementContainsNonLiteralComputedName(node)) {
                value = ensureIdentifier(flattenContext, value, false, location);
            }
            else if (needsValue) {
                value = ensureIdentifier(flattenContext, value, true, location);
            }
            else if (ts.nodeIsSynthesized(node)) {
                location = value;
            }
        }
        flattenBindingOrAssignmentElement(flattenContext, node, value, location, ts.isDestructuringAssignment(node));
        if (value && needsValue) {
            if (!ts.some(expressions)) {
                return value;
            }
            expressions.push(value);
        }
        return context.factory.inlineExpressions(expressions) || context.factory.createOmittedExpression();
        function emitExpression(expression) {
            expressions = ts.append(expressions, expression);
        }
        function emitBindingOrAssignment(target, value, location, original) {
            ts.Debug.assertNode(target, createAssignmentCallback ? ts.isIdentifier : ts.isExpression);
            var expression = createAssignmentCallback
                ? createAssignmentCallback(target, value, location)
                : ts.setTextRange(context.factory.createAssignment(ts.visitNode(target, visitor, ts.isExpression), value), location);
            expression.original = original;
            emitExpression(expression);
        }
    }
    ts.flattenDestructuringAssignment = flattenDestructuringAssignment;
    function bindingOrAssignmentElementAssignsToName(element, escapedName) {
        var target = ts.getTargetOfBindingOrAssignmentElement(element);
        if (ts.isBindingOrAssignmentPattern(target)) {
            return bindingOrAssignmentPatternAssignsToName(target, escapedName);
        }
        else if (ts.isIdentifier(target)) {
            return target.escapedText === escapedName;
        }
        return false;
    }
    function bindingOrAssignmentPatternAssignsToName(pattern, escapedName) {
        var elements = ts.getElementsOfBindingOrAssignmentPattern(pattern);
        for (var _i = 0, elements_4 = elements; _i < elements_4.length; _i++) {
            var element = elements_4[_i];
            if (bindingOrAssignmentElementAssignsToName(element, escapedName)) {
                return true;
            }
        }
        return false;
    }
    function bindingOrAssignmentElementContainsNonLiteralComputedName(element) {
        var propertyName = ts.tryGetPropertyNameOfBindingOrAssignmentElement(element);
        if (propertyName && ts.isComputedPropertyName(propertyName) && !ts.isLiteralExpression(propertyName.expression)) {
            return true;
        }
        var target = ts.getTargetOfBindingOrAssignmentElement(element);
        return !!target && ts.isBindingOrAssignmentPattern(target) && bindingOrAssignmentPatternContainsNonLiteralComputedName(target);
    }
    function bindingOrAssignmentPatternContainsNonLiteralComputedName(pattern) {
        return !!ts.forEach(ts.getElementsOfBindingOrAssignmentPattern(pattern), bindingOrAssignmentElementContainsNonLiteralComputedName);
    }
    function flattenDestructuringBinding(node, visitor, context, level, rval, hoistTempVariables, skipInitializer) {
        if (hoistTempVariables === void 0) { hoistTempVariables = false; }
        var pendingExpressions;
        var pendingDeclarations = [];
        var declarations = [];
        var flattenContext = {
            context: context,
            level: level,
            downlevelIteration: !!context.getCompilerOptions().downlevelIteration,
            hoistTempVariables: hoistTempVariables,
            emitExpression: emitExpression,
            emitBindingOrAssignment: emitBindingOrAssignment,
            createArrayBindingOrAssignmentPattern: function (elements) { return makeArrayBindingPattern(context.factory, elements); },
            createObjectBindingOrAssignmentPattern: function (elements) { return makeObjectBindingPattern(context.factory, elements); },
            createArrayBindingOrAssignmentElement: function (name) { return makeBindingElement(context.factory, name); },
            visitor: visitor
        };
        if (ts.isVariableDeclaration(node)) {
            var initializer = ts.getInitializerOfBindingOrAssignmentElement(node);
            if (initializer && (ts.isIdentifier(initializer) && bindingOrAssignmentElementAssignsToName(node, initializer.escapedText) ||
                bindingOrAssignmentElementContainsNonLiteralComputedName(node))) {
                initializer = ensureIdentifier(flattenContext, ts.visitNode(initializer, flattenContext.visitor), false, initializer);
                node = context.factory.updateVariableDeclaration(node, node.name, undefined, undefined, initializer);
            }
        }
        flattenBindingOrAssignmentElement(flattenContext, node, rval, node, skipInitializer);
        if (pendingExpressions) {
            var temp = context.factory.createTempVariable(undefined);
            if (hoistTempVariables) {
                var value = context.factory.inlineExpressions(pendingExpressions);
                pendingExpressions = undefined;
                emitBindingOrAssignment(temp, value, undefined, undefined);
            }
            else {
                context.hoistVariableDeclaration(temp);
                var pendingDeclaration = ts.last(pendingDeclarations);
                pendingDeclaration.pendingExpressions = ts.append(pendingDeclaration.pendingExpressions, context.factory.createAssignment(temp, pendingDeclaration.value));
                ts.addRange(pendingDeclaration.pendingExpressions, pendingExpressions);
                pendingDeclaration.value = temp;
            }
        }
        for (var _i = 0, pendingDeclarations_1 = pendingDeclarations; _i < pendingDeclarations_1.length; _i++) {
            var _a = pendingDeclarations_1[_i], pendingExpressions_1 = _a.pendingExpressions, name = _a.name, value = _a.value, location = _a.location, original = _a.original;
            var variable = context.factory.createVariableDeclaration(name, undefined, undefined, pendingExpressions_1 ? context.factory.inlineExpressions(ts.append(pendingExpressions_1, value)) : value);
            variable.original = original;
            ts.setTextRange(variable, location);
            declarations.push(variable);
        }
        return declarations;
        function emitExpression(value) {
            pendingExpressions = ts.append(pendingExpressions, value);
        }
        function emitBindingOrAssignment(target, value, location, original) {
            ts.Debug.assertNode(target, ts.isBindingName);
            if (pendingExpressions) {
                value = context.factory.inlineExpressions(ts.append(pendingExpressions, value));
                pendingExpressions = undefined;
            }
            pendingDeclarations.push({ pendingExpressions: pendingExpressions, name: target, value: value, location: location, original: original });
        }
    }
    ts.flattenDestructuringBinding = flattenDestructuringBinding;
    function flattenBindingOrAssignmentElement(flattenContext, element, value, location, skipInitializer) {
        var bindingTarget = ts.getTargetOfBindingOrAssignmentElement(element);
        if (!skipInitializer) {
            var initializer = ts.visitNode(ts.getInitializerOfBindingOrAssignmentElement(element), flattenContext.visitor, ts.isExpression);
            if (initializer) {
                if (value) {
                    value = createDefaultValueCheck(flattenContext, value, initializer, location);
                    if (!ts.isSimpleInlineableExpression(initializer) && ts.isBindingOrAssignmentPattern(bindingTarget)) {
                        value = ensureIdentifier(flattenContext, value, true, location);
                    }
                }
                else {
                    value = initializer;
                }
            }
            else if (!value) {
                value = flattenContext.context.factory.createVoidZero();
            }
        }
        if (ts.isObjectBindingOrAssignmentPattern(bindingTarget)) {
            flattenObjectBindingOrAssignmentPattern(flattenContext, element, bindingTarget, value, location);
        }
        else if (ts.isArrayBindingOrAssignmentPattern(bindingTarget)) {
            flattenArrayBindingOrAssignmentPattern(flattenContext, element, bindingTarget, value, location);
        }
        else {
            flattenContext.emitBindingOrAssignment(bindingTarget, value, location, element);
        }
    }
    function flattenObjectBindingOrAssignmentPattern(flattenContext, parent, pattern, value, location) {
        var elements = ts.getElementsOfBindingOrAssignmentPattern(pattern);
        var numElements = elements.length;
        if (numElements !== 1) {
            var reuseIdentifierExpressions = !ts.isDeclarationBindingElement(parent) || numElements !== 0;
            value = ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location);
        }
        var bindingElements;
        var computedTempVariables;
        for (var i = 0; i < numElements; i++) {
            var element = elements[i];
            if (!ts.getRestIndicatorOfBindingOrAssignmentElement(element)) {
                var propertyName = ts.getPropertyNameOfBindingOrAssignmentElement(element);
                if (flattenContext.level >= 1
                    && !(element.transformFlags & (32768 | 65536))
                    && !(ts.getTargetOfBindingOrAssignmentElement(element).transformFlags & (32768 | 65536))
                    && !ts.isComputedPropertyName(propertyName)) {
                    bindingElements = ts.append(bindingElements, ts.visitNode(element, flattenContext.visitor));
                }
                else {
                    if (bindingElements) {
                        flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
                        bindingElements = undefined;
                    }
                    var rhsValue = createDestructuringPropertyAccess(flattenContext, value, propertyName);
                    if (ts.isComputedPropertyName(propertyName)) {
                        computedTempVariables = ts.append(computedTempVariables, rhsValue.argumentExpression);
                    }
                    flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, element);
                }
            }
            else if (i === numElements - 1) {
                if (bindingElements) {
                    flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
                    bindingElements = undefined;
                }
                var rhsValue = flattenContext.context.getEmitHelperFactory().createRestHelper(value, elements, computedTempVariables, pattern);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, element);
            }
        }
        if (bindingElements) {
            flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
        }
    }
    function flattenArrayBindingOrAssignmentPattern(flattenContext, parent, pattern, value, location) {
        var elements = ts.getElementsOfBindingOrAssignmentPattern(pattern);
        var numElements = elements.length;
        if (flattenContext.level < 1 && flattenContext.downlevelIteration) {
            value = ensureIdentifier(flattenContext, ts.setTextRange(flattenContext.context.getEmitHelperFactory().createReadHelper(value, numElements > 0 && ts.getRestIndicatorOfBindingOrAssignmentElement(elements[numElements - 1])
                ? undefined
                : numElements), location), false, location);
        }
        else if (numElements !== 1 && (flattenContext.level < 1 || numElements === 0)
            || ts.every(elements, ts.isOmittedExpression)) {
            var reuseIdentifierExpressions = !ts.isDeclarationBindingElement(parent) || numElements !== 0;
            value = ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location);
        }
        var bindingElements;
        var restContainingElements;
        for (var i = 0; i < numElements; i++) {
            var element = elements[i];
            if (flattenContext.level >= 1) {
                if (element.transformFlags & 65536 || flattenContext.hasTransformedPriorElement && !isSimpleBindingOrAssignmentElement(element)) {
                    flattenContext.hasTransformedPriorElement = true;
                    var temp = flattenContext.context.factory.createTempVariable(undefined);
                    if (flattenContext.hoistTempVariables) {
                        flattenContext.context.hoistVariableDeclaration(temp);
                    }
                    restContainingElements = ts.append(restContainingElements, [temp, element]);
                    bindingElements = ts.append(bindingElements, flattenContext.createArrayBindingOrAssignmentElement(temp));
                }
                else {
                    bindingElements = ts.append(bindingElements, element);
                }
            }
            else if (ts.isOmittedExpression(element)) {
                continue;
            }
            else if (!ts.getRestIndicatorOfBindingOrAssignmentElement(element)) {
                var rhsValue = flattenContext.context.factory.createElementAccessExpression(value, i);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, element);
            }
            else if (i === numElements - 1) {
                var rhsValue = flattenContext.context.factory.createArraySliceCall(value, i);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, element);
            }
        }
        if (bindingElements) {
            flattenContext.emitBindingOrAssignment(flattenContext.createArrayBindingOrAssignmentPattern(bindingElements), value, location, pattern);
        }
        if (restContainingElements) {
            for (var _i = 0, restContainingElements_1 = restContainingElements; _i < restContainingElements_1.length; _i++) {
                var _a = restContainingElements_1[_i], id = _a[0], element = _a[1];
                flattenBindingOrAssignmentElement(flattenContext, element, id, element);
            }
        }
    }
    function isSimpleBindingOrAssignmentElement(element) {
        var target = ts.getTargetOfBindingOrAssignmentElement(element);
        if (!target || ts.isOmittedExpression(target))
            return true;
        var propertyName = ts.tryGetPropertyNameOfBindingOrAssignmentElement(element);
        if (propertyName && !ts.isPropertyNameLiteral(propertyName))
            return false;
        var initializer = ts.getInitializerOfBindingOrAssignmentElement(element);
        if (initializer && !ts.isSimpleInlineableExpression(initializer))
            return false;
        if (ts.isBindingOrAssignmentPattern(target))
            return ts.every(ts.getElementsOfBindingOrAssignmentPattern(target), isSimpleBindingOrAssignmentElement);
        return ts.isIdentifier(target);
    }
    function createDefaultValueCheck(flattenContext, value, defaultValue, location) {
        value = ensureIdentifier(flattenContext, value, true, location);
        return flattenContext.context.factory.createConditionalExpression(flattenContext.context.factory.createTypeCheck(value, "undefined"), undefined, defaultValue, undefined, value);
    }
    function createDestructuringPropertyAccess(flattenContext, value, propertyName) {
        if (ts.isComputedPropertyName(propertyName)) {
            var argumentExpression = ensureIdentifier(flattenContext, ts.visitNode(propertyName.expression, flattenContext.visitor), false, propertyName);
            return flattenContext.context.factory.createElementAccessExpression(value, argumentExpression);
        }
        else if (ts.isStringOrNumericLiteralLike(propertyName)) {
            var argumentExpression = ts.factory.cloneNode(propertyName);
            return flattenContext.context.factory.createElementAccessExpression(value, argumentExpression);
        }
        else {
            var name = flattenContext.context.factory.createIdentifier(ts.idText(propertyName));
            return flattenContext.context.factory.createPropertyAccessExpression(value, name);
        }
    }
    function ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location) {
        if (ts.isIdentifier(value) && reuseIdentifierExpressions) {
            return value;
        }
        else {
            var temp = flattenContext.context.factory.createTempVariable(undefined);
            if (flattenContext.hoistTempVariables) {
                flattenContext.context.hoistVariableDeclaration(temp);
                flattenContext.emitExpression(ts.setTextRange(flattenContext.context.factory.createAssignment(temp, value), location));
            }
            else {
                flattenContext.emitBindingOrAssignment(temp, value, location, undefined);
            }
            return temp;
        }
    }
    function makeArrayBindingPattern(factory, elements) {
        ts.Debug.assertEachNode(elements, ts.isArrayBindingElement);
        return factory.createArrayBindingPattern(elements);
    }
    function makeArrayAssignmentPattern(factory, elements) {
        return factory.createArrayLiteralExpression(ts.map(elements, factory.converters.convertToArrayAssignmentElement));
    }
    function makeObjectBindingPattern(factory, elements) {
        ts.Debug.assertEachNode(elements, ts.isBindingElement);
        return factory.createObjectBindingPattern(elements);
    }
    function makeObjectAssignmentPattern(factory, elements) {
        return factory.createObjectLiteralExpression(ts.map(elements, factory.converters.convertToObjectAssignmentElement));
    }
    function makeBindingElement(factory, name) {
        return factory.createBindingElement(undefined, undefined, name);
    }
    function makeAssignmentElement(name) {
        return name;
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    var ProcessLevel;
    (function (ProcessLevel) {
        ProcessLevel[ProcessLevel["LiftRestriction"] = 0] = "LiftRestriction";
        ProcessLevel[ProcessLevel["All"] = 1] = "All";
    })(ProcessLevel = ts.ProcessLevel || (ts.ProcessLevel = {}));
    function processTaggedTemplateExpression(context, node, visitor, currentSourceFile, recordTaggedTemplateString, level) {
        var tag = ts.visitNode(node.tag, visitor, ts.isExpression);
        var templateArguments = [undefined];
        var cookedStrings = [];
        var rawStrings = [];
        var template = node.template;
        if (level === ProcessLevel.LiftRestriction && !ts.hasInvalidEscape(template)) {
            return ts.visitEachChild(node, visitor, context);
        }
        if (ts.isNoSubstitutionTemplateLiteral(template)) {
            cookedStrings.push(createTemplateCooked(template));
            rawStrings.push(getRawLiteral(template, currentSourceFile));
        }
        else {
            cookedStrings.push(createTemplateCooked(template.head));
            rawStrings.push(getRawLiteral(template.head, currentSourceFile));
            for (var _i = 0, _a = template.templateSpans; _i < _a.length; _i++) {
                var templateSpan = _a[_i];
                cookedStrings.push(createTemplateCooked(templateSpan.literal));
                rawStrings.push(getRawLiteral(templateSpan.literal, currentSourceFile));
                templateArguments.push(ts.visitNode(templateSpan.expression, visitor, ts.isExpression));
            }
        }
        var helperCall = context.getEmitHelperFactory().createTemplateObjectHelper(ts.factory.createArrayLiteralExpression(cookedStrings), ts.factory.createArrayLiteralExpression(rawStrings));
        if (ts.isExternalModule(currentSourceFile)) {
            var tempVar = ts.factory.createUniqueName("templateObject");
            recordTaggedTemplateString(tempVar);
            templateArguments[0] = ts.factory.createLogicalOr(tempVar, ts.factory.createAssignment(tempVar, helperCall));
        }
        else {
            templateArguments[0] = helperCall;
        }
        return ts.factory.createCallExpression(tag, undefined, templateArguments);
    }
    ts.processTaggedTemplateExpression = processTaggedTemplateExpression;
    function createTemplateCooked(template) {
        return template.templateFlags ? ts.factory.createVoidZero() : ts.factory.createStringLiteral(template.text);
    }
    function getRawLiteral(node, currentSourceFile) {
        var text = node.rawText;
        if (text === undefined) {
            ts.Debug.assertIsDefined(currentSourceFile, "Template literal node is missing 'rawText' and does not have a source file. Possibly bad transform.");
            text = ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, node);
            var isLast = node.kind === 14 || node.kind === 17;
            text = text.substring(1, text.length - (isLast ? 1 : 2));
        }
        text = text.replace(/\r\n?/g, "\n");
        return ts.setTextRange(ts.factory.createStringLiteral(text), node);
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    var USE_NEW_TYPE_METADATA_FORMAT = false;
    function transformTypeScript(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var moduleKind = ts.getEmitModuleKind(compilerOptions);
        var typeSerializer = compilerOptions.emitDecoratorMetadata ? ts.createRuntimeTypeSerializer(context) : undefined;
        var previousOnEmitNode = context.onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        context.enableSubstitution(208);
        context.enableSubstitution(209);
        var currentSourceFile;
        var currentNamespace;
        var currentNamespaceContainerName;
        var currentLexicalScope;
        var currentScopeFirstDeclarationsOfName;
        var currentClassHasParameterProperties;
        var enabledSubstitutions;
        var applicableSubstitutions;
        return transformSourceFileOrBundle;
        function transformSourceFileOrBundle(node) {
            if (node.kind === 309) {
                return transformBundle(node);
            }
            return transformSourceFile(node);
        }
        function transformBundle(node) {
            return factory.createBundle(node.sourceFiles.map(transformSourceFile), ts.mapDefined(node.prepends, function (prepend) {
                if (prepend.kind === 311) {
                    return ts.createUnparsedSourceFile(prepend, "js");
                }
                return prepend;
            }));
        }
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            var visited = saveStateAndInvoke(node, visitSourceFile);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            return visited;
        }
        function saveStateAndInvoke(node, f) {
            var savedCurrentScope = currentLexicalScope;
            var savedCurrentScopeFirstDeclarationsOfName = currentScopeFirstDeclarationsOfName;
            var savedCurrentClassHasParameterProperties = currentClassHasParameterProperties;
            onBeforeVisitNode(node);
            var visited = f(node);
            if (currentLexicalScope !== savedCurrentScope) {
                currentScopeFirstDeclarationsOfName = savedCurrentScopeFirstDeclarationsOfName;
            }
            currentLexicalScope = savedCurrentScope;
            currentClassHasParameterProperties = savedCurrentClassHasParameterProperties;
            return visited;
        }
        function onBeforeVisitNode(node) {
            switch (node.kind) {
                case 308:
                case 266:
                case 265:
                case 238:
                    currentLexicalScope = node;
                    currentScopeFirstDeclarationsOfName = undefined;
                    break;
                case 260:
                case 259:
                    if (ts.hasSyntacticModifier(node, 2)) {
                        break;
                    }
                    if (node.name) {
                        recordEmittedDeclarationInScope(node);
                    }
                    else {
                        ts.Debug.assert(node.kind === 260 || ts.hasSyntacticModifier(node, 1024));
                    }
                    break;
            }
        }
        function visitor(node) {
            return saveStateAndInvoke(node, visitorWorker);
        }
        function visitorWorker(node) {
            if (node.transformFlags & 1) {
                return visitTypeScript(node);
            }
            return node;
        }
        function sourceElementVisitor(node) {
            return saveStateAndInvoke(node, sourceElementVisitorWorker);
        }
        function sourceElementVisitorWorker(node) {
            switch (node.kind) {
                case 269:
                case 268:
                case 274:
                case 275:
                    return visitElidableStatement(node);
                default:
                    return visitorWorker(node);
            }
        }
        function visitElidableStatement(node) {
            var parsed = ts.getParseTreeNode(node);
            if (parsed !== node) {
                if (node.transformFlags & 1) {
                    return ts.visitEachChild(node, visitor, context);
                }
                return node;
            }
            switch (node.kind) {
                case 269:
                    return visitImportDeclaration(node);
                case 268:
                    return visitImportEqualsDeclaration(node);
                case 274:
                    return visitExportAssignment(node);
                case 275:
                    return visitExportDeclaration(node);
                default:
                    ts.Debug.fail("Unhandled ellided statement");
            }
        }
        function namespaceElementVisitor(node) {
            return saveStateAndInvoke(node, namespaceElementVisitorWorker);
        }
        function namespaceElementVisitorWorker(node) {
            if (node.kind === 275 ||
                node.kind === 269 ||
                node.kind === 270 ||
                (node.kind === 268 &&
                    node.moduleReference.kind === 280)) {
                return undefined;
            }
            else if (node.transformFlags & 1 || ts.hasSyntacticModifier(node, 1)) {
                return visitTypeScript(node);
            }
            return node;
        }
        function getClassElementVisitor(parent) {
            return function (node) { return saveStateAndInvoke(node, function (n) { return classElementVisitorWorker(n, parent); }); };
        }
        function classElementVisitorWorker(node, parent) {
            switch (node.kind) {
                case 173:
                    return visitConstructor(node);
                case 169:
                    return visitPropertyDeclaration(node, parent);
                case 174:
                    return visitGetAccessor(node, parent);
                case 175:
                    return visitSetAccessor(node, parent);
                case 171:
                    return visitMethodDeclaration(node, parent);
                case 172:
                    return ts.visitEachChild(node, visitor, context);
                case 237:
                    return node;
                case 178:
                    return;
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
        }
        function getObjectLiteralElementVisitor(parent) {
            return function (node) { return saveStateAndInvoke(node, function (n) { return objectLiteralElementVisitorWorker(n, parent); }); };
        }
        function objectLiteralElementVisitorWorker(node, parent) {
            switch (node.kind) {
                case 299:
                case 300:
                case 301:
                    return visitor(node);
                case 174:
                    return visitGetAccessor(node, parent);
                case 175:
                    return visitSetAccessor(node, parent);
                case 171:
                    return visitMethodDeclaration(node, parent);
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
        }
        function modifierVisitor(node) {
            if (ts.isDecorator(node))
                return undefined;
            if (ts.modifierToFlag(node.kind) & 117086) {
                return undefined;
            }
            else if (currentNamespace && node.kind === 93) {
                return undefined;
            }
            return node;
        }
        function visitTypeScript(node) {
            if (ts.isStatement(node) && ts.hasSyntacticModifier(node, 2)) {
                return factory.createNotEmittedStatement(node);
            }
            switch (node.kind) {
                case 93:
                case 88:
                    return currentNamespace ? undefined : node;
                case 123:
                case 121:
                case 122:
                case 126:
                case 161:
                case 85:
                case 136:
                case 146:
                case 101:
                case 145:
                case 185:
                case 186:
                case 187:
                case 188:
                case 184:
                case 179:
                case 165:
                case 131:
                case 157:
                case 134:
                case 152:
                case 148:
                case 144:
                case 114:
                case 153:
                case 182:
                case 181:
                case 183:
                case 180:
                case 189:
                case 190:
                case 191:
                case 193:
                case 194:
                case 195:
                case 196:
                case 197:
                case 198:
                case 178:
                    return undefined;
                case 262:
                    return factory.createNotEmittedStatement(node);
                case 267:
                    return undefined;
                case 261:
                    return factory.createNotEmittedStatement(node);
                case 260:
                    return visitClassDeclaration(node);
                case 228:
                    return visitClassExpression(node);
                case 294:
                    return visitHeritageClause(node);
                case 230:
                    return visitExpressionWithTypeArguments(node);
                case 207:
                    return visitObjectLiteralExpression(node);
                case 173:
                case 169:
                case 171:
                case 174:
                case 175:
                case 172:
                    return ts.Debug.fail("Class and object literal elements must be visited with their respective visitors");
                case 259:
                    return visitFunctionDeclaration(node);
                case 215:
                    return visitFunctionExpression(node);
                case 216:
                    return visitArrowFunction(node);
                case 166:
                    return visitParameter(node);
                case 214:
                    return visitParenthesizedExpression(node);
                case 213:
                case 231:
                    return visitAssertionExpression(node);
                case 235:
                    return visitSatisfiesExpression(node);
                case 210:
                    return visitCallExpression(node);
                case 211:
                    return visitNewExpression(node);
                case 212:
                    return visitTaggedTemplateExpression(node);
                case 232:
                    return visitNonNullExpression(node);
                case 263:
                    return visitEnumDeclaration(node);
                case 240:
                    return visitVariableStatement(node);
                case 257:
                    return visitVariableDeclaration(node);
                case 264:
                    return visitModuleDeclaration(node);
                case 268:
                    return visitImportEqualsDeclaration(node);
                case 282:
                    return visitJsxSelfClosingElement(node);
                case 283:
                    return visitJsxJsxOpeningElement(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitSourceFile(node) {
            var alwaysStrict = ts.getStrictOptionValue(compilerOptions, "alwaysStrict") &&
                !(ts.isExternalModule(node) && moduleKind >= ts.ModuleKind.ES2015) &&
                !ts.isJsonSourceFile(node);
            return factory.updateSourceFile(node, ts.visitLexicalEnvironment(node.statements, sourceElementVisitor, context, 0, alwaysStrict));
        }
        function visitObjectLiteralExpression(node) {
            return factory.updateObjectLiteralExpression(node, ts.visitNodes(node.properties, getObjectLiteralElementVisitor(node), ts.isObjectLiteralElement));
        }
        function getClassFacts(node, staticProperties) {
            var facts = 0;
            if (ts.some(staticProperties))
                facts |= 1;
            var extendsClauseElement = ts.getEffectiveBaseTypeNode(node);
            if (extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 104)
                facts |= 64;
            if (ts.classOrConstructorParameterIsDecorated(node))
                facts |= 2;
            if (ts.childIsDecorated(node))
                facts |= 4;
            if (isExportOfNamespace(node))
                facts |= 8;
            else if (isDefaultExternalModuleExport(node))
                facts |= 32;
            else if (isNamedExternalModuleExport(node))
                facts |= 16;
            if (languageVersion <= 1 && (facts & 7))
                facts |= 128;
            return facts;
        }
        function hasTypeScriptClassSyntax(node) {
            return !!(node.transformFlags & 8192);
        }
        function isClassLikeDeclarationWithTypeScriptSyntax(node) {
            return ts.hasDecorators(node)
                || ts.some(node.typeParameters)
                || ts.some(node.heritageClauses, hasTypeScriptClassSyntax)
                || ts.some(node.members, hasTypeScriptClassSyntax);
        }
        function visitClassDeclaration(node) {
            if (!isClassLikeDeclarationWithTypeScriptSyntax(node) && !(currentNamespace && ts.hasSyntacticModifier(node, 1))) {
                return factory.updateClassDeclaration(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.name, undefined, ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause), ts.visitNodes(node.members, getClassElementVisitor(node), ts.isClassElement));
            }
            var staticProperties = ts.getProperties(node, true, true);
            var facts = getClassFacts(node, staticProperties);
            if (facts & 128) {
                context.startLexicalEnvironment();
            }
            var name = node.name || (facts & 5 ? factory.getGeneratedNameForNode(node) : undefined);
            var allDecorators = ts.getAllDecoratorsOfClass(node);
            var decorators = transformAllDecoratorsOfDeclaration(node, node, allDecorators);
            var modifiers = !(facts & 128)
                ? ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier)
                : ts.elideNodes(factory, node.modifiers);
            var classStatement = factory.updateClassDeclaration(node, ts.concatenate(decorators, modifiers), name, undefined, ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause), transformClassMembers(node));
            var emitFlags = ts.getEmitFlags(node);
            if (facts & 1) {
                emitFlags |= 32;
            }
            ts.setEmitFlags(classStatement, emitFlags);
            var statements = [classStatement];
            if (facts & 128) {
                var closingBraceLocation = ts.createTokenRange(ts.skipTrivia(currentSourceFile.text, node.members.end), 19);
                var localName = factory.getInternalName(node);
                var outer = factory.createPartiallyEmittedExpression(localName);
                ts.setTextRangeEnd(outer, closingBraceLocation.end);
                ts.setEmitFlags(outer, 1536);
                var statement = factory.createReturnStatement(outer);
                ts.setTextRangePos(statement, closingBraceLocation.pos);
                ts.setEmitFlags(statement, 1536 | 384);
                statements.push(statement);
                ts.insertStatementsAfterStandardPrologue(statements, context.endLexicalEnvironment());
                var iife = factory.createImmediatelyInvokedArrowFunction(statements);
                ts.setEmitFlags(iife, 33554432);
                var varStatement = factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                    factory.createVariableDeclaration(factory.getLocalName(node, false, false), undefined, undefined, iife)
                ]));
                ts.setOriginalNode(varStatement, node);
                ts.setCommentRange(varStatement, node);
                ts.setSourceMapRange(varStatement, ts.moveRangePastDecorators(node));
                ts.startOnNewLine(varStatement);
                statements = [varStatement];
            }
            if (facts & 8) {
                addExportMemberAssignment(statements, node);
            }
            else if (facts & 128 || facts & 2) {
                if (facts & 32) {
                    statements.push(factory.createExportDefault(factory.getLocalName(node, false, true)));
                }
                else if (facts & 16) {
                    statements.push(factory.createExternalModuleExport(factory.getLocalName(node, false, true)));
                }
            }
            if (statements.length > 1) {
                statements.push(factory.createEndOfDeclarationMarker(node));
                ts.setEmitFlags(classStatement, ts.getEmitFlags(classStatement) | 4194304);
            }
            return ts.singleOrMany(statements);
        }
        function visitClassExpression(node) {
            var allDecorators = ts.getAllDecoratorsOfClass(node);
            var decorators = transformAllDecoratorsOfDeclaration(node, node, allDecorators);
            return factory.updateClassExpression(node, decorators, node.name, undefined, ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause), isClassLikeDeclarationWithTypeScriptSyntax(node) ?
                transformClassMembers(node) :
                ts.visitNodes(node.members, getClassElementVisitor(node), ts.isClassElement));
        }
        function transformClassMembers(node) {
            var members = [];
            var constructor = ts.getFirstConstructorWithBody(node);
            var parametersWithPropertyAssignments = constructor &&
                ts.filter(constructor.parameters, function (p) { return ts.isParameterPropertyDeclaration(p, constructor); });
            if (parametersWithPropertyAssignments) {
                for (var _i = 0, parametersWithPropertyAssignments_1 = parametersWithPropertyAssignments; _i < parametersWithPropertyAssignments_1.length; _i++) {
                    var parameter = parametersWithPropertyAssignments_1[_i];
                    if (ts.isIdentifier(parameter.name)) {
                        members.push(ts.setOriginalNode(factory.createPropertyDeclaration(undefined, parameter.name, undefined, undefined, undefined), parameter));
                    }
                }
            }
            ts.addRange(members, ts.visitNodes(node.members, getClassElementVisitor(node), ts.isClassElement));
            return ts.setTextRange(factory.createNodeArray(members), node.members);
        }
        function transformAllDecoratorsOfDeclaration(node, container, allDecorators) {
            var _a, _b, _c, _d;
            if (!allDecorators) {
                return undefined;
            }
            var decorators = ts.visitArray(allDecorators.decorators, visitor, ts.isDecorator);
            var parameterDecorators = ts.flatMap(allDecorators.parameters, transformDecoratorsOfParameter);
            var metadataDecorators = ts.some(decorators) || ts.some(parameterDecorators) ? getTypeMetadata(node, container) : undefined;
            var result = factory.createNodeArray(ts.concatenate(ts.concatenate(decorators, parameterDecorators), metadataDecorators));
            var pos = (_b = (_a = ts.firstOrUndefined(allDecorators.decorators)) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : -1;
            var end = (_d = (_c = ts.lastOrUndefined(allDecorators.decorators)) === null || _c === void 0 ? void 0 : _c.end) !== null && _d !== void 0 ? _d : -1;
            ts.setTextRangePosEnd(result, pos, end);
            return result;
        }
        function transformDecoratorsOfParameter(parameterDecorators, parameterOffset) {
            if (parameterDecorators) {
                var decorators = [];
                for (var _i = 0, parameterDecorators_1 = parameterDecorators; _i < parameterDecorators_1.length; _i++) {
                    var parameterDecorator = parameterDecorators_1[_i];
                    var expression = ts.visitNode(parameterDecorator.expression, visitor, ts.isExpression);
                    var helper = emitHelpers().createParamHelper(expression, parameterOffset);
                    ts.setTextRange(helper, parameterDecorator.expression);
                    ts.setEmitFlags(helper, 1536);
                    var decorator = factory.createDecorator(helper);
                    ts.setSourceMapRange(decorator, parameterDecorator.expression);
                    ts.setCommentRange(decorator, parameterDecorator.expression);
                    ts.setEmitFlags(decorator, 1536);
                    decorators.push(decorator);
                }
                return decorators;
            }
        }
        function getTypeMetadata(node, container) {
            return USE_NEW_TYPE_METADATA_FORMAT ?
                getNewTypeMetadata(node, container) :
                getOldTypeMetadata(node, container);
        }
        function getOldTypeMetadata(node, container) {
            if (typeSerializer) {
                var decorators = void 0;
                if (shouldAddTypeMetadata(node)) {
                    var typeMetadata = emitHelpers().createMetadataHelper("design:type", typeSerializer.serializeTypeOfNode({ currentLexicalScope: currentLexicalScope, currentNameScope: container }, node));
                    decorators = ts.append(decorators, factory.createDecorator(typeMetadata));
                }
                if (shouldAddParamTypesMetadata(node)) {
                    var paramTypesMetadata = emitHelpers().createMetadataHelper("design:paramtypes", typeSerializer.serializeParameterTypesOfNode({ currentLexicalScope: currentLexicalScope, currentNameScope: container }, node, container));
                    decorators = ts.append(decorators, factory.createDecorator(paramTypesMetadata));
                }
                if (shouldAddReturnTypeMetadata(node)) {
                    var returnTypeMetadata = emitHelpers().createMetadataHelper("design:returntype", typeSerializer.serializeReturnTypeOfNode({ currentLexicalScope: currentLexicalScope, currentNameScope: container }, node));
                    decorators = ts.append(decorators, factory.createDecorator(returnTypeMetadata));
                }
                return decorators;
            }
        }
        function getNewTypeMetadata(node, container) {
            if (typeSerializer) {
                var properties = void 0;
                if (shouldAddTypeMetadata(node)) {
                    var typeProperty = factory.createPropertyAssignment("type", factory.createArrowFunction(undefined, undefined, [], undefined, factory.createToken(38), typeSerializer.serializeTypeOfNode({ currentLexicalScope: currentLexicalScope, currentNameScope: container }, node)));
                    properties = ts.append(properties, typeProperty);
                }
                if (shouldAddParamTypesMetadata(node)) {
                    var paramTypeProperty = factory.createPropertyAssignment("paramTypes", factory.createArrowFunction(undefined, undefined, [], undefined, factory.createToken(38), typeSerializer.serializeParameterTypesOfNode({ currentLexicalScope: currentLexicalScope, currentNameScope: container }, node, container)));
                    properties = ts.append(properties, paramTypeProperty);
                }
                if (shouldAddReturnTypeMetadata(node)) {
                    var returnTypeProperty = factory.createPropertyAssignment("returnType", factory.createArrowFunction(undefined, undefined, [], undefined, factory.createToken(38), typeSerializer.serializeReturnTypeOfNode({ currentLexicalScope: currentLexicalScope, currentNameScope: container }, node)));
                    properties = ts.append(properties, returnTypeProperty);
                }
                if (properties) {
                    var typeInfoMetadata = emitHelpers().createMetadataHelper("design:typeinfo", factory.createObjectLiteralExpression(properties, true));
                    return [factory.createDecorator(typeInfoMetadata)];
                }
            }
        }
        function shouldAddTypeMetadata(node) {
            var kind = node.kind;
            return kind === 171
                || kind === 174
                || kind === 175
                || kind === 169;
        }
        function shouldAddReturnTypeMetadata(node) {
            return node.kind === 171;
        }
        function shouldAddParamTypesMetadata(node) {
            switch (node.kind) {
                case 260:
                case 228:
                    return ts.getFirstConstructorWithBody(node) !== undefined;
                case 171:
                case 174:
                case 175:
                    return true;
            }
            return false;
        }
        function getExpressionForPropertyName(member, generateNameForComputedPropertyName) {
            var name = member.name;
            if (ts.isPrivateIdentifier(name)) {
                return factory.createIdentifier("");
            }
            else if (ts.isComputedPropertyName(name)) {
                return generateNameForComputedPropertyName && !ts.isSimpleInlineableExpression(name.expression)
                    ? factory.getGeneratedNameForNode(name)
                    : name.expression;
            }
            else if (ts.isIdentifier(name)) {
                return factory.createStringLiteral(ts.idText(name));
            }
            else {
                return factory.cloneNode(name);
            }
        }
        function visitPropertyNameOfClassElement(member) {
            var name = member.name;
            if (ts.isComputedPropertyName(name) && ((!ts.hasStaticModifier(member) && currentClassHasParameterProperties) || ts.hasDecorators(member))) {
                var expression = ts.visitNode(name.expression, visitor, ts.isExpression);
                var innerExpression = ts.skipPartiallyEmittedExpressions(expression);
                if (!ts.isSimpleInlineableExpression(innerExpression)) {
                    var generatedName = factory.getGeneratedNameForNode(name);
                    hoistVariableDeclaration(generatedName);
                    return factory.updateComputedPropertyName(name, factory.createAssignment(generatedName, expression));
                }
            }
            return ts.visitNode(name, visitor, ts.isPropertyName);
        }
        function visitHeritageClause(node) {
            if (node.token === 117) {
                return undefined;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitExpressionWithTypeArguments(node) {
            return factory.updateExpressionWithTypeArguments(node, ts.visitNode(node.expression, visitor, ts.isLeftHandSideExpression), undefined);
        }
        function shouldEmitFunctionLikeDeclaration(node) {
            return !ts.nodeIsMissing(node.body);
        }
        function visitPropertyDeclaration(node, parent) {
            var isAmbient = node.flags & 16777216 || ts.hasSyntacticModifier(node, 256);
            if (isAmbient && !ts.hasDecorators(node)) {
                return undefined;
            }
            var allDecorators = ts.getAllDecoratorsOfClassElement(node, parent);
            var decorators = transformAllDecoratorsOfDeclaration(node, parent, allDecorators);
            if (isAmbient) {
                return factory.updatePropertyDeclaration(node, ts.concatenate(decorators, factory.createModifiersFromModifierFlags(2)), ts.visitNode(node.name, visitor, ts.isPropertyName), undefined, undefined, undefined);
            }
            return factory.updatePropertyDeclaration(node, ts.concatenate(decorators, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifierLike)), visitPropertyNameOfClassElement(node), undefined, undefined, ts.visitNode(node.initializer, visitor));
        }
        function visitConstructor(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return undefined;
            }
            return factory.updateConstructorDeclaration(node, undefined, ts.visitParameterList(node.parameters, visitor, context), transformConstructorBody(node.body, node));
        }
        function transformConstructorBody(body, constructor) {
            var parametersWithPropertyAssignments = constructor &&
                ts.filter(constructor.parameters, function (p) { return ts.isParameterPropertyDeclaration(p, constructor); });
            if (!ts.some(parametersWithPropertyAssignments)) {
                return ts.visitFunctionBody(body, visitor, context);
            }
            var statements = [];
            resumeLexicalEnvironment();
            var prologueStatementCount = factory.copyPrologue(body.statements, statements, false, visitor);
            var superStatementIndex = ts.findSuperStatementIndex(body.statements, prologueStatementCount);
            if (superStatementIndex >= 0) {
                ts.addRange(statements, ts.visitNodes(body.statements, visitor, ts.isStatement, prologueStatementCount, superStatementIndex + 1 - prologueStatementCount));
            }
            var parameterPropertyAssignments = ts.mapDefined(parametersWithPropertyAssignments, transformParameterWithPropertyAssignment);
            if (superStatementIndex >= 0) {
                ts.addRange(statements, parameterPropertyAssignments);
            }
            else {
                statements = __spreadArray(__spreadArray(__spreadArray([], statements.slice(0, prologueStatementCount), true), parameterPropertyAssignments, true), statements.slice(prologueStatementCount), true);
            }
            var start = superStatementIndex >= 0 ? superStatementIndex + 1 : prologueStatementCount;
            ts.addRange(statements, ts.visitNodes(body.statements, visitor, ts.isStatement, start));
            statements = factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
            var block = factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), body.statements), true);
            ts.setTextRange(block, body);
            ts.setOriginalNode(block, body);
            return block;
        }
        function transformParameterWithPropertyAssignment(node) {
            var name = node.name;
            if (!ts.isIdentifier(name)) {
                return undefined;
            }
            var propertyName = ts.setParent(ts.setTextRange(factory.cloneNode(name), name), name.parent);
            ts.setEmitFlags(propertyName, 1536 | 48);
            var localName = ts.setParent(ts.setTextRange(factory.cloneNode(name), name), name.parent);
            ts.setEmitFlags(localName, 1536);
            return ts.startOnNewLine(ts.removeAllComments(ts.setTextRange(ts.setOriginalNode(factory.createExpressionStatement(factory.createAssignment(ts.setTextRange(factory.createPropertyAccessExpression(factory.createThis(), propertyName), node.name), localName)), node), ts.moveRangePos(node, -1))));
        }
        function visitMethodDeclaration(node, parent) {
            if (!(node.transformFlags & 1)) {
                return node;
            }
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return undefined;
            }
            var allDecorators = ts.isClassLike(parent) ? ts.getAllDecoratorsOfClassElement(node, parent) : undefined;
            var decorators = ts.isClassLike(parent) ? transformAllDecoratorsOfDeclaration(node, parent, allDecorators) : undefined;
            return factory.updateMethodDeclaration(node, ts.concatenate(decorators, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifierLike)), node.asteriskToken, visitPropertyNameOfClassElement(node), undefined, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.visitFunctionBody(node.body, visitor, context));
        }
        function shouldEmitAccessorDeclaration(node) {
            return !(ts.nodeIsMissing(node.body) && ts.hasSyntacticModifier(node, 256));
        }
        function visitGetAccessor(node, parent) {
            if (!(node.transformFlags & 1)) {
                return node;
            }
            if (!shouldEmitAccessorDeclaration(node)) {
                return undefined;
            }
            var decorators = ts.isClassLike(parent) ?
                transformAllDecoratorsOfDeclaration(node, parent, ts.getAllDecoratorsOfClassElement(node, parent)) :
                undefined;
            return factory.updateGetAccessorDeclaration(node, ts.concatenate(decorators, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifierLike)), visitPropertyNameOfClassElement(node), ts.visitParameterList(node.parameters, visitor, context), undefined, ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
        }
        function visitSetAccessor(node, parent) {
            if (!(node.transformFlags & 1)) {
                return node;
            }
            if (!shouldEmitAccessorDeclaration(node)) {
                return undefined;
            }
            var decorators = ts.isClassLike(parent) ?
                transformAllDecoratorsOfDeclaration(node, parent, ts.getAllDecoratorsOfClassElement(node, parent)) :
                undefined;
            return factory.updateSetAccessorDeclaration(node, ts.concatenate(decorators, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifierLike)), visitPropertyNameOfClassElement(node), ts.visitParameterList(node.parameters, visitor, context), ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
        }
        function visitFunctionDeclaration(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return factory.createNotEmittedStatement(node);
            }
            var updated = factory.updateFunctionDeclaration(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
            if (isExportOfNamespace(node)) {
                var statements = [updated];
                addExportMemberAssignment(statements, node);
                return statements;
            }
            return updated;
        }
        function visitFunctionExpression(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return factory.createOmittedExpression();
            }
            var updated = factory.updateFunctionExpression(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
            return updated;
        }
        function visitArrowFunction(node) {
            var updated = factory.updateArrowFunction(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, node.equalsGreaterThanToken, ts.visitFunctionBody(node.body, visitor, context));
            return updated;
        }
        function visitParameter(node) {
            if (ts.parameterIsThisKeyword(node)) {
                return undefined;
            }
            var updated = factory.updateParameterDeclaration(node, ts.elideNodes(factory, node.modifiers), node.dotDotDotToken, ts.visitNode(node.name, visitor, ts.isBindingName), undefined, undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            if (updated !== node) {
                ts.setCommentRange(updated, node);
                ts.setTextRange(updated, ts.moveRangePastModifiers(node));
                ts.setSourceMapRange(updated, ts.moveRangePastModifiers(node));
                ts.setEmitFlags(updated.name, 32);
            }
            return updated;
        }
        function visitVariableStatement(node) {
            if (isExportOfNamespace(node)) {
                var variables = ts.getInitializedVariables(node.declarationList);
                if (variables.length === 0) {
                    return undefined;
                }
                return ts.setTextRange(factory.createExpressionStatement(factory.inlineExpressions(ts.map(variables, transformInitializedVariable))), node);
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformInitializedVariable(node) {
            var name = node.name;
            if (ts.isBindingPattern(name)) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 0, false, createNamespaceExportExpression);
            }
            else {
                return ts.setTextRange(factory.createAssignment(getNamespaceMemberNameWithSourceMapsAndWithoutComments(name), ts.visitNode(node.initializer, visitor, ts.isExpression)), node);
            }
        }
        function visitVariableDeclaration(node) {
            var updated = factory.updateVariableDeclaration(node, ts.visitNode(node.name, visitor, ts.isBindingName), undefined, undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            if (node.type) {
                ts.setTypeNode(updated.name, node.type);
            }
            return updated;
        }
        function visitParenthesizedExpression(node) {
            var innerExpression = ts.skipOuterExpressions(node.expression, ~6);
            if (ts.isAssertionExpression(innerExpression)) {
                var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
                return factory.createPartiallyEmittedExpression(expression, node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitAssertionExpression(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            return factory.createPartiallyEmittedExpression(expression, node);
        }
        function visitNonNullExpression(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isLeftHandSideExpression);
            return factory.createPartiallyEmittedExpression(expression, node);
        }
        function visitSatisfiesExpression(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            return factory.createPartiallyEmittedExpression(expression, node);
        }
        function visitCallExpression(node) {
            return factory.updateCallExpression(node, ts.visitNode(node.expression, visitor, ts.isExpression), undefined, ts.visitNodes(node.arguments, visitor, ts.isExpression));
        }
        function visitNewExpression(node) {
            return factory.updateNewExpression(node, ts.visitNode(node.expression, visitor, ts.isExpression), undefined, ts.visitNodes(node.arguments, visitor, ts.isExpression));
        }
        function visitTaggedTemplateExpression(node) {
            return factory.updateTaggedTemplateExpression(node, ts.visitNode(node.tag, visitor, ts.isExpression), undefined, ts.visitNode(node.template, visitor, ts.isExpression));
        }
        function visitJsxSelfClosingElement(node) {
            return factory.updateJsxSelfClosingElement(node, ts.visitNode(node.tagName, visitor, ts.isJsxTagNameExpression), undefined, ts.visitNode(node.attributes, visitor, ts.isJsxAttributes));
        }
        function visitJsxJsxOpeningElement(node) {
            return factory.updateJsxOpeningElement(node, ts.visitNode(node.tagName, visitor, ts.isJsxTagNameExpression), undefined, ts.visitNode(node.attributes, visitor, ts.isJsxAttributes));
        }
        function shouldEmitEnumDeclaration(node) {
            return !ts.isEnumConst(node)
                || ts.shouldPreserveConstEnums(compilerOptions);
        }
        function visitEnumDeclaration(node) {
            if (!shouldEmitEnumDeclaration(node)) {
                return factory.createNotEmittedStatement(node);
            }
            var statements = [];
            var emitFlags = 2;
            var varAdded = addVarForEnumOrModuleDeclaration(statements, node);
            if (varAdded) {
                if (moduleKind !== ts.ModuleKind.System || currentLexicalScope !== currentSourceFile) {
                    emitFlags |= 512;
                }
            }
            var parameterName = getNamespaceParameterName(node);
            var containerName = getNamespaceContainerName(node);
            var exportName = ts.hasSyntacticModifier(node, 1)
                ? factory.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, false, true)
                : factory.getLocalName(node, false, true);
            var moduleArg = factory.createLogicalOr(exportName, factory.createAssignment(exportName, factory.createObjectLiteralExpression()));
            if (hasNamespaceQualifiedExportName(node)) {
                var localName = factory.getLocalName(node, false, true);
                moduleArg = factory.createAssignment(localName, moduleArg);
            }
            var enumStatement = factory.createExpressionStatement(factory.createCallExpression(factory.createFunctionExpression(undefined, undefined, undefined, undefined, [factory.createParameterDeclaration(undefined, undefined, parameterName)], undefined, transformEnumBody(node, containerName)), undefined, [moduleArg]));
            ts.setOriginalNode(enumStatement, node);
            if (varAdded) {
                ts.setSyntheticLeadingComments(enumStatement, undefined);
                ts.setSyntheticTrailingComments(enumStatement, undefined);
            }
            ts.setTextRange(enumStatement, node);
            ts.addEmitFlags(enumStatement, emitFlags);
            statements.push(enumStatement);
            statements.push(factory.createEndOfDeclarationMarker(node));
            return statements;
        }
        function transformEnumBody(node, localName) {
            var savedCurrentNamespaceLocalName = currentNamespaceContainerName;
            currentNamespaceContainerName = localName;
            var statements = [];
            startLexicalEnvironment();
            var members = ts.map(node.members, transformEnumMember);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            ts.addRange(statements, members);
            currentNamespaceContainerName = savedCurrentNamespaceLocalName;
            return factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), node.members), true);
        }
        function transformEnumMember(member) {
            var name = getExpressionForPropertyName(member, false);
            var valueExpression = transformEnumMemberDeclarationValue(member);
            var innerAssignment = factory.createAssignment(factory.createElementAccessExpression(currentNamespaceContainerName, name), valueExpression);
            var outerAssignment = valueExpression.kind === 10 ?
                innerAssignment :
                factory.createAssignment(factory.createElementAccessExpression(currentNamespaceContainerName, innerAssignment), name);
            return ts.setTextRange(factory.createExpressionStatement(ts.setTextRange(outerAssignment, member)), member);
        }
        function transformEnumMemberDeclarationValue(member) {
            var value = resolver.getConstantValue(member);
            if (value !== undefined) {
                return typeof value === "string" ? factory.createStringLiteral(value) : factory.createNumericLiteral(value);
            }
            else {
                enableSubstitutionForNonQualifiedEnumMembers();
                if (member.initializer) {
                    return ts.visitNode(member.initializer, visitor, ts.isExpression);
                }
                else {
                    return factory.createVoidZero();
                }
            }
        }
        function shouldEmitModuleDeclaration(nodeIn) {
            var node = ts.getParseTreeNode(nodeIn, ts.isModuleDeclaration);
            if (!node) {
                return true;
            }
            return ts.isInstantiatedModule(node, ts.shouldPreserveConstEnums(compilerOptions));
        }
        function hasNamespaceQualifiedExportName(node) {
            return isExportOfNamespace(node)
                || (isExternalModuleExport(node)
                    && moduleKind !== ts.ModuleKind.ES2015
                    && moduleKind !== ts.ModuleKind.ES2020
                    && moduleKind !== ts.ModuleKind.ES2022
                    && moduleKind !== ts.ModuleKind.ESNext
                    && moduleKind !== ts.ModuleKind.System);
        }
        function recordEmittedDeclarationInScope(node) {
            if (!currentScopeFirstDeclarationsOfName) {
                currentScopeFirstDeclarationsOfName = new ts.Map();
            }
            var name = declaredNameInScope(node);
            if (!currentScopeFirstDeclarationsOfName.has(name)) {
                currentScopeFirstDeclarationsOfName.set(name, node);
            }
        }
        function isFirstEmittedDeclarationInScope(node) {
            if (currentScopeFirstDeclarationsOfName) {
                var name = declaredNameInScope(node);
                return currentScopeFirstDeclarationsOfName.get(name) === node;
            }
            return true;
        }
        function declaredNameInScope(node) {
            ts.Debug.assertNode(node.name, ts.isIdentifier);
            return node.name.escapedText;
        }
        function addVarForEnumOrModuleDeclaration(statements, node) {
            var statement = factory.createVariableStatement(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), factory.createVariableDeclarationList([
                factory.createVariableDeclaration(factory.getLocalName(node, false, true))
            ], currentLexicalScope.kind === 308 ? 0 : 1));
            ts.setOriginalNode(statement, node);
            recordEmittedDeclarationInScope(node);
            if (isFirstEmittedDeclarationInScope(node)) {
                if (node.kind === 263) {
                    ts.setSourceMapRange(statement.declarationList, node);
                }
                else {
                    ts.setSourceMapRange(statement, node);
                }
                ts.setCommentRange(statement, node);
                ts.addEmitFlags(statement, 1024 | 4194304);
                statements.push(statement);
                return true;
            }
            else {
                var mergeMarker = factory.createMergeDeclarationMarker(statement);
                ts.setEmitFlags(mergeMarker, 1536 | 4194304);
                statements.push(mergeMarker);
                return false;
            }
        }
        function visitModuleDeclaration(node) {
            if (!shouldEmitModuleDeclaration(node)) {
                return factory.createNotEmittedStatement(node);
            }
            ts.Debug.assertNode(node.name, ts.isIdentifier, "A TypeScript namespace should have an Identifier name.");
            enableSubstitutionForNamespaceExports();
            var statements = [];
            var emitFlags = 2;
            var varAdded = addVarForEnumOrModuleDeclaration(statements, node);
            if (varAdded) {
                if (moduleKind !== ts.ModuleKind.System || currentLexicalScope !== currentSourceFile) {
                    emitFlags |= 512;
                }
            }
            var parameterName = getNamespaceParameterName(node);
            var containerName = getNamespaceContainerName(node);
            var exportName = ts.hasSyntacticModifier(node, 1)
                ? factory.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, false, true)
                : factory.getLocalName(node, false, true);
            var moduleArg = factory.createLogicalOr(exportName, factory.createAssignment(exportName, factory.createObjectLiteralExpression()));
            if (hasNamespaceQualifiedExportName(node)) {
                var localName = factory.getLocalName(node, false, true);
                moduleArg = factory.createAssignment(localName, moduleArg);
            }
            var moduleStatement = factory.createExpressionStatement(factory.createCallExpression(factory.createFunctionExpression(undefined, undefined, undefined, undefined, [factory.createParameterDeclaration(undefined, undefined, parameterName)], undefined, transformModuleBody(node, containerName)), undefined, [moduleArg]));
            ts.setOriginalNode(moduleStatement, node);
            if (varAdded) {
                ts.setSyntheticLeadingComments(moduleStatement, undefined);
                ts.setSyntheticTrailingComments(moduleStatement, undefined);
            }
            ts.setTextRange(moduleStatement, node);
            ts.addEmitFlags(moduleStatement, emitFlags);
            statements.push(moduleStatement);
            statements.push(factory.createEndOfDeclarationMarker(node));
            return statements;
        }
        function transformModuleBody(node, namespaceLocalName) {
            var savedCurrentNamespaceContainerName = currentNamespaceContainerName;
            var savedCurrentNamespace = currentNamespace;
            var savedCurrentScopeFirstDeclarationsOfName = currentScopeFirstDeclarationsOfName;
            currentNamespaceContainerName = namespaceLocalName;
            currentNamespace = node;
            currentScopeFirstDeclarationsOfName = undefined;
            var statements = [];
            startLexicalEnvironment();
            var statementsLocation;
            var blockLocation;
            if (node.body) {
                if (node.body.kind === 265) {
                    saveStateAndInvoke(node.body, function (body) { return ts.addRange(statements, ts.visitNodes(body.statements, namespaceElementVisitor, ts.isStatement)); });
                    statementsLocation = node.body.statements;
                    blockLocation = node.body;
                }
                else {
                    var result = visitModuleDeclaration(node.body);
                    if (result) {
                        if (ts.isArray(result)) {
                            ts.addRange(statements, result);
                        }
                        else {
                            statements.push(result);
                        }
                    }
                    var moduleBlock = getInnerMostModuleDeclarationFromDottedModule(node).body;
                    statementsLocation = ts.moveRangePos(moduleBlock.statements, -1);
                }
            }
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            currentNamespaceContainerName = savedCurrentNamespaceContainerName;
            currentNamespace = savedCurrentNamespace;
            currentScopeFirstDeclarationsOfName = savedCurrentScopeFirstDeclarationsOfName;
            var block = factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), statementsLocation), true);
            ts.setTextRange(block, blockLocation);
            if (!node.body || node.body.kind !== 265) {
                ts.setEmitFlags(block, ts.getEmitFlags(block) | 1536);
            }
            return block;
        }
        function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration) {
            if (moduleDeclaration.body.kind === 264) {
                var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration.body);
                return recursiveInnerModule || moduleDeclaration.body;
            }
        }
        function visitImportDeclaration(node) {
            if (!node.importClause) {
                return node;
            }
            if (node.importClause.isTypeOnly) {
                return undefined;
            }
            var importClause = ts.visitNode(node.importClause, visitImportClause, ts.isImportClause);
            return importClause ||
                compilerOptions.importsNotUsedAsValues === 1 ||
                compilerOptions.importsNotUsedAsValues === 2
                ? factory.updateImportDeclaration(node, undefined, importClause, node.moduleSpecifier, node.assertClause)
                : undefined;
        }
        function visitImportClause(node) {
            ts.Debug.assert(!node.isTypeOnly);
            var name = shouldEmitAliasDeclaration(node) ? node.name : undefined;
            var namedBindings = ts.visitNode(node.namedBindings, visitNamedImportBindings, ts.isNamedImportBindings);
            return (name || namedBindings) ? factory.updateImportClause(node, false, name, namedBindings) : undefined;
        }
        function visitNamedImportBindings(node) {
            if (node.kind === 271) {
                return shouldEmitAliasDeclaration(node) ? node : undefined;
            }
            else {
                var allowEmpty = compilerOptions.preserveValueImports && (compilerOptions.importsNotUsedAsValues === 1 ||
                    compilerOptions.importsNotUsedAsValues === 2);
                var elements = ts.visitNodes(node.elements, visitImportSpecifier, ts.isImportSpecifier);
                return allowEmpty || ts.some(elements) ? factory.updateNamedImports(node, elements) : undefined;
            }
        }
        function visitImportSpecifier(node) {
            return !node.isTypeOnly && shouldEmitAliasDeclaration(node) ? node : undefined;
        }
        function visitExportAssignment(node) {
            return resolver.isValueAliasDeclaration(node)
                ? ts.visitEachChild(node, visitor, context)
                : undefined;
        }
        function visitExportDeclaration(node) {
            if (node.isTypeOnly) {
                return undefined;
            }
            if (!node.exportClause || ts.isNamespaceExport(node.exportClause)) {
                return node;
            }
            var allowEmpty = !!node.moduleSpecifier && (compilerOptions.importsNotUsedAsValues === 1 ||
                compilerOptions.importsNotUsedAsValues === 2);
            var exportClause = ts.visitNode(node.exportClause, function (bindings) { return visitNamedExportBindings(bindings, allowEmpty); }, ts.isNamedExportBindings);
            return exportClause
                ? factory.updateExportDeclaration(node, undefined, node.isTypeOnly, exportClause, node.moduleSpecifier, node.assertClause)
                : undefined;
        }
        function visitNamedExports(node, allowEmpty) {
            var elements = ts.visitNodes(node.elements, visitExportSpecifier, ts.isExportSpecifier);
            return allowEmpty || ts.some(elements) ? factory.updateNamedExports(node, elements) : undefined;
        }
        function visitNamespaceExports(node) {
            return factory.updateNamespaceExport(node, ts.visitNode(node.name, visitor, ts.isIdentifier));
        }
        function visitNamedExportBindings(node, allowEmpty) {
            return ts.isNamespaceExport(node) ? visitNamespaceExports(node) : visitNamedExports(node, allowEmpty);
        }
        function visitExportSpecifier(node) {
            return !node.isTypeOnly && resolver.isValueAliasDeclaration(node) ? node : undefined;
        }
        function shouldEmitImportEqualsDeclaration(node) {
            return shouldEmitAliasDeclaration(node)
                || (!ts.isExternalModule(currentSourceFile)
                    && resolver.isTopLevelValueImportEqualsWithEntityName(node));
        }
        function visitImportEqualsDeclaration(node) {
            if (node.isTypeOnly) {
                return undefined;
            }
            if (ts.isExternalModuleImportEqualsDeclaration(node)) {
                var isReferenced = shouldEmitAliasDeclaration(node);
                if (!isReferenced && compilerOptions.importsNotUsedAsValues === 1) {
                    return ts.setOriginalNode(ts.setTextRange(factory.createImportDeclaration(undefined, undefined, node.moduleReference.expression, undefined), node), node);
                }
                return isReferenced ? ts.visitEachChild(node, visitor, context) : undefined;
            }
            if (!shouldEmitImportEqualsDeclaration(node)) {
                return undefined;
            }
            var moduleReference = ts.createExpressionFromEntityName(factory, node.moduleReference);
            ts.setEmitFlags(moduleReference, 1536 | 2048);
            if (isNamedExternalModuleExport(node) || !isExportOfNamespace(node)) {
                return ts.setOriginalNode(ts.setTextRange(factory.createVariableStatement(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), factory.createVariableDeclarationList([
                    ts.setOriginalNode(factory.createVariableDeclaration(node.name, undefined, undefined, moduleReference), node)
                ])), node), node);
            }
            else {
                return ts.setOriginalNode(createNamespaceExport(node.name, moduleReference, node), node);
            }
        }
        function isExportOfNamespace(node) {
            return currentNamespace !== undefined && ts.hasSyntacticModifier(node, 1);
        }
        function isExternalModuleExport(node) {
            return currentNamespace === undefined && ts.hasSyntacticModifier(node, 1);
        }
        function isNamedExternalModuleExport(node) {
            return isExternalModuleExport(node)
                && !ts.hasSyntacticModifier(node, 1024);
        }
        function isDefaultExternalModuleExport(node) {
            return isExternalModuleExport(node)
                && ts.hasSyntacticModifier(node, 1024);
        }
        function addExportMemberAssignment(statements, node) {
            var expression = factory.createAssignment(factory.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, false, true), factory.getLocalName(node));
            ts.setSourceMapRange(expression, ts.createRange(node.name ? node.name.pos : node.pos, node.end));
            var statement = factory.createExpressionStatement(expression);
            ts.setSourceMapRange(statement, ts.createRange(-1, node.end));
            statements.push(statement);
        }
        function createNamespaceExport(exportName, exportValue, location) {
            return ts.setTextRange(factory.createExpressionStatement(factory.createAssignment(factory.getNamespaceMemberName(currentNamespaceContainerName, exportName, false, true), exportValue)), location);
        }
        function createNamespaceExportExpression(exportName, exportValue, location) {
            return ts.setTextRange(factory.createAssignment(getNamespaceMemberNameWithSourceMapsAndWithoutComments(exportName), exportValue), location);
        }
        function getNamespaceMemberNameWithSourceMapsAndWithoutComments(name) {
            return factory.getNamespaceMemberName(currentNamespaceContainerName, name, false, true);
        }
        function getNamespaceParameterName(node) {
            var name = factory.getGeneratedNameForNode(node);
            ts.setSourceMapRange(name, node.name);
            return name;
        }
        function getNamespaceContainerName(node) {
            return factory.getGeneratedNameForNode(node);
        }
        function enableSubstitutionForNonQualifiedEnumMembers() {
            if ((enabledSubstitutions & 8) === 0) {
                enabledSubstitutions |= 8;
                context.enableSubstitution(79);
            }
        }
        function enableSubstitutionForNamespaceExports() {
            if ((enabledSubstitutions & 2) === 0) {
                enabledSubstitutions |= 2;
                context.enableSubstitution(79);
                context.enableSubstitution(300);
                context.enableEmitNotification(264);
            }
        }
        function isTransformedModuleDeclaration(node) {
            return ts.getOriginalNode(node).kind === 264;
        }
        function isTransformedEnumDeclaration(node) {
            return ts.getOriginalNode(node).kind === 263;
        }
        function onEmitNode(hint, node, emitCallback) {
            var savedApplicableSubstitutions = applicableSubstitutions;
            var savedCurrentSourceFile = currentSourceFile;
            if (ts.isSourceFile(node)) {
                currentSourceFile = node;
            }
            if (enabledSubstitutions & 2 && isTransformedModuleDeclaration(node)) {
                applicableSubstitutions |= 2;
            }
            if (enabledSubstitutions & 8 && isTransformedEnumDeclaration(node)) {
                applicableSubstitutions |= 8;
            }
            previousOnEmitNode(hint, node, emitCallback);
            applicableSubstitutions = savedApplicableSubstitutions;
            currentSourceFile = savedCurrentSourceFile;
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1) {
                return substituteExpression(node);
            }
            else if (ts.isShorthandPropertyAssignment(node)) {
                return substituteShorthandPropertyAssignment(node);
            }
            return node;
        }
        function substituteShorthandPropertyAssignment(node) {
            if (enabledSubstitutions & 2) {
                var name = node.name;
                var exportedName = trySubstituteNamespaceExportedName(name);
                if (exportedName) {
                    if (node.objectAssignmentInitializer) {
                        var initializer = factory.createAssignment(exportedName, node.objectAssignmentInitializer);
                        return ts.setTextRange(factory.createPropertyAssignment(name, initializer), node);
                    }
                    return ts.setTextRange(factory.createPropertyAssignment(name, exportedName), node);
                }
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79:
                    return substituteExpressionIdentifier(node);
                case 208:
                    return substitutePropertyAccessExpression(node);
                case 209:
                    return substituteElementAccessExpression(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            return trySubstituteNamespaceExportedName(node)
                || node;
        }
        function trySubstituteNamespaceExportedName(node) {
            if (enabledSubstitutions & applicableSubstitutions && !ts.isGeneratedIdentifier(node) && !ts.isLocalName(node)) {
                var container = resolver.getReferencedExportContainer(node, false);
                if (container && container.kind !== 308) {
                    var substitute = (applicableSubstitutions & 2 && container.kind === 264) ||
                        (applicableSubstitutions & 8 && container.kind === 263);
                    if (substitute) {
                        return ts.setTextRange(factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(container), node), node);
                    }
                }
            }
            return undefined;
        }
        function substitutePropertyAccessExpression(node) {
            return substituteConstantValue(node);
        }
        function substituteElementAccessExpression(node) {
            return substituteConstantValue(node);
        }
        function safeMultiLineComment(value) {
            return value.replace(/\*\//g, "*_/");
        }
        function substituteConstantValue(node) {
            var constantValue = tryGetConstEnumValue(node);
            if (constantValue !== undefined) {
                ts.setConstantValue(node, constantValue);
                var substitute = typeof constantValue === "string" ? factory.createStringLiteral(constantValue) : factory.createNumericLiteral(constantValue);
                if (!compilerOptions.removeComments) {
                    var originalNode = ts.getOriginalNode(node, ts.isAccessExpression);
                    ts.addSyntheticTrailingComment(substitute, 3, " ".concat(safeMultiLineComment(ts.getTextOfNode(originalNode)), " "));
                }
                return substitute;
            }
            return node;
        }
        function tryGetConstEnumValue(node) {
            if (compilerOptions.isolatedModules) {
                return undefined;
            }
            return ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node) ? resolver.getConstantValue(node) : undefined;
        }
        function shouldEmitAliasDeclaration(node) {
            return ts.isInJSFile(node) ||
                (compilerOptions.preserveValueImports
                    ? resolver.isValueAliasDeclaration(node)
                    : resolver.isReferencedAliasDeclaration(node));
        }
    }
    ts.transformTypeScript = transformTypeScript;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformClassFields(context) {
        var factory = context.factory, hoistVariableDeclaration = context.hoistVariableDeclaration, endLexicalEnvironment = context.endLexicalEnvironment, startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, addBlockScopedVariable = context.addBlockScopedVariable;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var useDefineForClassFields = ts.getUseDefineForClassFields(compilerOptions);
        var shouldTransformInitializersUsingSet = !useDefineForClassFields;
        var shouldTransformInitializersUsingDefine = useDefineForClassFields && languageVersion < 9;
        var shouldTransformInitializers = shouldTransformInitializersUsingSet || shouldTransformInitializersUsingDefine;
        var shouldTransformPrivateElementsOrClassStaticBlocks = languageVersion < 9;
        var shouldTransformAutoAccessors = languageVersion < 99;
        var shouldTransformThisInStaticInitializers = languageVersion < 9;
        var shouldTransformSuperInStaticInitializers = shouldTransformThisInStaticInitializers && languageVersion >= 2;
        var shouldTransformAnything = shouldTransformInitializers ||
            shouldTransformPrivateElementsOrClassStaticBlocks ||
            shouldTransformAutoAccessors;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        var enabledSubstitutions;
        var classAliases;
        var pendingExpressions;
        var pendingStatements;
        var classLexicalEnvironmentStack = [];
        var classLexicalEnvironmentMap = new ts.Map();
        var currentClassLexicalEnvironment;
        var currentClassContainer;
        var currentComputedPropertyNameClassLexicalEnvironment;
        var currentStaticPropertyDeclarationOrStaticBlock;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile || !shouldTransformAnything) {
                return node;
            }
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function visitor(node) {
            if (!(node.transformFlags & 16777216) &&
                !(node.transformFlags & 134234112)) {
                return node;
            }
            switch (node.kind) {
                case 127:
                    return shouldTransformAutoAccessors ? undefined : node;
                case 260:
                    return visitClassDeclaration(node);
                case 228:
                    return visitClassExpression(node);
                case 172:
                    return visitClassStaticBlockDeclaration(node);
                case 169:
                    return visitPropertyDeclaration(node);
                case 240:
                    return visitVariableStatement(node);
                case 80:
                    return visitPrivateIdentifier(node);
                case 208:
                    return visitPropertyAccessExpression(node);
                case 209:
                    return visitElementAccessExpression(node);
                case 221:
                case 222:
                    return visitPreOrPostfixUnaryExpression(node, false);
                case 223:
                    return visitBinaryExpression(node, false);
                case 210:
                    return visitCallExpression(node);
                case 241:
                    return visitExpressionStatement(node);
                case 212:
                    return visitTaggedTemplateExpression(node);
                case 245:
                    return visitForStatement(node);
                case 259:
                case 215:
                case 173:
                case 171:
                case 174:
                case 175: {
                    return setCurrentStaticPropertyDeclarationOrStaticBlockAnd(undefined, fallbackVisitor, node);
                }
                default:
                    return fallbackVisitor(node);
            }
        }
        function fallbackVisitor(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        function discardedValueVisitor(node) {
            switch (node.kind) {
                case 221:
                case 222:
                    return visitPreOrPostfixUnaryExpression(node, true);
                case 223:
                    return visitBinaryExpression(node, true);
                default:
                    return visitor(node);
            }
        }
        function heritageClauseVisitor(node) {
            switch (node.kind) {
                case 294:
                    return ts.visitEachChild(node, heritageClauseVisitor, context);
                case 230:
                    return visitExpressionWithTypeArgumentsInHeritageClause(node);
                default:
                    return visitor(node);
            }
        }
        function assignmentTargetVisitor(node) {
            switch (node.kind) {
                case 207:
                case 206:
                    return visitAssignmentPattern(node);
                default:
                    return visitor(node);
            }
        }
        function classElementVisitor(node) {
            switch (node.kind) {
                case 173:
                    return visitConstructorDeclaration(node);
                case 174:
                case 175:
                case 171:
                    return setCurrentStaticPropertyDeclarationOrStaticBlockAnd(undefined, visitMethodOrAccessorDeclaration, node);
                case 169:
                    return setCurrentStaticPropertyDeclarationOrStaticBlockAnd(undefined, visitPropertyDeclaration, node);
                case 164:
                    return visitComputedPropertyName(node);
                case 237:
                    return node;
                default:
                    return visitor(node);
            }
        }
        function accessorFieldResultVisitor(node) {
            switch (node.kind) {
                case 169:
                    return transformFieldInitializer(node);
                case 174:
                case 175:
                    return classElementVisitor(node);
                default:
                    ts.Debug.assertMissingNode(node, "Expected node to either be a PropertyDeclaration, GetAccessorDeclaration, or SetAccessorDeclaration");
                    break;
            }
        }
        function visitPrivateIdentifier(node) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                return node;
            }
            if (ts.isStatement(node.parent)) {
                return node;
            }
            return ts.setOriginalNode(factory.createIdentifier(""), node);
        }
        function isPrivateIdentifierInExpression(node) {
            return ts.isPrivateIdentifier(node.left)
                && node.operatorToken.kind === 101;
        }
        function transformPrivateIdentifierInInExpression(node) {
            var info = accessPrivateIdentifier(node.left);
            if (info) {
                var receiver = ts.visitNode(node.right, visitor, ts.isExpression);
                return ts.setOriginalNode(context.getEmitHelperFactory().createClassPrivateFieldInHelper(info.brandCheckIdentifier, receiver), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitVariableStatement(node) {
            var savedPendingStatements = pendingStatements;
            pendingStatements = [];
            var visitedNode = ts.visitEachChild(node, visitor, context);
            var statement = ts.some(pendingStatements) ? __spreadArray([visitedNode], pendingStatements, true) :
                visitedNode;
            pendingStatements = savedPendingStatements;
            return statement;
        }
        function visitComputedPropertyName(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            if (ts.some(pendingExpressions)) {
                if (ts.isParenthesizedExpression(expression)) {
                    expression = factory.updateParenthesizedExpression(expression, factory.inlineExpressions(__spreadArray(__spreadArray([], pendingExpressions, true), [expression.expression], false)));
                }
                else {
                    expression = factory.inlineExpressions(__spreadArray(__spreadArray([], pendingExpressions, true), [expression], false));
                }
                pendingExpressions = undefined;
            }
            return factory.updateComputedPropertyName(node, expression);
        }
        function visitConstructorDeclaration(node) {
            if (currentClassContainer) {
                return transformConstructor(node, currentClassContainer);
            }
            return fallbackVisitor(node);
        }
        function visitMethodOrAccessorDeclaration(node) {
            ts.Debug.assert(!ts.hasDecorators(node));
            if (!shouldTransformPrivateElementsOrClassStaticBlocks || !ts.isPrivateIdentifier(node.name)) {
                return ts.visitEachChild(node, classElementVisitor, context);
            }
            var info = accessPrivateIdentifier(node.name);
            ts.Debug.assert(info, "Undeclared private name for property declaration.");
            if (!info.isValid) {
                return node;
            }
            var functionName = getHoistedFunctionName(node);
            if (functionName) {
                getPendingExpressions().push(factory.createAssignment(functionName, factory.createFunctionExpression(ts.filter(node.modifiers, function (m) { return ts.isModifier(m) && !ts.isStaticModifier(m) && !ts.isAccessorModifier(m); }), node.asteriskToken, functionName, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.visitFunctionBody(node.body, visitor, context))));
            }
            return undefined;
        }
        function setCurrentStaticPropertyDeclarationOrStaticBlockAnd(current, visitor, arg) {
            var savedCurrentStaticPropertyDeclarationOrStaticBlock = currentStaticPropertyDeclarationOrStaticBlock;
            currentStaticPropertyDeclarationOrStaticBlock = current;
            var result = visitor(arg);
            currentStaticPropertyDeclarationOrStaticBlock = savedCurrentStaticPropertyDeclarationOrStaticBlock;
            return result;
        }
        function getHoistedFunctionName(node) {
            ts.Debug.assert(ts.isPrivateIdentifier(node.name));
            var info = accessPrivateIdentifier(node.name);
            ts.Debug.assert(info, "Undeclared private name for property declaration.");
            if (info.kind === "m") {
                return info.methodName;
            }
            if (info.kind === "a") {
                if (ts.isGetAccessor(node)) {
                    return info.getterName;
                }
                if (ts.isSetAccessor(node)) {
                    return info.setterName;
                }
            }
        }
        function transformAutoAccessor(node) {
            ts.Debug.assertEachNode(node.modifiers, ts.isModifier);
            var commentRange = ts.getCommentRange(node);
            var sourceMapRange = ts.getSourceMapRange(node);
            var name = node.name;
            var getterName = name;
            var setterName = name;
            if (ts.isComputedPropertyName(name) && !ts.isSimpleInlineableExpression(name.expression)) {
                var temp = factory.createTempVariable(hoistVariableDeclaration);
                ts.setSourceMapRange(temp, name.expression);
                var expression = ts.visitNode(name.expression, visitor, ts.isExpression);
                var assignment = factory.createAssignment(temp, expression);
                ts.setSourceMapRange(assignment, name.expression);
                getterName = factory.updateComputedPropertyName(name, factory.inlineExpressions([assignment, temp]));
                setterName = factory.updateComputedPropertyName(name, temp);
            }
            var backingField = ts.createAccessorPropertyBackingField(factory, node, node.modifiers, node.initializer);
            ts.setOriginalNode(backingField, node);
            ts.setEmitFlags(backingField, 1536);
            ts.setSourceMapRange(backingField, sourceMapRange);
            var getter = ts.createAccessorPropertyGetRedirector(factory, node, node.modifiers, getterName);
            ts.setOriginalNode(getter, node);
            ts.setCommentRange(getter, commentRange);
            ts.setSourceMapRange(getter, sourceMapRange);
            var setter = ts.createAccessorPropertySetRedirector(factory, node, node.modifiers, setterName);
            ts.setOriginalNode(setter, node);
            ts.setEmitFlags(setter, 1536);
            ts.setSourceMapRange(setter, sourceMapRange);
            return ts.visitArray([backingField, getter, setter], accessorFieldResultVisitor, ts.isClassElement);
        }
        function transformPrivateFieldInitializer(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                var info = accessPrivateIdentifier(node.name);
                ts.Debug.assert(info, "Undeclared private name for property declaration.");
                return info.isValid ? undefined : node;
            }
            if (shouldTransformInitializersUsingSet && !ts.isStatic(node)) {
                return factory.updatePropertyDeclaration(node, ts.visitNodes(node.modifiers, visitor, ts.isModifierLike), node.name, undefined, undefined, undefined);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformPublicFieldInitializer(node) {
            if (shouldTransformInitializers) {
                var expr = getPropertyNameExpressionIfNeeded(node.name, !!node.initializer || useDefineForClassFields);
                if (expr) {
                    getPendingExpressions().push(expr);
                }
                if (ts.isStatic(node) && !shouldTransformPrivateElementsOrClassStaticBlocks) {
                    var initializerStatement = transformPropertyOrClassStaticBlock(node, factory.createThis());
                    if (initializerStatement) {
                        var staticBlock = factory.createClassStaticBlockDeclaration(factory.createBlock([initializerStatement]));
                        ts.setOriginalNode(staticBlock, node);
                        ts.setCommentRange(staticBlock, node);
                        ts.setCommentRange(initializerStatement, { pos: -1, end: -1 });
                        ts.setSyntheticLeadingComments(initializerStatement, undefined);
                        ts.setSyntheticTrailingComments(initializerStatement, undefined);
                        return staticBlock;
                    }
                }
                return undefined;
            }
            return ts.visitEachChild(node, classElementVisitor, context);
        }
        function transformFieldInitializer(node) {
            ts.Debug.assert(!ts.hasDecorators(node), "Decorators should already have been transformed and elided.");
            return ts.isPrivateIdentifierClassElementDeclaration(node) ?
                transformPrivateFieldInitializer(node) :
                transformPublicFieldInitializer(node);
        }
        function visitPropertyDeclaration(node) {
            if (shouldTransformAutoAccessors && ts.isAutoAccessorPropertyDeclaration(node)) {
                return transformAutoAccessor(node);
            }
            return transformFieldInitializer(node);
        }
        function createPrivateIdentifierAccess(info, receiver) {
            return createPrivateIdentifierAccessHelper(info, ts.visitNode(receiver, visitor, ts.isExpression));
        }
        function createPrivateIdentifierAccessHelper(info, receiver) {
            ts.setCommentRange(receiver, ts.moveRangePos(receiver, -1));
            switch (info.kind) {
                case "a":
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.getterName);
                case "m":
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.methodName);
                case "f":
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.variableName);
                default:
                    ts.Debug.assertNever(info, "Unknown private element type");
            }
        }
        function visitPropertyAccessExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifier(node.name)) {
                var privateIdentifierInfo = accessPrivateIdentifier(node.name);
                if (privateIdentifierInfo) {
                    return ts.setTextRange(ts.setOriginalNode(createPrivateIdentifierAccess(privateIdentifierInfo, node.expression), node), node);
                }
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node) &&
                ts.isIdentifier(node.name) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                currentClassLexicalEnvironment) {
                var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                if (facts & 1) {
                    return visitInvalidSuperProperty(node);
                }
                if (classConstructor && superClassReference) {
                    var superProperty = factory.createReflectGetCall(superClassReference, factory.createStringLiteralFromNode(node.name), classConstructor);
                    ts.setOriginalNode(superProperty, node.expression);
                    ts.setTextRange(superProperty, node.expression);
                    return superProperty;
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitElementAccessExpression(node) {
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                currentClassLexicalEnvironment) {
                var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                if (facts & 1) {
                    return visitInvalidSuperProperty(node);
                }
                if (classConstructor && superClassReference) {
                    var superProperty = factory.createReflectGetCall(superClassReference, ts.visitNode(node.argumentExpression, visitor, ts.isExpression), classConstructor);
                    ts.setOriginalNode(superProperty, node.expression);
                    ts.setTextRange(superProperty, node.expression);
                    return superProperty;
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitPreOrPostfixUnaryExpression(node, valueIsDiscarded) {
            if (node.operator === 45 ||
                node.operator === 46) {
                var operand = ts.skipParentheses(node.operand);
                if (shouldTransformPrivateElementsOrClassStaticBlocks &&
                    ts.isPrivateIdentifierPropertyAccessExpression(operand)) {
                    var info = void 0;
                    if (info = accessPrivateIdentifier(operand.name)) {
                        var receiver = ts.visitNode(operand.expression, visitor, ts.isExpression);
                        var _a = createCopiableReceiverExpr(receiver), readExpression = _a.readExpression, initializeExpression = _a.initializeExpression;
                        var expression = createPrivateIdentifierAccess(info, readExpression);
                        var temp = ts.isPrefixUnaryExpression(node) || valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                        expression = ts.expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, hoistVariableDeclaration, temp);
                        expression = createPrivateIdentifierAssignment(info, initializeExpression || readExpression, expression, 63);
                        ts.setOriginalNode(expression, node);
                        ts.setTextRange(expression, node);
                        if (temp) {
                            expression = factory.createComma(expression, temp);
                            ts.setTextRange(expression, node);
                        }
                        return expression;
                    }
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(operand) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1) {
                        var expression = visitInvalidSuperProperty(operand);
                        return ts.isPrefixUnaryExpression(node) ?
                            factory.updatePrefixUnaryExpression(node, expression) :
                            factory.updatePostfixUnaryExpression(node, expression);
                    }
                    if (classConstructor && superClassReference) {
                        var setterName = void 0;
                        var getterName = void 0;
                        if (ts.isPropertyAccessExpression(operand)) {
                            if (ts.isIdentifier(operand.name)) {
                                getterName = setterName = factory.createStringLiteralFromNode(operand.name);
                            }
                        }
                        else {
                            if (ts.isSimpleInlineableExpression(operand.argumentExpression)) {
                                getterName = setterName = operand.argumentExpression;
                            }
                            else {
                                getterName = factory.createTempVariable(hoistVariableDeclaration);
                                setterName = factory.createAssignment(getterName, ts.visitNode(operand.argumentExpression, visitor, ts.isExpression));
                            }
                        }
                        if (setterName && getterName) {
                            var expression = factory.createReflectGetCall(superClassReference, getterName, classConstructor);
                            ts.setTextRange(expression, operand);
                            var temp = valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                            expression = ts.expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, hoistVariableDeclaration, temp);
                            expression = factory.createReflectSetCall(superClassReference, setterName, expression, classConstructor);
                            ts.setOriginalNode(expression, node);
                            ts.setTextRange(expression, node);
                            if (temp) {
                                expression = factory.createComma(expression, temp);
                                ts.setTextRange(expression, node);
                            }
                            return expression;
                        }
                    }
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, discardedValueVisitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, discardedValueVisitor, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
        }
        function visitExpressionStatement(node) {
            return factory.updateExpressionStatement(node, ts.visitNode(node.expression, discardedValueVisitor, ts.isExpression));
        }
        function createCopiableReceiverExpr(receiver) {
            var clone = ts.nodeIsSynthesized(receiver) ? receiver : factory.cloneNode(receiver);
            if (ts.isSimpleInlineableExpression(receiver)) {
                return { readExpression: clone, initializeExpression: undefined };
            }
            var readExpression = factory.createTempVariable(hoistVariableDeclaration);
            var initializeExpression = factory.createAssignment(readExpression, clone);
            return { readExpression: readExpression, initializeExpression: initializeExpression };
        }
        function visitCallExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks &&
                ts.isPrivateIdentifierPropertyAccessExpression(node.expression)) {
                var _a = factory.createCallBinding(node.expression, hoistVariableDeclaration, languageVersion), thisArg = _a.thisArg, target = _a.target;
                if (ts.isCallChain(node)) {
                    return factory.updateCallChain(node, factory.createPropertyAccessChain(ts.visitNode(target, visitor), node.questionDotToken, "call"), undefined, undefined, __spreadArray([ts.visitNode(thisArg, visitor, ts.isExpression)], ts.visitNodes(node.arguments, visitor, ts.isExpression), true));
                }
                return factory.updateCallExpression(node, factory.createPropertyAccessExpression(ts.visitNode(target, visitor), "call"), undefined, __spreadArray([ts.visitNode(thisArg, visitor, ts.isExpression)], ts.visitNodes(node.arguments, visitor, ts.isExpression), true));
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node.expression) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.classConstructor)) {
                var invocation = factory.createFunctionCallCall(ts.visitNode(node.expression, visitor, ts.isExpression), currentClassLexicalEnvironment.classConstructor, ts.visitNodes(node.arguments, visitor, ts.isExpression));
                ts.setOriginalNode(invocation, node);
                ts.setTextRange(invocation, node);
                return invocation;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitTaggedTemplateExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks &&
                ts.isPrivateIdentifierPropertyAccessExpression(node.tag)) {
                var _a = factory.createCallBinding(node.tag, hoistVariableDeclaration, languageVersion), thisArg = _a.thisArg, target = _a.target;
                return factory.updateTaggedTemplateExpression(node, factory.createCallExpression(factory.createPropertyAccessExpression(ts.visitNode(target, visitor), "bind"), undefined, [ts.visitNode(thisArg, visitor, ts.isExpression)]), undefined, ts.visitNode(node.template, visitor, ts.isTemplateLiteral));
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node.tag) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.classConstructor)) {
                var invocation = factory.createFunctionBindCall(ts.visitNode(node.tag, visitor, ts.isExpression), currentClassLexicalEnvironment.classConstructor, []);
                ts.setOriginalNode(invocation, node);
                ts.setTextRange(invocation, node);
                return factory.updateTaggedTemplateExpression(node, invocation, undefined, ts.visitNode(node.template, visitor, ts.isTemplateLiteral));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformClassStaticBlockDeclaration(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                if (currentClassLexicalEnvironment) {
                    classLexicalEnvironmentMap.set(ts.getOriginalNodeId(node), currentClassLexicalEnvironment);
                }
                startLexicalEnvironment();
                var statements = setCurrentStaticPropertyDeclarationOrStaticBlockAnd(node, function (statements) { return ts.visitNodes(statements, visitor, ts.isStatement); }, node.body.statements);
                statements = factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
                var iife = factory.createImmediatelyInvokedArrowFunction(statements);
                ts.setOriginalNode(iife, node);
                ts.setTextRange(iife, node);
                ts.addEmitFlags(iife, 2);
                return iife;
            }
        }
        function visitBinaryExpression(node, valueIsDiscarded) {
            if (ts.isDestructuringAssignment(node)) {
                var savedPendingExpressions = pendingExpressions;
                pendingExpressions = undefined;
                node = factory.updateBinaryExpression(node, ts.visitNode(node.left, assignmentTargetVisitor), node.operatorToken, ts.visitNode(node.right, visitor));
                var expr = ts.some(pendingExpressions) ?
                    factory.inlineExpressions(ts.compact(__spreadArray(__spreadArray([], pendingExpressions, true), [node], false))) :
                    node;
                pendingExpressions = savedPendingExpressions;
                return expr;
            }
            if (ts.isAssignmentExpression(node)) {
                if (shouldTransformPrivateElementsOrClassStaticBlocks &&
                    ts.isPrivateIdentifierPropertyAccessExpression(node.left)) {
                    var info = accessPrivateIdentifier(node.left.name);
                    if (info) {
                        return ts.setTextRange(ts.setOriginalNode(createPrivateIdentifierAssignment(info, node.left.expression, node.right, node.operatorToken.kind), node), node);
                    }
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(node.left) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1) {
                        return factory.updateBinaryExpression(node, visitInvalidSuperProperty(node.left), node.operatorToken, ts.visitNode(node.right, visitor, ts.isExpression));
                    }
                    if (classConstructor && superClassReference) {
                        var setterName = ts.isElementAccessExpression(node.left) ? ts.visitNode(node.left.argumentExpression, visitor, ts.isExpression) :
                            ts.isIdentifier(node.left.name) ? factory.createStringLiteralFromNode(node.left.name) :
                                undefined;
                        if (setterName) {
                            var expression = ts.visitNode(node.right, visitor, ts.isExpression);
                            if (ts.isCompoundAssignment(node.operatorToken.kind)) {
                                var getterName = setterName;
                                if (!ts.isSimpleInlineableExpression(setterName)) {
                                    getterName = factory.createTempVariable(hoistVariableDeclaration);
                                    setterName = factory.createAssignment(getterName, setterName);
                                }
                                var superPropertyGet = factory.createReflectGetCall(superClassReference, getterName, classConstructor);
                                ts.setOriginalNode(superPropertyGet, node.left);
                                ts.setTextRange(superPropertyGet, node.left);
                                expression = factory.createBinaryExpression(superPropertyGet, ts.getNonAssignmentOperatorForCompoundAssignment(node.operatorToken.kind), expression);
                                ts.setTextRange(expression, node);
                            }
                            var temp = valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                            if (temp) {
                                expression = factory.createAssignment(temp, expression);
                                ts.setTextRange(temp, node);
                            }
                            expression = factory.createReflectSetCall(superClassReference, setterName, expression, classConstructor);
                            ts.setOriginalNode(expression, node);
                            ts.setTextRange(expression, node);
                            if (temp) {
                                expression = factory.createComma(expression, temp);
                                ts.setTextRange(expression, node);
                            }
                            return expression;
                        }
                    }
                }
            }
            if (shouldTransformPrivateElementsOrClassStaticBlocks &&
                isPrivateIdentifierInExpression(node)) {
                return transformPrivateIdentifierInInExpression(node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function createPrivateIdentifierAssignment(info, receiver, right, operator) {
            receiver = ts.visitNode(receiver, visitor, ts.isExpression);
            right = ts.visitNode(right, visitor, ts.isExpression);
            if (ts.isCompoundAssignment(operator)) {
                var _a = createCopiableReceiverExpr(receiver), readExpression = _a.readExpression, initializeExpression = _a.initializeExpression;
                receiver = initializeExpression || readExpression;
                right = factory.createBinaryExpression(createPrivateIdentifierAccessHelper(info, readExpression), ts.getNonAssignmentOperatorForCompoundAssignment(operator), right);
            }
            ts.setCommentRange(receiver, ts.moveRangePos(receiver, -1));
            switch (info.kind) {
                case "a":
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, info.setterName);
                case "m":
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, undefined);
                case "f":
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, info.variableName);
                default:
                    ts.Debug.assertNever(info, "Unknown private element type");
            }
        }
        function getPrivateInstanceMethodsAndAccessors(node) {
            return ts.filter(node.members, ts.isNonStaticMethodOrAccessorWithPrivateName);
        }
        function getClassFacts(node) {
            var facts = 0;
            var original = ts.getOriginalNode(node);
            if (ts.isClassDeclaration(original) && ts.classOrConstructorParameterIsDecorated(original)) {
                facts |= 1;
            }
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (!ts.isStatic(member))
                    continue;
                if (member.name && (ts.isPrivateIdentifier(member.name) || ts.isAutoAccessorPropertyDeclaration(member)) && shouldTransformPrivateElementsOrClassStaticBlocks) {
                    facts |= 2;
                }
                if (ts.isPropertyDeclaration(member) || ts.isClassStaticBlockDeclaration(member)) {
                    if (shouldTransformThisInStaticInitializers && member.transformFlags & 16384) {
                        facts |= 8;
                        if (!(facts & 1)) {
                            facts |= 2;
                        }
                    }
                    if (shouldTransformSuperInStaticInitializers && member.transformFlags & 134217728) {
                        if (!(facts & 1)) {
                            facts |= 2 | 4;
                        }
                    }
                }
            }
            return facts;
        }
        function visitExpressionWithTypeArgumentsInHeritageClause(node) {
            var facts = (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.facts) || 0;
            if (facts & 4) {
                var temp = factory.createTempVariable(hoistVariableDeclaration, true);
                getClassLexicalEnvironment().superClassReference = temp;
                return factory.updateExpressionWithTypeArguments(node, factory.createAssignment(temp, ts.visitNode(node.expression, visitor, ts.isExpression)), undefined);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitInNewClassLexicalEnvironment(node, visitor) {
            var savedCurrentClassContainer = currentClassContainer;
            var savedPendingExpressions = pendingExpressions;
            currentClassContainer = node;
            pendingExpressions = undefined;
            startClassLexicalEnvironment();
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                var name = ts.getNameOfDeclaration(node);
                if (name && ts.isIdentifier(name)) {
                    getPrivateIdentifierEnvironment().className = name;
                }
                var privateInstanceMethodsAndAccessors = getPrivateInstanceMethodsAndAccessors(node);
                if (ts.some(privateInstanceMethodsAndAccessors)) {
                    getPrivateIdentifierEnvironment().weakSetName = createHoistedVariableForClass("instances", privateInstanceMethodsAndAccessors[0].name);
                }
            }
            var facts = getClassFacts(node);
            if (facts) {
                getClassLexicalEnvironment().facts = facts;
            }
            if (facts & 8) {
                enableSubstitutionForClassStaticThisOrSuperReference();
            }
            var result = visitor(node, facts);
            endClassLexicalEnvironment();
            currentClassContainer = savedCurrentClassContainer;
            pendingExpressions = savedPendingExpressions;
            return result;
        }
        function visitClassDeclaration(node) {
            return visitInNewClassLexicalEnvironment(node, visitClassDeclarationInNewClassLexicalEnvironment);
        }
        function visitClassDeclarationInNewClassLexicalEnvironment(node, facts) {
            var pendingClassReferenceAssignment;
            if (facts & 2) {
                var temp = factory.createTempVariable(hoistVariableDeclaration, true);
                getClassLexicalEnvironment().classConstructor = factory.cloneNode(temp);
                pendingClassReferenceAssignment = factory.createAssignment(temp, factory.getInternalName(node));
            }
            var modifiers = ts.visitNodes(node.modifiers, visitor, ts.isModifierLike);
            var heritageClauses = ts.visitNodes(node.heritageClauses, heritageClauseVisitor, ts.isHeritageClause);
            var _a = transformClassMembers(node), members = _a.members, prologue = _a.prologue;
            var classDecl = factory.updateClassDeclaration(node, modifiers, node.name, undefined, heritageClauses, members);
            var statements = [];
            if (prologue) {
                statements.push(factory.createExpressionStatement(prologue));
            }
            statements.push(classDecl);
            if (pendingClassReferenceAssignment) {
                getPendingExpressions().unshift(pendingClassReferenceAssignment);
            }
            if (ts.some(pendingExpressions)) {
                statements.push(factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions)));
            }
            if (shouldTransformInitializersUsingSet || shouldTransformPrivateElementsOrClassStaticBlocks) {
                var staticProperties = ts.getStaticPropertiesAndClassStaticBlock(node);
                if (ts.some(staticProperties)) {
                    addPropertyOrClassStaticBlockStatements(statements, staticProperties, factory.getInternalName(node));
                }
            }
            return statements;
        }
        function visitClassExpression(node) {
            return visitInNewClassLexicalEnvironment(node, visitClassExpressionInNewClassLexicalEnvironment);
        }
        function visitClassExpressionInNewClassLexicalEnvironment(node, facts) {
            var isDecoratedClassDeclaration = !!(facts & 1);
            var staticPropertiesOrClassStaticBlocks = ts.getStaticPropertiesAndClassStaticBlock(node);
            var isClassWithConstructorReference = resolver.getNodeCheckFlags(node) & 16777216;
            var temp;
            function createClassTempVar() {
                var classCheckFlags = resolver.getNodeCheckFlags(node);
                var isClassWithConstructorReference = classCheckFlags & 16777216;
                var requiresBlockScopedVar = classCheckFlags & 524288;
                return factory.createTempVariable(requiresBlockScopedVar ? addBlockScopedVariable : hoistVariableDeclaration, !!isClassWithConstructorReference);
            }
            if (facts & 2) {
                temp = createClassTempVar();
                getClassLexicalEnvironment().classConstructor = factory.cloneNode(temp);
            }
            var modifiers = ts.visitNodes(node.modifiers, visitor, ts.isModifierLike);
            var heritageClauses = ts.visitNodes(node.heritageClauses, heritageClauseVisitor, ts.isHeritageClause);
            var _a = transformClassMembers(node), members = _a.members, prologue = _a.prologue;
            var classExpression = factory.updateClassExpression(node, modifiers, node.name, undefined, heritageClauses, members);
            var expressions = [];
            if (prologue) {
                expressions.push(prologue);
            }
            var hasTransformableStatics = shouldTransformPrivateElementsOrClassStaticBlocks &&
                ts.some(staticPropertiesOrClassStaticBlocks, function (node) {
                    return ts.isClassStaticBlockDeclaration(node) ||
                        ts.isPrivateIdentifierClassElementDeclaration(node) ||
                        shouldTransformInitializers && ts.isInitializedProperty(node);
                });
            if (hasTransformableStatics || ts.some(pendingExpressions)) {
                if (isDecoratedClassDeclaration) {
                    ts.Debug.assertIsDefined(pendingStatements, "Decorated classes transformed by TypeScript are expected to be within a variable declaration.");
                    if (pendingStatements && pendingExpressions && ts.some(pendingExpressions)) {
                        pendingStatements.push(factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions)));
                    }
                    if (pendingStatements && ts.some(staticPropertiesOrClassStaticBlocks)) {
                        addPropertyOrClassStaticBlockStatements(pendingStatements, staticPropertiesOrClassStaticBlocks, factory.getInternalName(node));
                    }
                    if (temp) {
                        expressions.push(ts.startOnNewLine(factory.createAssignment(temp, classExpression)), ts.startOnNewLine(temp));
                    }
                    else {
                        expressions.push(classExpression);
                        if (prologue) {
                            ts.startOnNewLine(classExpression);
                        }
                    }
                }
                else {
                    temp || (temp = createClassTempVar());
                    if (isClassWithConstructorReference) {
                        enableSubstitutionForClassAliases();
                        var alias = factory.cloneNode(temp);
                        alias.autoGenerateFlags &= ~8;
                        classAliases[ts.getOriginalNodeId(node)] = alias;
                    }
                    ts.setEmitFlags(classExpression, 65536 | ts.getEmitFlags(classExpression));
                    expressions.push(ts.startOnNewLine(factory.createAssignment(temp, classExpression)));
                    ts.addRange(expressions, ts.map(pendingExpressions, ts.startOnNewLine));
                    ts.addRange(expressions, generateInitializedPropertyExpressionsOrClassStaticBlock(staticPropertiesOrClassStaticBlocks, temp));
                    expressions.push(ts.startOnNewLine(temp));
                }
            }
            else {
                expressions.push(classExpression);
                if (prologue) {
                    ts.startOnNewLine(classExpression);
                }
            }
            return factory.inlineExpressions(expressions);
        }
        function visitClassStaticBlockDeclaration(node) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                return ts.visitEachChild(node, visitor, context);
            }
            return undefined;
        }
        function transformClassMembers(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                    var member = _a[_i];
                    if (ts.isPrivateIdentifierClassElementDeclaration(member)) {
                        addPrivateIdentifierToEnvironment(member, member.name, addPrivateIdentifierClassElementToEnvironment);
                    }
                }
                if (ts.some(getPrivateInstanceMethodsAndAccessors(node))) {
                    createBrandCheckWeakSetForPrivateMethods();
                }
                if (shouldTransformAutoAccessors) {
                    for (var _b = 0, _c = node.members; _b < _c.length; _b++) {
                        var member = _c[_b];
                        if (ts.isAutoAccessorPropertyDeclaration(member)) {
                            var storageName = factory.getGeneratedPrivateNameForNode(member.name, undefined, "_accessor_storage");
                            addPrivateIdentifierToEnvironment(member, storageName, addPrivateIdentifierPropertyDeclarationToEnvironment);
                        }
                    }
                }
            }
            var members = ts.visitNodes(node.members, classElementVisitor, ts.isClassElement);
            var syntheticConstructor;
            if (!ts.some(members, ts.isConstructorDeclaration)) {
                syntheticConstructor = transformConstructor(undefined, node);
            }
            var prologue;
            var syntheticStaticBlock;
            if (!shouldTransformPrivateElementsOrClassStaticBlocks && ts.some(pendingExpressions)) {
                var statement = factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions));
                if (statement.transformFlags & 134234112) {
                    var temp = factory.createTempVariable(hoistVariableDeclaration);
                    var arrow = factory.createArrowFunction(undefined, undefined, [], undefined, undefined, factory.createBlock([statement]));
                    prologue = factory.createAssignment(temp, arrow);
                    statement = factory.createExpressionStatement(factory.createCallExpression(temp, undefined, []));
                }
                var block = factory.createBlock([statement]);
                syntheticStaticBlock = factory.createClassStaticBlockDeclaration(block);
                pendingExpressions = undefined;
            }
            if (syntheticConstructor || syntheticStaticBlock) {
                var membersArray = void 0;
                membersArray = ts.append(membersArray, syntheticConstructor);
                membersArray = ts.append(membersArray, syntheticStaticBlock);
                membersArray = ts.addRange(membersArray, members);
                members = ts.setTextRange(factory.createNodeArray(membersArray), node.members);
            }
            return { members: members, prologue: prologue };
        }
        function createBrandCheckWeakSetForPrivateMethods() {
            var weakSetName = getPrivateIdentifierEnvironment().weakSetName;
            ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
            getPendingExpressions().push(factory.createAssignment(weakSetName, factory.createNewExpression(factory.createIdentifier("WeakSet"), undefined, [])));
        }
        function isClassElementThatRequiresConstructorStatement(member) {
            if (ts.isStatic(member) || ts.hasAbstractModifier(ts.getOriginalNode(member))) {
                return false;
            }
            return shouldTransformInitializersUsingDefine && ts.isPropertyDeclaration(member) ||
                shouldTransformInitializersUsingSet && ts.isInitializedProperty(member) ||
                shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierClassElementDeclaration(member) ||
                shouldTransformPrivateElementsOrClassStaticBlocks && shouldTransformAutoAccessors && ts.isAutoAccessorPropertyDeclaration(member);
        }
        function transformConstructor(constructor, container) {
            constructor = ts.visitNode(constructor, visitor, ts.isConstructorDeclaration);
            if (!ts.some(container.members, isClassElementThatRequiresConstructorStatement)) {
                return constructor;
            }
            var extendsClauseElement = ts.getEffectiveBaseTypeNode(container);
            var isDerivedClass = !!(extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 104);
            var parameters = ts.visitParameterList(constructor ? constructor.parameters : undefined, visitor, context);
            var body = transformConstructorBody(container, constructor, isDerivedClass);
            if (!body) {
                return constructor;
            }
            if (constructor) {
                ts.Debug.assert(parameters);
                return factory.updateConstructorDeclaration(constructor, undefined, parameters, body);
            }
            return ts.startOnNewLine(ts.setOriginalNode(ts.setTextRange(factory.createConstructorDeclaration(undefined, parameters !== null && parameters !== void 0 ? parameters : [], body), constructor || container), constructor));
        }
        function transformConstructorBody(node, constructor, isDerivedClass) {
            var _a, _b;
            var properties = ts.getProperties(node, false, false);
            if (!useDefineForClassFields) {
                properties = ts.filter(properties, function (property) { return !!property.initializer || ts.isPrivateIdentifier(property.name) || ts.hasAccessorModifier(property); });
            }
            var privateMethodsAndAccessors = getPrivateInstanceMethodsAndAccessors(node);
            var needsConstructorBody = ts.some(properties) || ts.some(privateMethodsAndAccessors);
            if (!constructor && !needsConstructorBody) {
                return ts.visitFunctionBody(undefined, visitor, context);
            }
            resumeLexicalEnvironment();
            var needsSyntheticConstructor = !constructor && isDerivedClass;
            var indexOfFirstStatementAfterSuperAndPrologue = 0;
            var prologueStatementCount = 0;
            var superStatementIndex = -1;
            var statements = [];
            if ((_a = constructor === null || constructor === void 0 ? void 0 : constructor.body) === null || _a === void 0 ? void 0 : _a.statements) {
                prologueStatementCount = factory.copyPrologue(constructor.body.statements, statements, false, visitor);
                superStatementIndex = ts.findSuperStatementIndex(constructor.body.statements, prologueStatementCount);
                if (superStatementIndex >= 0) {
                    indexOfFirstStatementAfterSuperAndPrologue = superStatementIndex + 1;
                    statements = __spreadArray(__spreadArray(__spreadArray([], statements.slice(0, prologueStatementCount), true), ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, prologueStatementCount, indexOfFirstStatementAfterSuperAndPrologue - prologueStatementCount), true), statements.slice(prologueStatementCount), true);
                }
                else if (prologueStatementCount >= 0) {
                    indexOfFirstStatementAfterSuperAndPrologue = prologueStatementCount;
                }
            }
            if (needsSyntheticConstructor) {
                statements.push(factory.createExpressionStatement(factory.createCallExpression(factory.createSuper(), undefined, [factory.createSpreadElement(factory.createIdentifier("arguments"))])));
            }
            var parameterPropertyDeclarationCount = 0;
            if (constructor === null || constructor === void 0 ? void 0 : constructor.body) {
                if (useDefineForClassFields) {
                    statements = statements.filter(function (statement) { return !ts.isParameterPropertyDeclaration(ts.getOriginalNode(statement), constructor); });
                }
                else {
                    for (var _i = 0, _c = constructor.body.statements; _i < _c.length; _i++) {
                        var statement = _c[_i];
                        if (ts.isParameterPropertyDeclaration(ts.getOriginalNode(statement), constructor)) {
                            parameterPropertyDeclarationCount++;
                        }
                    }
                    if (parameterPropertyDeclarationCount > 0) {
                        var parameterProperties = ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, indexOfFirstStatementAfterSuperAndPrologue, parameterPropertyDeclarationCount);
                        if (superStatementIndex >= 0) {
                            ts.addRange(statements, parameterProperties);
                        }
                        else {
                            var superAndPrologueStatementCount = prologueStatementCount;
                            if (needsSyntheticConstructor)
                                superAndPrologueStatementCount++;
                            statements = __spreadArray(__spreadArray(__spreadArray([], statements.slice(0, superAndPrologueStatementCount), true), parameterProperties, true), statements.slice(superAndPrologueStatementCount), true);
                        }
                        indexOfFirstStatementAfterSuperAndPrologue += parameterPropertyDeclarationCount;
                    }
                }
            }
            var receiver = factory.createThis();
            addMethodStatements(statements, privateMethodsAndAccessors, receiver);
            addPropertyOrClassStaticBlockStatements(statements, properties, receiver);
            if (constructor) {
                ts.addRange(statements, ts.visitNodes(constructor.body.statements, visitBodyStatement, ts.isStatement, indexOfFirstStatementAfterSuperAndPrologue));
            }
            statements = factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
            if (statements.length === 0 && !constructor) {
                return undefined;
            }
            var multiLine = (constructor === null || constructor === void 0 ? void 0 : constructor.body) && constructor.body.statements.length >= statements.length ?
                (_b = constructor.body.multiLine) !== null && _b !== void 0 ? _b : statements.length > 0 :
                statements.length > 0;
            return ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), constructor ? constructor.body.statements : node.members), multiLine), constructor ? constructor.body : undefined);
            function visitBodyStatement(statement) {
                if (useDefineForClassFields && ts.isParameterPropertyDeclaration(ts.getOriginalNode(statement), constructor)) {
                    return undefined;
                }
                return visitor(statement);
            }
        }
        function addPropertyOrClassStaticBlockStatements(statements, properties, receiver) {
            for (var _i = 0, properties_7 = properties; _i < properties_7.length; _i++) {
                var property = properties_7[_i];
                if (ts.isStatic(property) && !shouldTransformPrivateElementsOrClassStaticBlocks && !useDefineForClassFields) {
                    continue;
                }
                var statement = transformPropertyOrClassStaticBlock(property, receiver);
                if (!statement) {
                    continue;
                }
                statements.push(statement);
            }
        }
        function transformPropertyOrClassStaticBlock(property, receiver) {
            var expression = ts.isClassStaticBlockDeclaration(property) ?
                transformClassStaticBlockDeclaration(property) :
                transformProperty(property, receiver);
            if (!expression) {
                return undefined;
            }
            var statement = factory.createExpressionStatement(expression);
            ts.setOriginalNode(statement, property);
            ts.addEmitFlags(statement, ts.getEmitFlags(property) & 1536);
            ts.setSourceMapRange(statement, ts.moveRangePastModifiers(property));
            ts.setCommentRange(statement, property);
            ts.setSyntheticLeadingComments(expression, undefined);
            ts.setSyntheticTrailingComments(expression, undefined);
            return statement;
        }
        function generateInitializedPropertyExpressionsOrClassStaticBlock(propertiesOrClassStaticBlocks, receiver) {
            var expressions = [];
            for (var _i = 0, propertiesOrClassStaticBlocks_1 = propertiesOrClassStaticBlocks; _i < propertiesOrClassStaticBlocks_1.length; _i++) {
                var property = propertiesOrClassStaticBlocks_1[_i];
                var expression = ts.isClassStaticBlockDeclaration(property) ? transformClassStaticBlockDeclaration(property) : transformProperty(property, receiver);
                if (!expression) {
                    continue;
                }
                ts.startOnNewLine(expression);
                ts.setOriginalNode(expression, property);
                ts.addEmitFlags(expression, ts.getEmitFlags(property) & 1536);
                ts.setSourceMapRange(expression, ts.moveRangePastModifiers(property));
                ts.setCommentRange(expression, property);
                expressions.push(expression);
            }
            return expressions;
        }
        function transformProperty(property, receiver) {
            var savedCurrentStaticPropertyDeclarationOrStaticBlock = currentStaticPropertyDeclarationOrStaticBlock;
            var transformed = transformPropertyWorker(property, receiver);
            if (transformed && ts.hasStaticModifier(property) && (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.facts)) {
                ts.setOriginalNode(transformed, property);
                ts.addEmitFlags(transformed, 2);
                classLexicalEnvironmentMap.set(ts.getOriginalNodeId(transformed), currentClassLexicalEnvironment);
            }
            currentStaticPropertyDeclarationOrStaticBlock = savedCurrentStaticPropertyDeclarationOrStaticBlock;
            return transformed;
        }
        function transformPropertyWorker(property, receiver) {
            var _a;
            var emitAssignment = !useDefineForClassFields;
            var propertyName = ts.hasAccessorModifier(property) ?
                factory.getGeneratedPrivateNameForNode(property.name) :
                ts.isComputedPropertyName(property.name) && !ts.isSimpleInlineableExpression(property.name.expression) ?
                    factory.updateComputedPropertyName(property.name, factory.getGeneratedNameForNode(property.name)) :
                    property.name;
            if (ts.hasStaticModifier(property)) {
                currentStaticPropertyDeclarationOrStaticBlock = property;
            }
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifier(propertyName)) {
                var privateIdentifierInfo = accessPrivateIdentifier(propertyName);
                if (privateIdentifierInfo) {
                    if (privateIdentifierInfo.kind === "f") {
                        if (!privateIdentifierInfo.isStatic) {
                            return createPrivateInstanceFieldInitializer(receiver, ts.visitNode(property.initializer, visitor, ts.isExpression), privateIdentifierInfo.brandCheckIdentifier);
                        }
                        else {
                            return createPrivateStaticFieldInitializer(privateIdentifierInfo.variableName, ts.visitNode(property.initializer, visitor, ts.isExpression));
                        }
                    }
                    else {
                        return undefined;
                    }
                }
                else {
                    ts.Debug.fail("Undeclared private name for property declaration.");
                }
            }
            if ((ts.isPrivateIdentifier(propertyName) || ts.hasStaticModifier(property)) && !property.initializer) {
                return undefined;
            }
            var propertyOriginalNode = ts.getOriginalNode(property);
            if (ts.hasSyntacticModifier(propertyOriginalNode, 256)) {
                return undefined;
            }
            var initializer = property.initializer || emitAssignment ? (_a = ts.visitNode(property.initializer, visitor, ts.isExpression)) !== null && _a !== void 0 ? _a : factory.createVoidZero()
                : ts.isParameterPropertyDeclaration(propertyOriginalNode, propertyOriginalNode.parent) && ts.isIdentifier(propertyName) ? propertyName
                    : factory.createVoidZero();
            if (emitAssignment || ts.isPrivateIdentifier(propertyName)) {
                var memberAccess = ts.createMemberAccessForPropertyName(factory, receiver, propertyName, propertyName);
                return factory.createAssignment(memberAccess, initializer);
            }
            else {
                var name = ts.isComputedPropertyName(propertyName) ? propertyName.expression
                    : ts.isIdentifier(propertyName) ? factory.createStringLiteral(ts.unescapeLeadingUnderscores(propertyName.escapedText))
                        : propertyName;
                var descriptor = factory.createPropertyDescriptor({ value: initializer, configurable: true, writable: true, enumerable: true });
                return factory.createObjectDefinePropertyCall(receiver, name, descriptor);
            }
        }
        function enableSubstitutionForClassAliases() {
            if ((enabledSubstitutions & 1) === 0) {
                enabledSubstitutions |= 1;
                context.enableSubstitution(79);
                classAliases = [];
            }
        }
        function enableSubstitutionForClassStaticThisOrSuperReference() {
            if ((enabledSubstitutions & 2) === 0) {
                enabledSubstitutions |= 2;
                context.enableSubstitution(108);
                context.enableEmitNotification(259);
                context.enableEmitNotification(215);
                context.enableEmitNotification(173);
                context.enableEmitNotification(174);
                context.enableEmitNotification(175);
                context.enableEmitNotification(171);
                context.enableEmitNotification(169);
                context.enableEmitNotification(164);
            }
        }
        function addMethodStatements(statements, methods, receiver) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks || !ts.some(methods)) {
                return;
            }
            var weakSetName = getPrivateIdentifierEnvironment().weakSetName;
            ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
            statements.push(factory.createExpressionStatement(createPrivateInstanceMethodInitializer(receiver, weakSetName)));
        }
        function visitInvalidSuperProperty(node) {
            return ts.isPropertyAccessExpression(node) ?
                factory.updatePropertyAccessExpression(node, factory.createVoidZero(), node.name) :
                factory.updateElementAccessExpression(node, factory.createVoidZero(), ts.visitNode(node.argumentExpression, visitor, ts.isExpression));
        }
        function onEmitNode(hint, node, emitCallback) {
            var original = ts.getOriginalNode(node);
            if (original.id) {
                var classLexicalEnvironment = classLexicalEnvironmentMap.get(original.id);
                if (classLexicalEnvironment) {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = classLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = classLexicalEnvironment;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
            }
            switch (node.kind) {
                case 215:
                    if (ts.isArrowFunction(original) || ts.getEmitFlags(node) & 262144) {
                        break;
                    }
                case 259:
                case 173: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = undefined;
                    currentComputedPropertyNameClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
                case 174:
                case 175:
                case 171:
                case 169: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = currentClassLexicalEnvironment;
                    currentClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
                case 164: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79:
                    return substituteExpressionIdentifier(node);
                case 108:
                    return substituteThisExpression(node);
            }
            return node;
        }
        function substituteThisExpression(node) {
            if (enabledSubstitutions & 2 && currentClassLexicalEnvironment) {
                var facts = currentClassLexicalEnvironment.facts, classConstructor = currentClassLexicalEnvironment.classConstructor;
                if (facts & 1) {
                    return factory.createParenthesizedExpression(factory.createVoidZero());
                }
                if (classConstructor) {
                    return ts.setTextRange(ts.setOriginalNode(factory.cloneNode(classConstructor), node), node);
                }
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            return trySubstituteClassAlias(node) || node;
        }
        function trySubstituteClassAlias(node) {
            if (enabledSubstitutions & 1) {
                if (resolver.getNodeCheckFlags(node) & 33554432) {
                    var declaration = resolver.getReferencedValueDeclaration(node);
                    if (declaration) {
                        var classAlias = classAliases[declaration.id];
                        if (classAlias) {
                            var clone_2 = factory.cloneNode(classAlias);
                            ts.setSourceMapRange(clone_2, node);
                            ts.setCommentRange(clone_2, node);
                            return clone_2;
                        }
                    }
                }
            }
            return undefined;
        }
        function getPropertyNameExpressionIfNeeded(name, shouldHoist) {
            if (ts.isComputedPropertyName(name)) {
                var expression = ts.visitNode(name.expression, visitor, ts.isExpression);
                var innerExpression = ts.skipPartiallyEmittedExpressions(expression);
                var inlinable = ts.isSimpleInlineableExpression(innerExpression);
                var alreadyTransformed = ts.isAssignmentExpression(innerExpression) && ts.isGeneratedIdentifier(innerExpression.left);
                if (!alreadyTransformed && !inlinable && shouldHoist) {
                    var generatedName = factory.getGeneratedNameForNode(name);
                    if (resolver.getNodeCheckFlags(name) & 524288) {
                        addBlockScopedVariable(generatedName);
                    }
                    else {
                        hoistVariableDeclaration(generatedName);
                    }
                    return factory.createAssignment(generatedName, expression);
                }
                return (inlinable || ts.isIdentifier(innerExpression)) ? undefined : expression;
            }
        }
        function startClassLexicalEnvironment() {
            classLexicalEnvironmentStack.push(currentClassLexicalEnvironment);
            currentClassLexicalEnvironment = undefined;
        }
        function endClassLexicalEnvironment() {
            currentClassLexicalEnvironment = classLexicalEnvironmentStack.pop();
        }
        function getClassLexicalEnvironment() {
            return currentClassLexicalEnvironment || (currentClassLexicalEnvironment = {
                facts: 0,
                classConstructor: undefined,
                superClassReference: undefined,
                privateIdentifierEnvironment: undefined,
            });
        }
        function getPrivateIdentifierEnvironment() {
            var lex = getClassLexicalEnvironment();
            lex.privateIdentifierEnvironment || (lex.privateIdentifierEnvironment = {
                className: undefined,
                weakSetName: undefined,
                identifiers: undefined,
                generatedIdentifiers: undefined,
            });
            return lex.privateIdentifierEnvironment;
        }
        function getPendingExpressions() {
            return pendingExpressions !== null && pendingExpressions !== void 0 ? pendingExpressions : (pendingExpressions = []);
        }
        function addPrivateIdentifierClassElementToEnvironment(node, name, lex, privateEnv, isStatic, isValid, previousInfo) {
            if (ts.isAutoAccessorPropertyDeclaration(node)) {
                addPrivateIdentifierAutoAccessorPropertyDeclarationToEnvironment(node, name, lex, privateEnv, isStatic, isValid, previousInfo);
            }
            else if (ts.isPropertyDeclaration(node)) {
                addPrivateIdentifierPropertyDeclarationToEnvironment(node, name, lex, privateEnv, isStatic, isValid, previousInfo);
            }
            else if (ts.isMethodDeclaration(node)) {
                addPrivateIdentifierMethodDeclarationToEnvironment(node, name, lex, privateEnv, isStatic, isValid, previousInfo);
            }
            else if (ts.isGetAccessorDeclaration(node)) {
                addPrivateIdentifierGetAccessorDeclarationToEnvironment(node, name, lex, privateEnv, isStatic, isValid, previousInfo);
            }
            else if (ts.isSetAccessorDeclaration(node)) {
                addPrivateIdentifierSetAccessorDeclarationToEnvironment(node, name, lex, privateEnv, isStatic, isValid, previousInfo);
            }
        }
        function addPrivateIdentifierPropertyDeclarationToEnvironment(_node, name, lex, privateEnv, isStatic, isValid, _previousInfo) {
            if (isStatic) {
                ts.Debug.assert(lex.classConstructor, "classConstructor should be set in private identifier environment");
                var variableName = createHoistedVariableForPrivateName(name);
                setPrivateIdentifier(privateEnv, name, {
                    kind: "f",
                    brandCheckIdentifier: lex.classConstructor,
                    variableName: variableName,
                    isStatic: true,
                    isValid: isValid,
                });
            }
            else {
                var weakMapName = createHoistedVariableForPrivateName(name);
                setPrivateIdentifier(privateEnv, name, {
                    kind: "f",
                    brandCheckIdentifier: weakMapName,
                    variableName: undefined,
                    isStatic: false,
                    isValid: isValid,
                });
                getPendingExpressions().push(factory.createAssignment(weakMapName, factory.createNewExpression(factory.createIdentifier("WeakMap"), undefined, [])));
            }
        }
        function addPrivateIdentifierMethodDeclarationToEnvironment(_node, name, lex, privateEnv, isStatic, isValid, _previousInfo) {
            var methodName = createHoistedVariableForPrivateName(name);
            var brandCheckIdentifier = isStatic ?
                ts.Debug.checkDefined(lex.classConstructor, "classConstructor should be set in private identifier environment") :
                ts.Debug.checkDefined(privateEnv.weakSetName, "weakSetName should be set in private identifier environment");
            setPrivateIdentifier(privateEnv, name, {
                kind: "m",
                methodName: methodName,
                brandCheckIdentifier: brandCheckIdentifier,
                isStatic: isStatic,
                isValid: isValid,
            });
        }
        function addPrivateIdentifierGetAccessorDeclarationToEnvironment(_node, name, lex, privateEnv, isStatic, isValid, previousInfo) {
            var getterName = createHoistedVariableForPrivateName(name, "_get");
            var brandCheckIdentifier = isStatic ?
                ts.Debug.checkDefined(lex.classConstructor, "classConstructor should be set in private identifier environment") :
                ts.Debug.checkDefined(privateEnv.weakSetName, "weakSetName should be set in private identifier environment");
            if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" && previousInfo.isStatic === isStatic && !previousInfo.getterName) {
                previousInfo.getterName = getterName;
            }
            else {
                setPrivateIdentifier(privateEnv, name, {
                    kind: "a",
                    getterName: getterName,
                    setterName: undefined,
                    brandCheckIdentifier: brandCheckIdentifier,
                    isStatic: isStatic,
                    isValid: isValid,
                });
            }
        }
        function addPrivateIdentifierSetAccessorDeclarationToEnvironment(_node, name, lex, privateEnv, isStatic, isValid, previousInfo) {
            var setterName = createHoistedVariableForPrivateName(name, "_set");
            var brandCheckIdentifier = isStatic ?
                ts.Debug.checkDefined(lex.classConstructor, "classConstructor should be set in private identifier environment") :
                ts.Debug.checkDefined(privateEnv.weakSetName, "weakSetName should be set in private identifier environment");
            if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" && previousInfo.isStatic === isStatic && !previousInfo.setterName) {
                previousInfo.setterName = setterName;
            }
            else {
                setPrivateIdentifier(privateEnv, name, {
                    kind: "a",
                    getterName: undefined,
                    setterName: setterName,
                    brandCheckIdentifier: brandCheckIdentifier,
                    isStatic: isStatic,
                    isValid: isValid,
                });
            }
        }
        function addPrivateIdentifierAutoAccessorPropertyDeclarationToEnvironment(_node, name, lex, privateEnv, isStatic, isValid, _previousInfo) {
            var getterName = createHoistedVariableForPrivateName(name, "_get");
            var setterName = createHoistedVariableForPrivateName(name, "_set");
            var brandCheckIdentifier = isStatic ?
                ts.Debug.checkDefined(lex.classConstructor, "classConstructor should be set in private identifier environment") :
                ts.Debug.checkDefined(privateEnv.weakSetName, "weakSetName should be set in private identifier environment");
            setPrivateIdentifier(privateEnv, name, {
                kind: "a",
                getterName: getterName,
                setterName: setterName,
                brandCheckIdentifier: brandCheckIdentifier,
                isStatic: isStatic,
                isValid: isValid,
            });
        }
        function addPrivateIdentifierToEnvironment(node, name, addDeclaration) {
            var lex = getClassLexicalEnvironment();
            var privateEnv = getPrivateIdentifierEnvironment();
            var previousInfo = getPrivateIdentifier(privateEnv, name);
            var isStatic = ts.hasStaticModifier(node);
            var isValid = !isReservedPrivateName(name) && previousInfo === undefined;
            addDeclaration(node, name, lex, privateEnv, isStatic, isValid, previousInfo);
        }
        function createHoistedVariableForClass(name, node, suffix) {
            var className = getPrivateIdentifierEnvironment().className;
            var prefix = className ? { prefix: "_", node: className, suffix: "_" } : "_";
            var identifier = typeof name === "object" ? factory.getGeneratedNameForNode(name, 16 | 8, prefix, suffix) :
                typeof name === "string" ? factory.createUniqueName(name, 16, prefix, suffix) :
                    factory.createTempVariable(undefined, true, prefix, suffix);
            if (resolver.getNodeCheckFlags(node) & 524288) {
                addBlockScopedVariable(identifier);
            }
            else {
                hoistVariableDeclaration(identifier);
            }
            return identifier;
        }
        function createHoistedVariableForPrivateName(name, suffix) {
            var _a;
            var text = ts.tryGetTextOfPropertyName(name);
            return createHoistedVariableForClass((_a = text === null || text === void 0 ? void 0 : text.substring(1)) !== null && _a !== void 0 ? _a : name, name, suffix);
        }
        function accessPrivateIdentifier(name) {
            if (ts.isGeneratedPrivateIdentifier(name)) {
                return accessGeneratedPrivateIdentifier(name);
            }
            else {
                return accessPrivateIdentifierByText(name.escapedText);
            }
        }
        function accessPrivateIdentifierByText(text) {
            return accessPrivateIdentifierWorker(getPrivateIdentifierInfo, text);
        }
        function accessGeneratedPrivateIdentifier(name) {
            return accessPrivateIdentifierWorker(getGeneratedPrivateIdentifierInfo, ts.getNodeForGeneratedName(name));
        }
        function accessPrivateIdentifierWorker(getPrivateIdentifierInfo, privateIdentifierKey) {
            if (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.privateIdentifierEnvironment) {
                var info = getPrivateIdentifierInfo(currentClassLexicalEnvironment.privateIdentifierEnvironment, privateIdentifierKey);
                if (info) {
                    return info;
                }
            }
            for (var i = classLexicalEnvironmentStack.length - 1; i >= 0; --i) {
                var env = classLexicalEnvironmentStack[i];
                if (!env) {
                    continue;
                }
                if (env.privateIdentifierEnvironment) {
                    var info = getPrivateIdentifierInfo(env.privateIdentifierEnvironment, privateIdentifierKey);
                    if (info) {
                        return info;
                    }
                }
            }
            return undefined;
        }
        function wrapPrivateIdentifierForDestructuringTarget(node) {
            var parameter = factory.getGeneratedNameForNode(node);
            var info = accessPrivateIdentifier(node.name);
            if (!info) {
                return ts.visitEachChild(node, visitor, context);
            }
            var receiver = node.expression;
            if (ts.isThisProperty(node) || ts.isSuperProperty(node) || !ts.isSimpleCopiableExpression(node.expression)) {
                receiver = factory.createTempVariable(hoistVariableDeclaration, true);
                getPendingExpressions().push(factory.createBinaryExpression(receiver, 63, ts.visitNode(node.expression, visitor, ts.isExpression)));
            }
            return factory.createAssignmentTargetWrapper(parameter, createPrivateIdentifierAssignment(info, receiver, parameter, 63));
        }
        function visitArrayAssignmentTarget(node) {
            var target = ts.getTargetOfBindingOrAssignmentElement(node);
            if (target) {
                var wrapped = void 0;
                if (ts.isPrivateIdentifierPropertyAccessExpression(target)) {
                    wrapped = wrapPrivateIdentifierForDestructuringTarget(target);
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(target) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1) {
                        wrapped = visitInvalidSuperProperty(target);
                    }
                    else if (classConstructor && superClassReference) {
                        var name = ts.isElementAccessExpression(target) ? ts.visitNode(target.argumentExpression, visitor, ts.isExpression) :
                            ts.isIdentifier(target.name) ? factory.createStringLiteralFromNode(target.name) :
                                undefined;
                        if (name) {
                            var temp = factory.createTempVariable(undefined);
                            wrapped = factory.createAssignmentTargetWrapper(temp, factory.createReflectSetCall(superClassReference, name, temp, classConstructor));
                        }
                    }
                }
                if (wrapped) {
                    if (ts.isAssignmentExpression(node)) {
                        return factory.updateBinaryExpression(node, wrapped, node.operatorToken, ts.visitNode(node.right, visitor, ts.isExpression));
                    }
                    else if (ts.isSpreadElement(node)) {
                        return factory.updateSpreadElement(node, wrapped);
                    }
                    else {
                        return wrapped;
                    }
                }
            }
            return ts.visitNode(node, assignmentTargetVisitor);
        }
        function visitObjectAssignmentTarget(node) {
            if (ts.isObjectBindingOrAssignmentElement(node) && !ts.isShorthandPropertyAssignment(node)) {
                var target = ts.getTargetOfBindingOrAssignmentElement(node);
                var wrapped = void 0;
                if (target) {
                    if (ts.isPrivateIdentifierPropertyAccessExpression(target)) {
                        wrapped = wrapPrivateIdentifierForDestructuringTarget(target);
                    }
                    else if (shouldTransformSuperInStaticInitializers &&
                        ts.isSuperProperty(target) &&
                        currentStaticPropertyDeclarationOrStaticBlock &&
                        currentClassLexicalEnvironment) {
                        var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                        if (facts & 1) {
                            wrapped = visitInvalidSuperProperty(target);
                        }
                        else if (classConstructor && superClassReference) {
                            var name = ts.isElementAccessExpression(target) ? ts.visitNode(target.argumentExpression, visitor, ts.isExpression) :
                                ts.isIdentifier(target.name) ? factory.createStringLiteralFromNode(target.name) :
                                    undefined;
                            if (name) {
                                var temp = factory.createTempVariable(undefined);
                                wrapped = factory.createAssignmentTargetWrapper(temp, factory.createReflectSetCall(superClassReference, name, temp, classConstructor));
                            }
                        }
                    }
                }
                if (ts.isPropertyAssignment(node)) {
                    var initializer = ts.getInitializerOfBindingOrAssignmentElement(node);
                    return factory.updatePropertyAssignment(node, ts.visitNode(node.name, visitor, ts.isPropertyName), wrapped ?
                        initializer ? factory.createAssignment(wrapped, ts.visitNode(initializer, visitor)) : wrapped :
                        ts.visitNode(node.initializer, assignmentTargetVisitor, ts.isExpression));
                }
                if (ts.isSpreadAssignment(node)) {
                    return factory.updateSpreadAssignment(node, wrapped || ts.visitNode(node.expression, assignmentTargetVisitor, ts.isExpression));
                }
                ts.Debug.assert(wrapped === undefined, "Should not have generated a wrapped target");
            }
            return ts.visitNode(node, visitor);
        }
        function visitAssignmentPattern(node) {
            if (ts.isArrayLiteralExpression(node)) {
                return factory.updateArrayLiteralExpression(node, ts.visitNodes(node.elements, visitArrayAssignmentTarget, ts.isExpression));
            }
            else {
                return factory.updateObjectLiteralExpression(node, ts.visitNodes(node.properties, visitObjectAssignmentTarget, ts.isObjectLiteralElementLike));
            }
        }
    }
    ts.transformClassFields = transformClassFields;
    function createPrivateStaticFieldInitializer(variableName, initializer) {
        return ts.factory.createAssignment(variableName, ts.factory.createObjectLiteralExpression([
            ts.factory.createPropertyAssignment("value", initializer || ts.factory.createVoidZero())
        ]));
    }
    function createPrivateInstanceFieldInitializer(receiver, initializer, weakMapName) {
        return ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(weakMapName, "set"), undefined, [receiver, initializer || ts.factory.createVoidZero()]);
    }
    function createPrivateInstanceMethodInitializer(receiver, weakSetName) {
        return ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(weakSetName, "add"), undefined, [receiver]);
    }
    function isReservedPrivateName(node) {
        return !ts.isGeneratedPrivateIdentifier(node) && node.escapedText === "#constructor";
    }
    function getPrivateIdentifier(privateEnv, name) {
        return ts.isGeneratedPrivateIdentifier(name) ?
            getGeneratedPrivateIdentifierInfo(privateEnv, ts.getNodeForGeneratedName(name)) :
            getPrivateIdentifierInfo(privateEnv, name.escapedText);
    }
    function setPrivateIdentifier(privateEnv, name, info) {
        var _a, _b;
        if (ts.isGeneratedPrivateIdentifier(name)) {
            (_a = privateEnv.generatedIdentifiers) !== null && _a !== void 0 ? _a : (privateEnv.generatedIdentifiers = new ts.Map());
            privateEnv.generatedIdentifiers.set(ts.getNodeForGeneratedName(name), info);
        }
        else {
            (_b = privateEnv.identifiers) !== null && _b !== void 0 ? _b : (privateEnv.identifiers = new ts.Map());
            privateEnv.identifiers.set(name.escapedText, info);
        }
    }
    function getPrivateIdentifierInfo(privateEnv, key) {
        var _a;
        return (_a = privateEnv.identifiers) === null || _a === void 0 ? void 0 : _a.get(key);
    }
    function getGeneratedPrivateIdentifierInfo(privateEnv, key) {
        var _a;
        return (_a = privateEnv.generatedIdentifiers) === null || _a === void 0 ? void 0 : _a.get(key);
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createRuntimeTypeSerializer(context) {
        var hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var strictNullChecks = ts.getStrictOptionValue(compilerOptions, "strictNullChecks");
        var currentLexicalScope;
        var currentNameScope;
        return {
            serializeTypeNode: function (serializerContext, node) { return setSerializerContextAnd(serializerContext, serializeTypeNode, node); },
            serializeTypeOfNode: function (serializerContext, node) { return setSerializerContextAnd(serializerContext, serializeTypeOfNode, node); },
            serializeParameterTypesOfNode: function (serializerContext, node, container) { return setSerializerContextAnd(serializerContext, serializeParameterTypesOfNode, node, container); },
            serializeReturnTypeOfNode: function (serializerContext, node) { return setSerializerContextAnd(serializerContext, serializeReturnTypeOfNode, node); },
        };
        function setSerializerContextAnd(serializerContext, cb, node, arg) {
            var savedCurrentLexicalScope = currentLexicalScope;
            var savedCurrentNameScope = currentNameScope;
            currentLexicalScope = serializerContext.currentLexicalScope;
            currentNameScope = serializerContext.currentNameScope;
            var result = arg === undefined ? cb(node) : cb(node, arg);
            currentLexicalScope = savedCurrentLexicalScope;
            currentNameScope = savedCurrentNameScope;
            return result;
        }
        function getAccessorTypeNode(node) {
            var accessors = resolver.getAllAccessorDeclarations(node);
            return accessors.setAccessor && ts.getSetAccessorTypeAnnotationNode(accessors.setAccessor)
                || accessors.getAccessor && ts.getEffectiveReturnTypeNode(accessors.getAccessor);
        }
        function serializeTypeOfNode(node) {
            switch (node.kind) {
                case 169:
                case 166:
                    return serializeTypeNode(node.type);
                case 175:
                case 174:
                    return serializeTypeNode(getAccessorTypeNode(node));
                case 260:
                case 228:
                case 171:
                    return ts.factory.createIdentifier("Function");
                default:
                    return ts.factory.createVoidZero();
            }
        }
        function serializeParameterTypesOfNode(node, container) {
            var valueDeclaration = ts.isClassLike(node)
                ? ts.getFirstConstructorWithBody(node)
                : ts.isFunctionLike(node) && ts.nodeIsPresent(node.body)
                    ? node
                    : undefined;
            var expressions = [];
            if (valueDeclaration) {
                var parameters = getParametersOfDecoratedDeclaration(valueDeclaration, container);
                var numParameters = parameters.length;
                for (var i = 0; i < numParameters; i++) {
                    var parameter = parameters[i];
                    if (i === 0 && ts.isIdentifier(parameter.name) && parameter.name.escapedText === "this") {
                        continue;
                    }
                    if (parameter.dotDotDotToken) {
                        expressions.push(serializeTypeNode(ts.getRestParameterElementType(parameter.type)));
                    }
                    else {
                        expressions.push(serializeTypeOfNode(parameter));
                    }
                }
            }
            return ts.factory.createArrayLiteralExpression(expressions);
        }
        function getParametersOfDecoratedDeclaration(node, container) {
            if (container && node.kind === 174) {
                var setAccessor = ts.getAllAccessorDeclarations(container.members, node).setAccessor;
                if (setAccessor) {
                    return setAccessor.parameters;
                }
            }
            return node.parameters;
        }
        function serializeReturnTypeOfNode(node) {
            if (ts.isFunctionLike(node) && node.type) {
                return serializeTypeNode(node.type);
            }
            else if (ts.isAsyncFunction(node)) {
                return ts.factory.createIdentifier("Promise");
            }
            return ts.factory.createVoidZero();
        }
        function serializeTypeNode(node) {
            if (node === undefined) {
                return ts.factory.createIdentifier("Object");
            }
            node = ts.skipTypeParentheses(node);
            switch (node.kind) {
                case 114:
                case 155:
                case 144:
                    return ts.factory.createVoidZero();
                case 181:
                case 182:
                    return ts.factory.createIdentifier("Function");
                case 185:
                case 186:
                    return ts.factory.createIdentifier("Array");
                case 179:
                    return node.assertsModifier ?
                        ts.factory.createVoidZero() :
                        ts.factory.createIdentifier("Boolean");
                case 134:
                    return ts.factory.createIdentifier("Boolean");
                case 200:
                case 152:
                    return ts.factory.createIdentifier("String");
                case 149:
                    return ts.factory.createIdentifier("Object");
                case 198:
                    return serializeLiteralOfLiteralTypeNode(node.literal);
                case 148:
                    return ts.factory.createIdentifier("Number");
                case 160:
                    return getGlobalConstructor("BigInt", 7);
                case 153:
                    return getGlobalConstructor("Symbol", 2);
                case 180:
                    return serializeTypeReferenceNode(node);
                case 190:
                    return serializeUnionOrIntersectionConstituents(node.types, true);
                case 189:
                    return serializeUnionOrIntersectionConstituents(node.types, false);
                case 191:
                    return serializeUnionOrIntersectionConstituents([node.trueType, node.falseType], false);
                case 195:
                    if (node.operator === 146) {
                        return serializeTypeNode(node.type);
                    }
                    break;
                case 183:
                case 196:
                case 197:
                case 184:
                case 131:
                case 157:
                case 194:
                case 202:
                    break;
                case 315:
                case 316:
                case 320:
                case 321:
                case 322:
                    break;
                case 317:
                case 318:
                case 319:
                    return serializeTypeNode(node.type);
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
            return ts.factory.createIdentifier("Object");
        }
        function serializeLiteralOfLiteralTypeNode(node) {
            switch (node.kind) {
                case 10:
                case 14:
                    return ts.factory.createIdentifier("String");
                case 221: {
                    var operand = node.operand;
                    switch (operand.kind) {
                        case 8:
                        case 9:
                            return serializeLiteralOfLiteralTypeNode(operand);
                        default:
                            return ts.Debug.failBadSyntaxKind(operand);
                    }
                }
                case 8:
                    return ts.factory.createIdentifier("Number");
                case 9:
                    return getGlobalConstructor("BigInt", 7);
                case 110:
                case 95:
                    return ts.factory.createIdentifier("Boolean");
                case 104:
                    return ts.factory.createVoidZero();
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
        }
        function serializeUnionOrIntersectionConstituents(types, isIntersection) {
            var serializedType;
            for (var _i = 0, types_22 = types; _i < types_22.length; _i++) {
                var typeNode = types_22[_i];
                typeNode = ts.skipTypeParentheses(typeNode);
                if (typeNode.kind === 144) {
                    if (isIntersection)
                        return ts.factory.createVoidZero();
                    continue;
                }
                if (typeNode.kind === 157) {
                    if (!isIntersection)
                        return ts.factory.createIdentifier("Object");
                    continue;
                }
                if (typeNode.kind === 131) {
                    return ts.factory.createIdentifier("Object");
                }
                if (!strictNullChecks && ((ts.isLiteralTypeNode(typeNode) && typeNode.literal.kind === 104) || typeNode.kind === 155)) {
                    continue;
                }
                var serializedConstituent = serializeTypeNode(typeNode);
                if (ts.isIdentifier(serializedConstituent) && serializedConstituent.escapedText === "Object") {
                    return serializedConstituent;
                }
                if (serializedType) {
                    if (!equateSerializedTypeNodes(serializedType, serializedConstituent)) {
                        return ts.factory.createIdentifier("Object");
                    }
                }
                else {
                    serializedType = serializedConstituent;
                }
            }
            return serializedType !== null && serializedType !== void 0 ? serializedType : (ts.factory.createVoidZero());
        }
        function equateSerializedTypeNodes(left, right) {
            return (ts.isGeneratedIdentifier(left) ? ts.isGeneratedIdentifier(right) :
                ts.isIdentifier(left) ? ts.isIdentifier(right)
                    && left.escapedText === right.escapedText :
                    ts.isPropertyAccessExpression(left) ? ts.isPropertyAccessExpression(right)
                        && equateSerializedTypeNodes(left.expression, right.expression)
                        && equateSerializedTypeNodes(left.name, right.name) :
                        ts.isVoidExpression(left) ? ts.isVoidExpression(right)
                            && ts.isNumericLiteral(left.expression) && left.expression.text === "0"
                            && ts.isNumericLiteral(right.expression) && right.expression.text === "0" :
                            ts.isStringLiteral(left) ? ts.isStringLiteral(right)
                                && left.text === right.text :
                                ts.isTypeOfExpression(left) ? ts.isTypeOfExpression(right)
                                    && equateSerializedTypeNodes(left.expression, right.expression) :
                                    ts.isParenthesizedExpression(left) ? ts.isParenthesizedExpression(right)
                                        && equateSerializedTypeNodes(left.expression, right.expression) :
                                        ts.isConditionalExpression(left) ? ts.isConditionalExpression(right)
                                            && equateSerializedTypeNodes(left.condition, right.condition)
                                            && equateSerializedTypeNodes(left.whenTrue, right.whenTrue)
                                            && equateSerializedTypeNodes(left.whenFalse, right.whenFalse) :
                                            ts.isBinaryExpression(left) ? ts.isBinaryExpression(right)
                                                && left.operatorToken.kind === right.operatorToken.kind
                                                && equateSerializedTypeNodes(left.left, right.left)
                                                && equateSerializedTypeNodes(left.right, right.right) :
                                                false);
        }
        function serializeTypeReferenceNode(node) {
            var kind = resolver.getTypeReferenceSerializationKind(node.typeName, currentNameScope !== null && currentNameScope !== void 0 ? currentNameScope : currentLexicalScope);
            switch (kind) {
                case ts.TypeReferenceSerializationKind.Unknown:
                    if (ts.findAncestor(node, function (n) { return n.parent && ts.isConditionalTypeNode(n.parent) && (n.parent.trueType === n || n.parent.falseType === n); })) {
                        return ts.factory.createIdentifier("Object");
                    }
                    var serialized = serializeEntityNameAsExpressionFallback(node.typeName);
                    var temp = ts.factory.createTempVariable(hoistVariableDeclaration);
                    return ts.factory.createConditionalExpression(ts.factory.createTypeCheck(ts.factory.createAssignment(temp, serialized), "function"), undefined, temp, undefined, ts.factory.createIdentifier("Object"));
                case ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue:
                    return serializeEntityNameAsExpression(node.typeName);
                case ts.TypeReferenceSerializationKind.VoidNullableOrNeverType:
                    return ts.factory.createVoidZero();
                case ts.TypeReferenceSerializationKind.BigIntLikeType:
                    return getGlobalConstructor("BigInt", 7);
                case ts.TypeReferenceSerializationKind.BooleanType:
                    return ts.factory.createIdentifier("Boolean");
                case ts.TypeReferenceSerializationKind.NumberLikeType:
                    return ts.factory.createIdentifier("Number");
                case ts.TypeReferenceSerializationKind.StringLikeType:
                    return ts.factory.createIdentifier("String");
                case ts.TypeReferenceSerializationKind.ArrayLikeType:
                    return ts.factory.createIdentifier("Array");
                case ts.TypeReferenceSerializationKind.ESSymbolType:
                    return getGlobalConstructor("Symbol", 2);
                case ts.TypeReferenceSerializationKind.TypeWithCallSignature:
                    return ts.factory.createIdentifier("Function");
                case ts.TypeReferenceSerializationKind.Promise:
                    return ts.factory.createIdentifier("Promise");
                case ts.TypeReferenceSerializationKind.ObjectType:
                    return ts.factory.createIdentifier("Object");
                default:
                    return ts.Debug.assertNever(kind);
            }
        }
        function createCheckedValue(left, right) {
            return ts.factory.createLogicalAnd(ts.factory.createStrictInequality(ts.factory.createTypeOfExpression(left), ts.factory.createStringLiteral("undefined")), right);
        }
        function serializeEntityNameAsExpressionFallback(node) {
            if (node.kind === 79) {
                var copied = serializeEntityNameAsExpression(node);
                return createCheckedValue(copied, copied);
            }
            if (node.left.kind === 79) {
                return createCheckedValue(serializeEntityNameAsExpression(node.left), serializeEntityNameAsExpression(node));
            }
            var left = serializeEntityNameAsExpressionFallback(node.left);
            var temp = ts.factory.createTempVariable(hoistVariableDeclaration);
            return ts.factory.createLogicalAnd(ts.factory.createLogicalAnd(left.left, ts.factory.createStrictInequality(ts.factory.createAssignment(temp, left.right), ts.factory.createVoidZero())), ts.factory.createPropertyAccessExpression(temp, node.right));
        }
        function serializeEntityNameAsExpression(node) {
            switch (node.kind) {
                case 79:
                    var name = ts.setParent(ts.setTextRange(ts.parseNodeFactory.cloneNode(node), node), node.parent);
                    name.original = undefined;
                    ts.setParent(name, ts.getParseTreeNode(currentLexicalScope));
                    return name;
                case 163:
                    return serializeQualifiedNameAsExpression(node);
            }
        }
        function serializeQualifiedNameAsExpression(node) {
            return ts.factory.createPropertyAccessExpression(serializeEntityNameAsExpression(node.left), node.right);
        }
        function getGlobalConstructorWithFallback(name) {
            return ts.factory.createConditionalExpression(ts.factory.createTypeCheck(ts.factory.createIdentifier(name), "function"), undefined, ts.factory.createIdentifier(name), undefined, ts.factory.createIdentifier("Object"));
        }
        function getGlobalConstructor(name, minLanguageVersion) {
            return languageVersion < minLanguageVersion ?
                getGlobalConstructorWithFallback(name) :
                ts.factory.createIdentifier(name);
        }
    }
    ts.createRuntimeTypeSerializer = createRuntimeTypeSerializer;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformLegacyDecorators(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var classAliases;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function modifierVisitor(node) {
            return ts.isDecorator(node) ? undefined : node;
        }
        function visitor(node) {
            if (!(node.transformFlags & 33554432)) {
                return node;
            }
            switch (node.kind) {
                case 167:
                    return undefined;
                case 260:
                    return visitClassDeclaration(node);
                case 228:
                    return visitClassExpression(node);
                case 173:
                    return visitConstructorDeclaration(node);
                case 171:
                    return visitMethodDeclaration(node);
                case 175:
                    return visitSetAccessorDeclaration(node);
                case 174:
                    return visitGetAccessorDeclaration(node);
                case 169:
                    return visitPropertyDeclaration(node);
                case 166:
                    return visitParameterDeclaration(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitClassDeclaration(node) {
            if (!(ts.classOrConstructorParameterIsDecorated(node) || ts.childIsDecorated(node)))
                return ts.visitEachChild(node, visitor, context);
            var statements = ts.hasDecorators(node) ?
                transformClassDeclarationWithClassDecorators(node, node.name) :
                transformClassDeclarationWithoutClassDecorators(node, node.name);
            if (statements.length > 1) {
                statements.push(factory.createEndOfDeclarationMarker(node));
                ts.setEmitFlags(statements[0], ts.getEmitFlags(statements[0]) | 4194304);
            }
            return ts.singleOrMany(statements);
        }
        function decoratorContainsPrivateIdentifierInExpression(decorator) {
            return !!(decorator.transformFlags & 536870912);
        }
        function parameterDecoratorsContainPrivateIdentifierInExpression(parameterDecorators) {
            return ts.some(parameterDecorators, decoratorContainsPrivateIdentifierInExpression);
        }
        function hasClassElementWithDecoratorContainingPrivateIdentifierInExpression(node) {
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (!ts.canHaveDecorators(member))
                    continue;
                var allDecorators = ts.getAllDecoratorsOfClassElement(member, node);
                if (ts.some(allDecorators === null || allDecorators === void 0 ? void 0 : allDecorators.decorators, decoratorContainsPrivateIdentifierInExpression))
                    return true;
                if (ts.some(allDecorators === null || allDecorators === void 0 ? void 0 : allDecorators.parameters, parameterDecoratorsContainPrivateIdentifierInExpression))
                    return true;
            }
            return false;
        }
        function transformDecoratorsOfClassElements(node, members) {
            var decorationStatements = [];
            addClassElementDecorationStatements(decorationStatements, node, false);
            addClassElementDecorationStatements(decorationStatements, node, true);
            if (hasClassElementWithDecoratorContainingPrivateIdentifierInExpression(node)) {
                members = ts.setTextRange(factory.createNodeArray(__spreadArray(__spreadArray([], members, true), [
                    factory.createClassStaticBlockDeclaration(factory.createBlock(decorationStatements, true))
                ], false)), members);
                decorationStatements = undefined;
            }
            return { decorationStatements: decorationStatements, members: members };
        }
        function transformClassDeclarationWithoutClassDecorators(node, name) {
            var _a;
            var modifiers = ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier);
            var heritageClauses = ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause);
            var members = ts.visitNodes(node.members, visitor, ts.isClassElement);
            var decorationStatements = [];
            (_a = transformDecoratorsOfClassElements(node, members), members = _a.members, decorationStatements = _a.decorationStatements);
            var updated = factory.updateClassDeclaration(node, modifiers, name, undefined, heritageClauses, members);
            return ts.addRange([updated], decorationStatements);
        }
        function transformClassDeclarationWithClassDecorators(node, name) {
            var _a;
            var location = ts.moveRangePastModifiers(node);
            var classAlias = getClassAliasIfNeeded(node);
            var declName = languageVersion <= 2 ?
                factory.getInternalName(node, false, true) :
                factory.getLocalName(node, false, true);
            var heritageClauses = ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause);
            var members = ts.visitNodes(node.members, visitor, ts.isClassElement);
            var decorationStatements = [];
            (_a = transformDecoratorsOfClassElements(node, members), members = _a.members, decorationStatements = _a.decorationStatements);
            var classExpression = factory.createClassExpression(undefined, name, undefined, heritageClauses, members);
            ts.setOriginalNode(classExpression, node);
            ts.setTextRange(classExpression, location);
            var statement = factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration(declName, undefined, undefined, classAlias ? factory.createAssignment(classAlias, classExpression) : classExpression)
            ], 1));
            ts.setOriginalNode(statement, node);
            ts.setTextRange(statement, location);
            ts.setCommentRange(statement, node);
            var statements = [statement];
            ts.addRange(statements, decorationStatements);
            addConstructorDecorationStatement(statements, node);
            return statements;
        }
        function visitClassExpression(node) {
            return factory.updateClassExpression(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.name, undefined, ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause), ts.visitNodes(node.members, visitor, ts.isClassElement));
        }
        function visitConstructorDeclaration(node) {
            return factory.updateConstructorDeclaration(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), ts.visitNodes(node.parameters, visitor, ts.isParameterDeclaration), ts.visitNode(node.body, visitor, ts.isBlock));
        }
        function finishClassElement(updated, original) {
            if (updated !== original) {
                ts.setCommentRange(updated, original);
                ts.setSourceMapRange(updated, ts.moveRangePastModifiers(original));
            }
            return updated;
        }
        function visitMethodDeclaration(node) {
            return finishClassElement(factory.updateMethodDeclaration(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, ts.visitNode(node.name, visitor, ts.isPropertyName), undefined, undefined, ts.visitNodes(node.parameters, visitor, ts.isParameterDeclaration), undefined, ts.visitNode(node.body, visitor, ts.isBlock)), node);
        }
        function visitGetAccessorDeclaration(node) {
            return finishClassElement(factory.updateGetAccessorDeclaration(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitNodes(node.parameters, visitor, ts.isParameterDeclaration), undefined, ts.visitNode(node.body, visitor, ts.isBlock)), node);
        }
        function visitSetAccessorDeclaration(node) {
            return finishClassElement(factory.updateSetAccessorDeclaration(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitNodes(node.parameters, visitor, ts.isParameterDeclaration), ts.visitNode(node.body, visitor, ts.isBlock)), node);
        }
        function visitPropertyDeclaration(node) {
            if (node.flags & 16777216 || ts.hasSyntacticModifier(node, 2)) {
                return undefined;
            }
            return finishClassElement(factory.updatePropertyDeclaration(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), ts.visitNode(node.name, visitor, ts.isPropertyName), undefined, undefined, ts.visitNode(node.initializer, visitor, ts.isExpression)), node);
        }
        function visitParameterDeclaration(node) {
            var updated = factory.updateParameterDeclaration(node, ts.elideNodes(factory, node.modifiers), node.dotDotDotToken, ts.visitNode(node.name, visitor, ts.isBindingName), undefined, undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            if (updated !== node) {
                ts.setCommentRange(updated, node);
                ts.setTextRange(updated, ts.moveRangePastModifiers(node));
                ts.setSourceMapRange(updated, ts.moveRangePastModifiers(node));
                ts.setEmitFlags(updated.name, 32);
            }
            return updated;
        }
        function transformAllDecoratorsOfDeclaration(allDecorators) {
            if (!allDecorators) {
                return undefined;
            }
            var decoratorExpressions = [];
            ts.addRange(decoratorExpressions, ts.map(allDecorators.decorators, transformDecorator));
            ts.addRange(decoratorExpressions, ts.flatMap(allDecorators.parameters, transformDecoratorsOfParameter));
            return decoratorExpressions;
        }
        function addClassElementDecorationStatements(statements, node, isStatic) {
            ts.addRange(statements, ts.map(generateClassElementDecorationExpressions(node, isStatic), function (expr) { return factory.createExpressionStatement(expr); }));
        }
        function isDecoratedClassElement(member, isStaticElement, parent) {
            return ts.nodeOrChildIsDecorated(member, parent)
                && isStaticElement === ts.isStatic(member);
        }
        function getDecoratedClassElements(node, isStatic) {
            return ts.filter(node.members, function (m) { return isDecoratedClassElement(m, isStatic, node); });
        }
        function generateClassElementDecorationExpressions(node, isStatic) {
            var members = getDecoratedClassElements(node, isStatic);
            var expressions;
            for (var _i = 0, members_8 = members; _i < members_8.length; _i++) {
                var member = members_8[_i];
                expressions = ts.append(expressions, generateClassElementDecorationExpression(node, member));
            }
            return expressions;
        }
        function generateClassElementDecorationExpression(node, member) {
            var allDecorators = ts.getAllDecoratorsOfClassElement(member, node);
            var decoratorExpressions = transformAllDecoratorsOfDeclaration(allDecorators);
            if (!decoratorExpressions) {
                return undefined;
            }
            var prefix = getClassMemberPrefix(node, member);
            var memberName = getExpressionForPropertyName(member, !ts.hasSyntacticModifier(member, 2));
            var descriptor = languageVersion > 0
                ? ts.isPropertyDeclaration(member) && !ts.hasAccessorModifier(member)
                    ? factory.createVoidZero()
                    : factory.createNull()
                : undefined;
            var helper = emitHelpers().createDecorateHelper(decoratorExpressions, prefix, memberName, descriptor);
            ts.setEmitFlags(helper, 1536);
            ts.setSourceMapRange(helper, ts.moveRangePastModifiers(member));
            return helper;
        }
        function addConstructorDecorationStatement(statements, node) {
            var expression = generateConstructorDecorationExpression(node);
            if (expression) {
                statements.push(ts.setOriginalNode(factory.createExpressionStatement(expression), node));
            }
        }
        function generateConstructorDecorationExpression(node) {
            var allDecorators = ts.getAllDecoratorsOfClass(node);
            var decoratorExpressions = transformAllDecoratorsOfDeclaration(allDecorators);
            if (!decoratorExpressions) {
                return undefined;
            }
            var classAlias = classAliases && classAliases[ts.getOriginalNodeId(node)];
            var localName = languageVersion <= 2 ?
                factory.getInternalName(node, false, true) :
                factory.getLocalName(node, false, true);
            var decorate = emitHelpers().createDecorateHelper(decoratorExpressions, localName);
            var expression = factory.createAssignment(localName, classAlias ? factory.createAssignment(classAlias, decorate) : decorate);
            ts.setEmitFlags(expression, 1536);
            ts.setSourceMapRange(expression, ts.moveRangePastModifiers(node));
            return expression;
        }
        function transformDecorator(decorator) {
            return ts.visitNode(decorator.expression, visitor, ts.isExpression);
        }
        function transformDecoratorsOfParameter(decorators, parameterOffset) {
            var expressions;
            if (decorators) {
                expressions = [];
                for (var _i = 0, decorators_1 = decorators; _i < decorators_1.length; _i++) {
                    var decorator = decorators_1[_i];
                    var helper = emitHelpers().createParamHelper(transformDecorator(decorator), parameterOffset);
                    ts.setTextRange(helper, decorator.expression);
                    ts.setEmitFlags(helper, 1536);
                    expressions.push(helper);
                }
            }
            return expressions;
        }
        function getExpressionForPropertyName(member, generateNameForComputedPropertyName) {
            var name = member.name;
            if (ts.isPrivateIdentifier(name)) {
                return factory.createIdentifier("");
            }
            else if (ts.isComputedPropertyName(name)) {
                return generateNameForComputedPropertyName && !ts.isSimpleInlineableExpression(name.expression)
                    ? factory.getGeneratedNameForNode(name)
                    : name.expression;
            }
            else if (ts.isIdentifier(name)) {
                return factory.createStringLiteral(ts.idText(name));
            }
            else {
                return factory.cloneNode(name);
            }
        }
        function enableSubstitutionForClassAliases() {
            if (!classAliases) {
                context.enableSubstitution(79);
                classAliases = [];
            }
        }
        function getClassAliasIfNeeded(node) {
            if (resolver.getNodeCheckFlags(node) & 16777216) {
                enableSubstitutionForClassAliases();
                var classAlias = factory.createUniqueName(node.name && !ts.isGeneratedIdentifier(node.name) ? ts.idText(node.name) : "default");
                classAliases[ts.getOriginalNodeId(node)] = classAlias;
                hoistVariableDeclaration(classAlias);
                return classAlias;
            }
        }
        function getClassPrototype(node) {
            return factory.createPropertyAccessExpression(factory.getDeclarationName(node), "prototype");
        }
        function getClassMemberPrefix(node, member) {
            return ts.isStatic(member)
                ? factory.getDeclarationName(node)
                : getClassPrototype(node);
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79:
                    return substituteExpressionIdentifier(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            var _a;
            return (_a = trySubstituteClassAlias(node)) !== null && _a !== void 0 ? _a : node;
        }
        function trySubstituteClassAlias(node) {
            if (classAliases) {
                if (resolver.getNodeCheckFlags(node) & 33554432) {
                    var declaration = resolver.getReferencedValueDeclaration(node);
                    if (declaration) {
                        var classAlias = classAliases[declaration.id];
                        if (classAlias) {
                            var clone_3 = factory.cloneNode(classAlias);
                            ts.setSourceMapRange(clone_3, node);
                            ts.setCommentRange(clone_3, node);
                            return clone_3;
                        }
                    }
                }
            }
            return undefined;
        }
    }
    ts.transformLegacyDecorators = transformLegacyDecorators;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformES2017(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var enabledSubstitutions;
        var enclosingSuperContainerFlags = 0;
        var enclosingFunctionParameterNames;
        var capturedSuperProperties;
        var hasSuperElementAccess;
        var substitutedSuperAccessors = [];
        var contextFlags = 0;
        var previousOnEmitNode = context.onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            setContextFlag(1, false);
            setContextFlag(2, !ts.isEffectiveStrictModeSourceFile(node, compilerOptions));
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function setContextFlag(flag, val) {
            contextFlags = val ? contextFlags | flag : contextFlags & ~flag;
        }
        function inContext(flags) {
            return (contextFlags & flags) !== 0;
        }
        function inTopLevelContext() {
            return !inContext(1);
        }
        function inHasLexicalThisContext() {
            return inContext(2);
        }
        function doWithContext(flags, cb, value) {
            var contextFlagsToSet = flags & ~contextFlags;
            if (contextFlagsToSet) {
                setContextFlag(contextFlagsToSet, true);
                var result = cb(value);
                setContextFlag(contextFlagsToSet, false);
                return result;
            }
            return cb(value);
        }
        function visitDefault(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 256) === 0) {
                return node;
            }
            switch (node.kind) {
                case 132:
                    return undefined;
                case 220:
                    return visitAwaitExpression(node);
                case 171:
                    return doWithContext(1 | 2, visitMethodDeclaration, node);
                case 259:
                    return doWithContext(1 | 2, visitFunctionDeclaration, node);
                case 215:
                    return doWithContext(1 | 2, visitFunctionExpression, node);
                case 216:
                    return doWithContext(1, visitArrowFunction, node);
                case 208:
                    if (capturedSuperProperties && ts.isPropertyAccessExpression(node) && node.expression.kind === 106) {
                        capturedSuperProperties.add(node.name.escapedText);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 209:
                    if (capturedSuperProperties && node.expression.kind === 106) {
                        hasSuperElementAccess = true;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 174:
                    return doWithContext(1 | 2, visitGetAccessorDeclaration, node);
                case 175:
                    return doWithContext(1 | 2, visitSetAccessorDeclaration, node);
                case 173:
                    return doWithContext(1 | 2, visitConstructorDeclaration, node);
                case 260:
                case 228:
                    return doWithContext(1 | 2, visitDefault, node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function asyncBodyVisitor(node) {
            if (ts.isNodeWithPossibleHoistedDeclaration(node)) {
                switch (node.kind) {
                    case 240:
                        return visitVariableStatementInAsyncBody(node);
                    case 245:
                        return visitForStatementInAsyncBody(node);
                    case 246:
                        return visitForInStatementInAsyncBody(node);
                    case 247:
                        return visitForOfStatementInAsyncBody(node);
                    case 295:
                        return visitCatchClauseInAsyncBody(node);
                    case 238:
                    case 252:
                    case 266:
                    case 292:
                    case 293:
                    case 255:
                    case 243:
                    case 244:
                    case 242:
                    case 251:
                    case 253:
                        return ts.visitEachChild(node, asyncBodyVisitor, context);
                    default:
                        return ts.Debug.assertNever(node, "Unhandled node.");
                }
            }
            return visitor(node);
        }
        function visitCatchClauseInAsyncBody(node) {
            var catchClauseNames = new ts.Set();
            recordDeclarationName(node.variableDeclaration, catchClauseNames);
            var catchClauseUnshadowedNames;
            catchClauseNames.forEach(function (_, escapedName) {
                if (enclosingFunctionParameterNames.has(escapedName)) {
                    if (!catchClauseUnshadowedNames) {
                        catchClauseUnshadowedNames = new ts.Set(enclosingFunctionParameterNames);
                    }
                    catchClauseUnshadowedNames.delete(escapedName);
                }
            });
            if (catchClauseUnshadowedNames) {
                var savedEnclosingFunctionParameterNames = enclosingFunctionParameterNames;
                enclosingFunctionParameterNames = catchClauseUnshadowedNames;
                var result = ts.visitEachChild(node, asyncBodyVisitor, context);
                enclosingFunctionParameterNames = savedEnclosingFunctionParameterNames;
                return result;
            }
            else {
                return ts.visitEachChild(node, asyncBodyVisitor, context);
            }
        }
        function visitVariableStatementInAsyncBody(node) {
            if (isVariableDeclarationListWithCollidingName(node.declarationList)) {
                var expression = visitVariableDeclarationListWithCollidingNames(node.declarationList, false);
                return expression ? factory.createExpressionStatement(expression) : undefined;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForInStatementInAsyncBody(node) {
            return factory.updateForInStatement(node, isVariableDeclarationListWithCollidingName(node.initializer)
                ? visitVariableDeclarationListWithCollidingNames(node.initializer, true)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        function visitForOfStatementInAsyncBody(node) {
            return factory.updateForOfStatement(node, ts.visitNode(node.awaitModifier, visitor, ts.isToken), isVariableDeclarationListWithCollidingName(node.initializer)
                ? visitVariableDeclarationListWithCollidingNames(node.initializer, true)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        function visitForStatementInAsyncBody(node) {
            var initializer = node.initializer;
            return factory.updateForStatement(node, isVariableDeclarationListWithCollidingName(initializer)
                ? visitVariableDeclarationListWithCollidingNames(initializer, false)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        function visitAwaitExpression(node) {
            if (inTopLevelContext()) {
                return ts.visitEachChild(node, visitor, context);
            }
            return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(undefined, ts.visitNode(node.expression, visitor, ts.isExpression)), node), node);
        }
        function visitConstructorDeclaration(node) {
            return factory.updateConstructorDeclaration(node, ts.visitNodes(node.modifiers, visitor, ts.isModifierLike), ts.visitParameterList(node.parameters, visitor, context), transformMethodBody(node));
        }
        function visitMethodDeclaration(node) {
            return factory.updateMethodDeclaration(node, ts.visitNodes(node.modifiers, visitor, ts.isModifierLike), node.asteriskToken, node.name, undefined, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.getFunctionFlags(node) & 2
                ? transformAsyncFunctionBody(node)
                : transformMethodBody(node));
        }
        function visitGetAccessorDeclaration(node) {
            return factory.updateGetAccessorDeclaration(node, ts.visitNodes(node.modifiers, visitor, ts.isModifierLike), node.name, ts.visitParameterList(node.parameters, visitor, context), undefined, transformMethodBody(node));
        }
        function visitSetAccessorDeclaration(node) {
            return factory.updateSetAccessorDeclaration(node, ts.visitNodes(node.modifiers, visitor, ts.isModifierLike), node.name, ts.visitParameterList(node.parameters, visitor, context), transformMethodBody(node));
        }
        function visitFunctionDeclaration(node) {
            return factory.updateFunctionDeclaration(node, ts.visitNodes(node.modifiers, visitor, ts.isModifierLike), node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.getFunctionFlags(node) & 2
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        function visitFunctionExpression(node) {
            return factory.updateFunctionExpression(node, ts.visitNodes(node.modifiers, visitor, ts.isModifierLike), node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.getFunctionFlags(node) & 2
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        function visitArrowFunction(node) {
            return factory.updateArrowFunction(node, ts.visitNodes(node.modifiers, visitor, ts.isModifierLike), undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, node.equalsGreaterThanToken, ts.getFunctionFlags(node) & 2
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        function recordDeclarationName(_a, names) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                names.add(name.escapedText);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element)) {
                        recordDeclarationName(element, names);
                    }
                }
            }
        }
        function isVariableDeclarationListWithCollidingName(node) {
            return !!node
                && ts.isVariableDeclarationList(node)
                && !(node.flags & 3)
                && node.declarations.some(collidesWithParameterName);
        }
        function visitVariableDeclarationListWithCollidingNames(node, hasReceiver) {
            hoistVariableDeclarationList(node);
            var variables = ts.getInitializedVariables(node);
            if (variables.length === 0) {
                if (hasReceiver) {
                    return ts.visitNode(factory.converters.convertToAssignmentElementTarget(node.declarations[0].name), visitor, ts.isExpression);
                }
                return undefined;
            }
            return factory.inlineExpressions(ts.map(variables, transformInitializedVariable));
        }
        function hoistVariableDeclarationList(node) {
            ts.forEach(node.declarations, hoistVariable);
        }
        function hoistVariable(_a) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                hoistVariableDeclaration(name);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element)) {
                        hoistVariable(element);
                    }
                }
            }
        }
        function transformInitializedVariable(node) {
            var converted = ts.setSourceMapRange(factory.createAssignment(factory.converters.convertToAssignmentElementTarget(node.name), node.initializer), node);
            return ts.visitNode(converted, visitor, ts.isExpression);
        }
        function collidesWithParameterName(_a) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                return enclosingFunctionParameterNames.has(name.escapedText);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element) && collidesWithParameterName(element)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function transformMethodBody(node) {
            ts.Debug.assertIsDefined(node.body);
            var savedCapturedSuperProperties = capturedSuperProperties;
            var savedHasSuperElementAccess = hasSuperElementAccess;
            capturedSuperProperties = new ts.Set();
            hasSuperElementAccess = false;
            var updated = ts.visitFunctionBody(node.body, visitor, context);
            var originalMethod = ts.getOriginalNode(node, ts.isFunctionLikeDeclaration);
            var emitSuperHelpers = languageVersion >= 2 &&
                resolver.getNodeCheckFlags(node) & (4096 | 2048) &&
                (ts.getFunctionFlags(originalMethod) & 3) !== 3;
            if (emitSuperHelpers) {
                enableSubstitutionForAsyncMethodsWithSuper();
                if (capturedSuperProperties.size) {
                    var variableStatement = createSuperAccessVariableStatement(factory, resolver, node, capturedSuperProperties);
                    substitutedSuperAccessors[ts.getNodeId(variableStatement)] = true;
                    var statements = updated.statements.slice();
                    ts.insertStatementsAfterStandardPrologue(statements, [variableStatement]);
                    updated = factory.updateBlock(updated, statements);
                }
                if (hasSuperElementAccess) {
                    if (resolver.getNodeCheckFlags(node) & 4096) {
                        ts.addEmitHelper(updated, ts.advancedAsyncSuperHelper);
                    }
                    else if (resolver.getNodeCheckFlags(node) & 2048) {
                        ts.addEmitHelper(updated, ts.asyncSuperHelper);
                    }
                }
            }
            capturedSuperProperties = savedCapturedSuperProperties;
            hasSuperElementAccess = savedHasSuperElementAccess;
            return updated;
        }
        function transformAsyncFunctionBody(node) {
            resumeLexicalEnvironment();
            var original = ts.getOriginalNode(node, ts.isFunctionLike);
            var nodeType = original.type;
            var promiseConstructor = languageVersion < 2 ? getPromiseConstructor(nodeType) : undefined;
            var isArrowFunction = node.kind === 216;
            var hasLexicalArguments = (resolver.getNodeCheckFlags(node) & 8192) !== 0;
            var savedEnclosingFunctionParameterNames = enclosingFunctionParameterNames;
            enclosingFunctionParameterNames = new ts.Set();
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                recordDeclarationName(parameter, enclosingFunctionParameterNames);
            }
            var savedCapturedSuperProperties = capturedSuperProperties;
            var savedHasSuperElementAccess = hasSuperElementAccess;
            if (!isArrowFunction) {
                capturedSuperProperties = new ts.Set();
                hasSuperElementAccess = false;
            }
            var result;
            if (!isArrowFunction) {
                var statements = [];
                var statementOffset = factory.copyPrologue(node.body.statements, statements, false, visitor);
                statements.push(factory.createReturnStatement(emitHelpers().createAwaiterHelper(inHasLexicalThisContext(), hasLexicalArguments, promiseConstructor, transformAsyncFunctionBodyWorker(node.body, statementOffset))));
                ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
                var emitSuperHelpers = languageVersion >= 2 && resolver.getNodeCheckFlags(node) & (4096 | 2048);
                if (emitSuperHelpers) {
                    enableSubstitutionForAsyncMethodsWithSuper();
                    if (capturedSuperProperties.size) {
                        var variableStatement = createSuperAccessVariableStatement(factory, resolver, node, capturedSuperProperties);
                        substitutedSuperAccessors[ts.getNodeId(variableStatement)] = true;
                        ts.insertStatementsAfterStandardPrologue(statements, [variableStatement]);
                    }
                }
                var block = factory.createBlock(statements, true);
                ts.setTextRange(block, node.body);
                if (emitSuperHelpers && hasSuperElementAccess) {
                    if (resolver.getNodeCheckFlags(node) & 4096) {
                        ts.addEmitHelper(block, ts.advancedAsyncSuperHelper);
                    }
                    else if (resolver.getNodeCheckFlags(node) & 2048) {
                        ts.addEmitHelper(block, ts.asyncSuperHelper);
                    }
                }
                result = block;
            }
            else {
                var expression = emitHelpers().createAwaiterHelper(inHasLexicalThisContext(), hasLexicalArguments, promiseConstructor, transformAsyncFunctionBodyWorker(node.body));
                var declarations = endLexicalEnvironment();
                if (ts.some(declarations)) {
                    var block = factory.converters.convertToFunctionBlock(expression);
                    result = factory.updateBlock(block, ts.setTextRange(factory.createNodeArray(ts.concatenate(declarations, block.statements)), block.statements));
                }
                else {
                    result = expression;
                }
            }
            enclosingFunctionParameterNames = savedEnclosingFunctionParameterNames;
            if (!isArrowFunction) {
                capturedSuperProperties = savedCapturedSuperProperties;
                hasSuperElementAccess = savedHasSuperElementAccess;
            }
            return result;
        }
        function transformAsyncFunctionBodyWorker(body, start) {
            if (ts.isBlock(body)) {
                return factory.updateBlock(body, ts.visitNodes(body.statements, asyncBodyVisitor, ts.isStatement, start));
            }
            else {
                return factory.converters.convertToFunctionBlock(ts.visitNode(body, asyncBodyVisitor, ts.isConciseBody));
            }
        }
        function getPromiseConstructor(type) {
            var typeName = type && ts.getEntityNameFromTypeNode(type);
            if (typeName && ts.isEntityName(typeName)) {
                var serializationKind = resolver.getTypeReferenceSerializationKind(typeName);
                if (serializationKind === ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue
                    || serializationKind === ts.TypeReferenceSerializationKind.Unknown) {
                    return typeName;
                }
            }
            return undefined;
        }
        function enableSubstitutionForAsyncMethodsWithSuper() {
            if ((enabledSubstitutions & 1) === 0) {
                enabledSubstitutions |= 1;
                context.enableSubstitution(210);
                context.enableSubstitution(208);
                context.enableSubstitution(209);
                context.enableEmitNotification(260);
                context.enableEmitNotification(171);
                context.enableEmitNotification(174);
                context.enableEmitNotification(175);
                context.enableEmitNotification(173);
                context.enableEmitNotification(240);
            }
        }
        function onEmitNode(hint, node, emitCallback) {
            if (enabledSubstitutions & 1 && isSuperContainer(node)) {
                var superContainerFlags = resolver.getNodeCheckFlags(node) & (2048 | 4096);
                if (superContainerFlags !== enclosingSuperContainerFlags) {
                    var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                    enclosingSuperContainerFlags = superContainerFlags;
                    previousOnEmitNode(hint, node, emitCallback);
                    enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                    return;
                }
            }
            else if (enabledSubstitutions && substitutedSuperAccessors[ts.getNodeId(node)]) {
                var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                enclosingSuperContainerFlags = 0;
                previousOnEmitNode(hint, node, emitCallback);
                enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                return;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 && enclosingSuperContainerFlags) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 208:
                    return substitutePropertyAccessExpression(node);
                case 209:
                    return substituteElementAccessExpression(node);
                case 210:
                    return substituteCallExpression(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (node.expression.kind === 106) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createUniqueName("_super", 16 | 32), node.name), node);
            }
            return node;
        }
        function substituteElementAccessExpression(node) {
            if (node.expression.kind === 106) {
                return createSuperElementAccessInAsyncMethod(node.argumentExpression, node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            var expression = node.expression;
            if (ts.isSuperProperty(expression)) {
                var argumentExpression = ts.isPropertyAccessExpression(expression)
                    ? substitutePropertyAccessExpression(expression)
                    : substituteElementAccessExpression(expression);
                return factory.createCallExpression(factory.createPropertyAccessExpression(argumentExpression, "call"), undefined, __spreadArray([
                    factory.createThis()
                ], node.arguments, true));
            }
            return node;
        }
        function isSuperContainer(node) {
            var kind = node.kind;
            return kind === 260
                || kind === 173
                || kind === 171
                || kind === 174
                || kind === 175;
        }
        function createSuperElementAccessInAsyncMethod(argumentExpression, location) {
            if (enclosingSuperContainerFlags & 4096) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createCallExpression(factory.createUniqueName("_superIndex", 16 | 32), undefined, [argumentExpression]), "value"), location);
            }
            else {
                return ts.setTextRange(factory.createCallExpression(factory.createUniqueName("_superIndex", 16 | 32), undefined, [argumentExpression]), location);
            }
        }
    }
    ts.transformES2017 = transformES2017;
    function createSuperAccessVariableStatement(factory, resolver, node, names) {
        var hasBinding = (resolver.getNodeCheckFlags(node) & 4096) !== 0;
        var accessors = [];
        names.forEach(function (_, key) {
            var name = ts.unescapeLeadingUnderscores(key);
            var getterAndSetter = [];
            getterAndSetter.push(factory.createPropertyAssignment("get", factory.createArrowFunction(undefined, undefined, [], undefined, undefined, ts.setEmitFlags(factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createSuper(), 4), name), 4))));
            if (hasBinding) {
                getterAndSetter.push(factory.createPropertyAssignment("set", factory.createArrowFunction(undefined, undefined, [
                    factory.createParameterDeclaration(undefined, undefined, "v", undefined, undefined, undefined)
                ], undefined, undefined, factory.createAssignment(ts.setEmitFlags(factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createSuper(), 4), name), 4), factory.createIdentifier("v")))));
            }
            accessors.push(factory.createPropertyAssignment(name, factory.createObjectLiteralExpression(getterAndSetter)));
        });
        return factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
            factory.createVariableDeclaration(factory.createUniqueName("_super", 16 | 32), undefined, undefined, factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "create"), undefined, [
                factory.createNull(),
                factory.createObjectLiteralExpression(accessors, true)
            ]))
        ], 2));
    }
    ts.createSuperAccessVariableStatement = createSuperAccessVariableStatement;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformES2018(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var exportedVariableStatement = false;
        var enabledSubstitutions;
        var enclosingFunctionFlags;
        var parametersWithPrecedingObjectRestOrSpread;
        var enclosingSuperContainerFlags = 0;
        var hierarchyFacts = 0;
        var currentSourceFile;
        var taggedTemplateStringDeclarations;
        var capturedSuperProperties;
        var hasSuperElementAccess;
        var substitutedSuperAccessors = [];
        return ts.chainBundle(context, transformSourceFile);
        function affectsSubtree(excludeFacts, includeFacts) {
            return hierarchyFacts !== (hierarchyFacts & ~excludeFacts | includeFacts);
        }
        function enterSubtree(excludeFacts, includeFacts) {
            var ancestorFacts = hierarchyFacts;
            hierarchyFacts = (hierarchyFacts & ~excludeFacts | includeFacts) & 3;
            return ancestorFacts;
        }
        function exitSubtree(ancestorFacts) {
            hierarchyFacts = ancestorFacts;
        }
        function recordTaggedTemplateString(temp) {
            taggedTemplateStringDeclarations = ts.append(taggedTemplateStringDeclarations, factory.createVariableDeclaration(temp));
        }
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            var visited = visitSourceFile(node);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            taggedTemplateStringDeclarations = undefined;
            return visited;
        }
        function visitor(node) {
            return visitorWorker(node, false);
        }
        function visitorWithUnusedExpressionResult(node) {
            return visitorWorker(node, true);
        }
        function visitorNoAsyncModifier(node) {
            if (node.kind === 132) {
                return undefined;
            }
            return node;
        }
        function doWithHierarchyFacts(cb, value, excludeFacts, includeFacts) {
            if (affectsSubtree(excludeFacts, includeFacts)) {
                var ancestorFacts = enterSubtree(excludeFacts, includeFacts);
                var result = cb(value);
                exitSubtree(ancestorFacts);
                return result;
            }
            return cb(value);
        }
        function visitDefault(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        function visitorWorker(node, expressionResultIsUnused) {
            if ((node.transformFlags & 128) === 0) {
                return node;
            }
            switch (node.kind) {
                case 220:
                    return visitAwaitExpression(node);
                case 226:
                    return visitYieldExpression(node);
                case 250:
                    return visitReturnStatement(node);
                case 253:
                    return visitLabeledStatement(node);
                case 207:
                    return visitObjectLiteralExpression(node);
                case 223:
                    return visitBinaryExpression(node, expressionResultIsUnused);
                case 354:
                    return visitCommaListExpression(node, expressionResultIsUnused);
                case 295:
                    return visitCatchClause(node);
                case 240:
                    return visitVariableStatement(node);
                case 257:
                    return visitVariableDeclaration(node);
                case 243:
                case 244:
                case 246:
                    return doWithHierarchyFacts(visitDefault, node, 0, 2);
                case 247:
                    return visitForOfStatement(node, undefined);
                case 245:
                    return doWithHierarchyFacts(visitForStatement, node, 0, 2);
                case 219:
                    return visitVoidExpression(node);
                case 173:
                    return doWithHierarchyFacts(visitConstructorDeclaration, node, 2, 1);
                case 171:
                    return doWithHierarchyFacts(visitMethodDeclaration, node, 2, 1);
                case 174:
                    return doWithHierarchyFacts(visitGetAccessorDeclaration, node, 2, 1);
                case 175:
                    return doWithHierarchyFacts(visitSetAccessorDeclaration, node, 2, 1);
                case 259:
                    return doWithHierarchyFacts(visitFunctionDeclaration, node, 2, 1);
                case 215:
                    return doWithHierarchyFacts(visitFunctionExpression, node, 2, 1);
                case 216:
                    return doWithHierarchyFacts(visitArrowFunction, node, 2, 0);
                case 166:
                    return visitParameter(node);
                case 241:
                    return visitExpressionStatement(node);
                case 214:
                    return visitParenthesizedExpression(node, expressionResultIsUnused);
                case 212:
                    return visitTaggedTemplateExpression(node);
                case 208:
                    if (capturedSuperProperties && ts.isPropertyAccessExpression(node) && node.expression.kind === 106) {
                        capturedSuperProperties.add(node.name.escapedText);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 209:
                    if (capturedSuperProperties && node.expression.kind === 106) {
                        hasSuperElementAccess = true;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 260:
                case 228:
                    return doWithHierarchyFacts(visitDefault, node, 2, 1);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitAwaitExpression(node) {
            if (enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1) {
                return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(undefined, emitHelpers().createAwaitHelper(ts.visitNode(node.expression, visitor, ts.isExpression))), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitYieldExpression(node) {
            if (enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1) {
                if (node.asteriskToken) {
                    var expression = ts.visitNode(ts.Debug.checkDefined(node.expression), visitor, ts.isExpression);
                    return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(undefined, emitHelpers().createAwaitHelper(factory.updateYieldExpression(node, node.asteriskToken, ts.setTextRange(emitHelpers().createAsyncDelegatorHelper(ts.setTextRange(emitHelpers().createAsyncValuesHelper(expression), expression)), expression)))), node), node);
                }
                return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(undefined, createDownlevelAwait(node.expression
                    ? ts.visitNode(node.expression, visitor, ts.isExpression)
                    : factory.createVoidZero())), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitReturnStatement(node) {
            if (enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1) {
                return factory.updateReturnStatement(node, createDownlevelAwait(node.expression ? ts.visitNode(node.expression, visitor, ts.isExpression) : factory.createVoidZero()));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitLabeledStatement(node) {
            if (enclosingFunctionFlags & 2) {
                var statement = ts.unwrapInnermostStatementOfLabel(node);
                if (statement.kind === 247 && statement.awaitModifier) {
                    return visitForOfStatement(statement, node);
                }
                return factory.restoreEnclosingLabel(ts.visitNode(statement, visitor, ts.isStatement, factory.liftToBlock), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function chunkObjectLiteralElements(elements) {
            var chunkObject;
            var objects = [];
            for (var _i = 0, elements_5 = elements; _i < elements_5.length; _i++) {
                var e = elements_5[_i];
                if (e.kind === 301) {
                    if (chunkObject) {
                        objects.push(factory.createObjectLiteralExpression(chunkObject));
                        chunkObject = undefined;
                    }
                    var target = e.expression;
                    objects.push(ts.visitNode(target, visitor, ts.isExpression));
                }
                else {
                    chunkObject = ts.append(chunkObject, e.kind === 299
                        ? factory.createPropertyAssignment(e.name, ts.visitNode(e.initializer, visitor, ts.isExpression))
                        : ts.visitNode(e, visitor, ts.isObjectLiteralElementLike));
                }
            }
            if (chunkObject) {
                objects.push(factory.createObjectLiteralExpression(chunkObject));
            }
            return objects;
        }
        function visitObjectLiteralExpression(node) {
            if (node.transformFlags & 65536) {
                var objects = chunkObjectLiteralElements(node.properties);
                if (objects.length && objects[0].kind !== 207) {
                    objects.unshift(factory.createObjectLiteralExpression());
                }
                var expression = objects[0];
                if (objects.length > 1) {
                    for (var i = 1; i < objects.length; i++) {
                        expression = emitHelpers().createAssignHelper([expression, objects[i]]);
                    }
                    return expression;
                }
                else {
                    return emitHelpers().createAssignHelper(objects);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitExpressionStatement(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        function visitParenthesizedExpression(node, expressionResultIsUnused) {
            return ts.visitEachChild(node, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, context);
        }
        function visitSourceFile(node) {
            var ancestorFacts = enterSubtree(2, ts.isEffectiveStrictModeSourceFile(node, compilerOptions) ?
                0 :
                1);
            exportedVariableStatement = false;
            var visited = ts.visitEachChild(node, visitor, context);
            var statement = ts.concatenate(visited.statements, taggedTemplateStringDeclarations && [
                factory.createVariableStatement(undefined, factory.createVariableDeclarationList(taggedTemplateStringDeclarations))
            ]);
            var result = factory.updateSourceFile(visited, ts.setTextRange(factory.createNodeArray(statement), node.statements));
            exitSubtree(ancestorFacts);
            return result;
        }
        function visitTaggedTemplateExpression(node) {
            return ts.processTaggedTemplateExpression(context, node, visitor, currentSourceFile, recordTaggedTemplateString, ts.ProcessLevel.LiftRestriction);
        }
        function visitBinaryExpression(node, expressionResultIsUnused) {
            if (ts.isDestructuringAssignment(node) && node.left.transformFlags & 65536) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 1, !expressionResultIsUnused);
            }
            if (node.operatorToken.kind === 27) {
                return factory.updateBinaryExpression(node, ts.visitNode(node.left, visitorWithUnusedExpressionResult, ts.isExpression), node.operatorToken, ts.visitNode(node.right, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCommaListExpression(node, expressionResultIsUnused) {
            if (expressionResultIsUnused) {
                return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
            }
            var result;
            for (var i = 0; i < node.elements.length; i++) {
                var element = node.elements[i];
                var visited = ts.visitNode(element, i < node.elements.length - 1 ? visitorWithUnusedExpressionResult : visitor, ts.isExpression);
                if (result || visited !== element) {
                    result || (result = node.elements.slice(0, i));
                    result.push(visited);
                }
            }
            var elements = result ? ts.setTextRange(factory.createNodeArray(result), node.elements) : node.elements;
            return factory.updateCommaListExpression(node, elements);
        }
        function visitCatchClause(node) {
            if (node.variableDeclaration &&
                ts.isBindingPattern(node.variableDeclaration.name) &&
                node.variableDeclaration.name.transformFlags & 65536) {
                var name = factory.getGeneratedNameForNode(node.variableDeclaration.name);
                var updatedDecl = factory.updateVariableDeclaration(node.variableDeclaration, node.variableDeclaration.name, undefined, undefined, name);
                var visitedBindings = ts.flattenDestructuringBinding(updatedDecl, visitor, context, 1);
                var block = ts.visitNode(node.block, visitor, ts.isBlock);
                if (ts.some(visitedBindings)) {
                    block = factory.updateBlock(block, __spreadArray([
                        factory.createVariableStatement(undefined, visitedBindings)
                    ], block.statements, true));
                }
                return factory.updateCatchClause(node, factory.updateVariableDeclaration(node.variableDeclaration, name, undefined, undefined, undefined), block);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitVariableStatement(node) {
            if (ts.hasSyntacticModifier(node, 1)) {
                var savedExportedVariableStatement = exportedVariableStatement;
                exportedVariableStatement = true;
                var visited = ts.visitEachChild(node, visitor, context);
                exportedVariableStatement = savedExportedVariableStatement;
                return visited;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitVariableDeclaration(node) {
            if (exportedVariableStatement) {
                var savedExportedVariableStatement = exportedVariableStatement;
                exportedVariableStatement = false;
                var visited = visitVariableDeclarationWorker(node, true);
                exportedVariableStatement = savedExportedVariableStatement;
                return visited;
            }
            return visitVariableDeclarationWorker(node, false);
        }
        function visitVariableDeclarationWorker(node, exportedVariableStatement) {
            if (ts.isBindingPattern(node.name) && node.name.transformFlags & 65536) {
                return ts.flattenDestructuringBinding(node, visitor, context, 1, undefined, exportedVariableStatement);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, visitorWithUnusedExpressionResult, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitorWithUnusedExpressionResult, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
        }
        function visitVoidExpression(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        function visitForOfStatement(node, outermostLabeledStatement) {
            var ancestorFacts = enterSubtree(0, 2);
            if (node.initializer.transformFlags & 65536) {
                node = transformForOfStatementWithObjectRest(node);
            }
            var result = node.awaitModifier ?
                transformForAwaitOfStatement(node, outermostLabeledStatement, ancestorFacts) :
                factory.restoreEnclosingLabel(ts.visitEachChild(node, visitor, context), outermostLabeledStatement);
            exitSubtree(ancestorFacts);
            return result;
        }
        function transformForOfStatementWithObjectRest(node) {
            var initializerWithoutParens = ts.skipParentheses(node.initializer);
            if (ts.isVariableDeclarationList(initializerWithoutParens) || ts.isAssignmentPattern(initializerWithoutParens)) {
                var bodyLocation = void 0;
                var statementsLocation = void 0;
                var temp = factory.createTempVariable(undefined);
                var statements = [ts.createForOfBindingStatement(factory, initializerWithoutParens, temp)];
                if (ts.isBlock(node.statement)) {
                    ts.addRange(statements, node.statement.statements);
                    bodyLocation = node.statement;
                    statementsLocation = node.statement.statements;
                }
                else if (node.statement) {
                    ts.append(statements, node.statement);
                    bodyLocation = node.statement;
                    statementsLocation = node.statement;
                }
                return factory.updateForOfStatement(node, node.awaitModifier, ts.setTextRange(factory.createVariableDeclarationList([
                    ts.setTextRange(factory.createVariableDeclaration(temp), node.initializer)
                ], 1), node.initializer), node.expression, ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), statementsLocation), true), bodyLocation));
            }
            return node;
        }
        function convertForOfStatementHead(node, boundValue, nonUserCode) {
            var value = factory.createTempVariable(hoistVariableDeclaration);
            var iteratorValueExpression = factory.createAssignment(value, boundValue);
            var iteratorValueStatement = factory.createExpressionStatement(iteratorValueExpression);
            ts.setSourceMapRange(iteratorValueStatement, node.expression);
            var exitNonUserCodeExpression = factory.createAssignment(nonUserCode, factory.createFalse());
            var exitNonUserCodeStatement = factory.createExpressionStatement(exitNonUserCodeExpression);
            ts.setSourceMapRange(exitNonUserCodeStatement, node.expression);
            var enterNonUserCodeExpression = factory.createAssignment(nonUserCode, factory.createTrue());
            var enterNonUserCodeStatement = factory.createExpressionStatement(enterNonUserCodeExpression);
            ts.setSourceMapRange(exitNonUserCodeStatement, node.expression);
            var statements = [];
            var binding = ts.createForOfBindingStatement(factory, node.initializer, value);
            statements.push(ts.visitNode(binding, visitor, ts.isStatement));
            var bodyLocation;
            var statementsLocation;
            var statement = ts.visitIterationBody(node.statement, visitor, context);
            if (ts.isBlock(statement)) {
                ts.addRange(statements, statement.statements);
                bodyLocation = statement;
                statementsLocation = statement.statements;
            }
            else {
                statements.push(statement);
            }
            var body = ts.setEmitFlags(ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), statementsLocation), true), bodyLocation), 48 | 384);
            return factory.createBlock([
                iteratorValueStatement,
                exitNonUserCodeStatement,
                factory.createTryStatement(body, undefined, factory.createBlock([
                    enterNonUserCodeStatement
                ]))
            ]);
        }
        function createDownlevelAwait(expression) {
            return enclosingFunctionFlags & 1
                ? factory.createYieldExpression(undefined, emitHelpers().createAwaitHelper(expression))
                : factory.createAwaitExpression(expression);
        }
        function transformForAwaitOfStatement(node, outermostLabeledStatement, ancestorFacts) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var iterator = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(expression) : factory.createTempVariable(undefined);
            var result = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(iterator) : factory.createTempVariable(undefined);
            var nonUserCode = factory.createTempVariable(undefined);
            var done = factory.createTempVariable(hoistVariableDeclaration);
            var errorRecord = factory.createUniqueName("e");
            var catchVariable = factory.getGeneratedNameForNode(errorRecord);
            var returnMethod = factory.createTempVariable(undefined);
            var callValues = ts.setTextRange(emitHelpers().createAsyncValuesHelper(expression), node.expression);
            var callNext = factory.createCallExpression(factory.createPropertyAccessExpression(iterator, "next"), undefined, []);
            var getDone = factory.createPropertyAccessExpression(result, "done");
            var getValue = factory.createPropertyAccessExpression(result, "value");
            var callReturn = factory.createFunctionCallCall(returnMethod, iterator, []);
            hoistVariableDeclaration(errorRecord);
            hoistVariableDeclaration(returnMethod);
            var initializer = ancestorFacts & 2 ?
                factory.inlineExpressions([factory.createAssignment(errorRecord, factory.createVoidZero()), callValues]) :
                callValues;
            var forStatement = ts.setEmitFlags(ts.setTextRange(factory.createForStatement(ts.setEmitFlags(ts.setTextRange(factory.createVariableDeclarationList([
                factory.createVariableDeclaration(nonUserCode, undefined, undefined, factory.createTrue()),
                ts.setTextRange(factory.createVariableDeclaration(iterator, undefined, undefined, initializer), node.expression),
                factory.createVariableDeclaration(result)
            ]), node.expression), 2097152), factory.inlineExpressions([
                factory.createAssignment(result, createDownlevelAwait(callNext)),
                factory.createAssignment(done, getDone),
                factory.createLogicalNot(done)
            ]), undefined, convertForOfStatementHead(node, getValue, nonUserCode)), node), 256);
            ts.setOriginalNode(forStatement, node);
            return factory.createTryStatement(factory.createBlock([
                factory.restoreEnclosingLabel(forStatement, outermostLabeledStatement)
            ]), factory.createCatchClause(factory.createVariableDeclaration(catchVariable), ts.setEmitFlags(factory.createBlock([
                factory.createExpressionStatement(factory.createAssignment(errorRecord, factory.createObjectLiteralExpression([
                    factory.createPropertyAssignment("error", catchVariable)
                ])))
            ]), 1)), factory.createBlock([
                factory.createTryStatement(factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(factory.createLogicalAnd(factory.createLogicalAnd(factory.createLogicalNot(nonUserCode), factory.createLogicalNot(done)), factory.createAssignment(returnMethod, factory.createPropertyAccessExpression(iterator, "return"))), factory.createExpressionStatement(createDownlevelAwait(callReturn))), 1)
                ]), undefined, ts.setEmitFlags(factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(errorRecord, factory.createThrowStatement(factory.createPropertyAccessExpression(errorRecord, "error"))), 1)
                ]), 1))
            ]));
        }
        function parameterVisitor(node) {
            ts.Debug.assertNode(node, ts.isParameter);
            return visitParameter(node);
        }
        function visitParameter(node) {
            if (parametersWithPrecedingObjectRestOrSpread === null || parametersWithPrecedingObjectRestOrSpread === void 0 ? void 0 : parametersWithPrecedingObjectRestOrSpread.has(node)) {
                return factory.updateParameterDeclaration(node, undefined, node.dotDotDotToken, ts.isBindingPattern(node.name) ? factory.getGeneratedNameForNode(node) : node.name, undefined, undefined, undefined);
            }
            if (node.transformFlags & 65536) {
                return factory.updateParameterDeclaration(node, undefined, node.dotDotDotToken, factory.getGeneratedNameForNode(node), undefined, undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function collectParametersWithPrecedingObjectRestOrSpread(node) {
            var parameters;
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                if (parameters) {
                    parameters.add(parameter);
                }
                else if (parameter.transformFlags & 65536) {
                    parameters = new ts.Set();
                }
            }
            return parameters;
        }
        function visitConstructorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateConstructorDeclaration(node, node.modifiers, ts.visitParameterList(node.parameters, parameterVisitor, context), transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitGetAccessorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateGetAccessorDeclaration(node, node.modifiers, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitParameterList(node.parameters, parameterVisitor, context), undefined, transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitSetAccessorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateSetAccessorDeclaration(node, node.modifiers, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitParameterList(node.parameters, parameterVisitor, context), transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitMethodDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateMethodDeclaration(node, enclosingFunctionFlags & 1
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifierLike)
                : node.modifiers, enclosingFunctionFlags & 2
                ? undefined
                : node.asteriskToken, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitNode(undefined, visitor, ts.isToken), undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), undefined, enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitFunctionDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateFunctionDeclaration(node, enclosingFunctionFlags & 1
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2
                ? undefined
                : node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), undefined, enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitArrowFunction(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateArrowFunction(node, node.modifiers, undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), undefined, node.equalsGreaterThanToken, transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitFunctionExpression(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateFunctionExpression(node, enclosingFunctionFlags & 1
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2
                ? undefined
                : node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), undefined, enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function transformAsyncGeneratorFunctionBody(node) {
            resumeLexicalEnvironment();
            var statements = [];
            var statementOffset = factory.copyPrologue(node.body.statements, statements, false, visitor);
            appendObjectRestAssignmentsIfNeeded(statements, node);
            var savedCapturedSuperProperties = capturedSuperProperties;
            var savedHasSuperElementAccess = hasSuperElementAccess;
            capturedSuperProperties = new ts.Set();
            hasSuperElementAccess = false;
            var returnStatement = factory.createReturnStatement(emitHelpers().createAsyncGeneratorHelper(factory.createFunctionExpression(undefined, factory.createToken(41), node.name && factory.getGeneratedNameForNode(node.name), undefined, [], undefined, factory.updateBlock(node.body, ts.visitLexicalEnvironment(node.body.statements, visitor, context, statementOffset))), !!(hierarchyFacts & 1)));
            var emitSuperHelpers = languageVersion >= 2 && resolver.getNodeCheckFlags(node) & (4096 | 2048);
            if (emitSuperHelpers) {
                enableSubstitutionForAsyncMethodsWithSuper();
                var variableStatement = ts.createSuperAccessVariableStatement(factory, resolver, node, capturedSuperProperties);
                substitutedSuperAccessors[ts.getNodeId(variableStatement)] = true;
                ts.insertStatementsAfterStandardPrologue(statements, [variableStatement]);
            }
            statements.push(returnStatement);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var block = factory.updateBlock(node.body, statements);
            if (emitSuperHelpers && hasSuperElementAccess) {
                if (resolver.getNodeCheckFlags(node) & 4096) {
                    ts.addEmitHelper(block, ts.advancedAsyncSuperHelper);
                }
                else if (resolver.getNodeCheckFlags(node) & 2048) {
                    ts.addEmitHelper(block, ts.asyncSuperHelper);
                }
            }
            capturedSuperProperties = savedCapturedSuperProperties;
            hasSuperElementAccess = savedHasSuperElementAccess;
            return block;
        }
        function transformFunctionBody(node) {
            var _a;
            resumeLexicalEnvironment();
            var statementOffset = 0;
            var statements = [];
            var body = (_a = ts.visitNode(node.body, visitor, ts.isConciseBody)) !== null && _a !== void 0 ? _a : factory.createBlock([]);
            if (ts.isBlock(body)) {
                statementOffset = factory.copyPrologue(body.statements, statements, false, visitor);
            }
            ts.addRange(statements, appendObjectRestAssignmentsIfNeeded(undefined, node));
            var leadingStatements = endLexicalEnvironment();
            if (statementOffset > 0 || ts.some(statements) || ts.some(leadingStatements)) {
                var block = factory.converters.convertToFunctionBlock(body, true);
                ts.insertStatementsAfterStandardPrologue(statements, leadingStatements);
                ts.addRange(statements, block.statements.slice(statementOffset));
                return factory.updateBlock(block, ts.setTextRange(factory.createNodeArray(statements), block.statements));
            }
            return body;
        }
        function appendObjectRestAssignmentsIfNeeded(statements, node) {
            var containsPrecedingObjectRestOrSpread = false;
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                if (containsPrecedingObjectRestOrSpread) {
                    if (ts.isBindingPattern(parameter.name)) {
                        if (parameter.name.elements.length > 0) {
                            var declarations = ts.flattenDestructuringBinding(parameter, visitor, context, 0, factory.getGeneratedNameForNode(parameter));
                            if (ts.some(declarations)) {
                                var declarationList = factory.createVariableDeclarationList(declarations);
                                var statement = factory.createVariableStatement(undefined, declarationList);
                                ts.setEmitFlags(statement, 1048576);
                                statements = ts.append(statements, statement);
                            }
                        }
                        else if (parameter.initializer) {
                            var name = factory.getGeneratedNameForNode(parameter);
                            var initializer = ts.visitNode(parameter.initializer, visitor, ts.isExpression);
                            var assignment = factory.createAssignment(name, initializer);
                            var statement = factory.createExpressionStatement(assignment);
                            ts.setEmitFlags(statement, 1048576);
                            statements = ts.append(statements, statement);
                        }
                    }
                    else if (parameter.initializer) {
                        var name = factory.cloneNode(parameter.name);
                        ts.setTextRange(name, parameter.name);
                        ts.setEmitFlags(name, 48);
                        var initializer = ts.visitNode(parameter.initializer, visitor, ts.isExpression);
                        ts.addEmitFlags(initializer, 48 | 1536);
                        var assignment = factory.createAssignment(name, initializer);
                        ts.setTextRange(assignment, parameter);
                        ts.setEmitFlags(assignment, 1536);
                        var block = factory.createBlock([factory.createExpressionStatement(assignment)]);
                        ts.setTextRange(block, parameter);
                        ts.setEmitFlags(block, 1 | 32 | 384 | 1536);
                        var typeCheck = factory.createTypeCheck(factory.cloneNode(parameter.name), "undefined");
                        var statement = factory.createIfStatement(typeCheck, block);
                        ts.startOnNewLine(statement);
                        ts.setTextRange(statement, parameter);
                        ts.setEmitFlags(statement, 384 | 32 | 1048576 | 1536);
                        statements = ts.append(statements, statement);
                    }
                }
                else if (parameter.transformFlags & 65536) {
                    containsPrecedingObjectRestOrSpread = true;
                    var declarations = ts.flattenDestructuringBinding(parameter, visitor, context, 1, factory.getGeneratedNameForNode(parameter), false, true);
                    if (ts.some(declarations)) {
                        var declarationList = factory.createVariableDeclarationList(declarations);
                        var statement = factory.createVariableStatement(undefined, declarationList);
                        ts.setEmitFlags(statement, 1048576);
                        statements = ts.append(statements, statement);
                    }
                }
            }
            return statements;
        }
        function enableSubstitutionForAsyncMethodsWithSuper() {
            if ((enabledSubstitutions & 1) === 0) {
                enabledSubstitutions |= 1;
                context.enableSubstitution(210);
                context.enableSubstitution(208);
                context.enableSubstitution(209);
                context.enableEmitNotification(260);
                context.enableEmitNotification(171);
                context.enableEmitNotification(174);
                context.enableEmitNotification(175);
                context.enableEmitNotification(173);
                context.enableEmitNotification(240);
            }
        }
        function onEmitNode(hint, node, emitCallback) {
            if (enabledSubstitutions & 1 && isSuperContainer(node)) {
                var superContainerFlags = resolver.getNodeCheckFlags(node) & (2048 | 4096);
                if (superContainerFlags !== enclosingSuperContainerFlags) {
                    var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                    enclosingSuperContainerFlags = superContainerFlags;
                    previousOnEmitNode(hint, node, emitCallback);
                    enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                    return;
                }
            }
            else if (enabledSubstitutions && substitutedSuperAccessors[ts.getNodeId(node)]) {
                var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                enclosingSuperContainerFlags = 0;
                previousOnEmitNode(hint, node, emitCallback);
                enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                return;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 && enclosingSuperContainerFlags) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 208:
                    return substitutePropertyAccessExpression(node);
                case 209:
                    return substituteElementAccessExpression(node);
                case 210:
                    return substituteCallExpression(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (node.expression.kind === 106) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createUniqueName("_super", 16 | 32), node.name), node);
            }
            return node;
        }
        function substituteElementAccessExpression(node) {
            if (node.expression.kind === 106) {
                return createSuperElementAccessInAsyncMethod(node.argumentExpression, node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            var expression = node.expression;
            if (ts.isSuperProperty(expression)) {
                var argumentExpression = ts.isPropertyAccessExpression(expression)
                    ? substitutePropertyAccessExpression(expression)
                    : substituteElementAccessExpression(expression);
                return factory.createCallExpression(factory.createPropertyAccessExpression(argumentExpression, "call"), undefined, __spreadArray([
                    factory.createThis()
                ], node.arguments, true));
            }
            return node;
        }
        function isSuperContainer(node) {
            var kind = node.kind;
            return kind === 260
                || kind === 173
                || kind === 171
                || kind === 174
                || kind === 175;
        }
        function createSuperElementAccessInAsyncMethod(argumentExpression, location) {
            if (enclosingSuperContainerFlags & 4096) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createCallExpression(factory.createIdentifier("_superIndex"), undefined, [argumentExpression]), "value"), location);
            }
            else {
                return ts.setTextRange(factory.createCallExpression(factory.createIdentifier("_superIndex"), undefined, [argumentExpression]), location);
            }
        }
    }
    ts.transformES2018 = transformES2018;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformES2019(context) {
        var factory = context.factory;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 64) === 0) {
                return node;
            }
            switch (node.kind) {
                case 295:
                    return visitCatchClause(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitCatchClause(node) {
            if (!node.variableDeclaration) {
                return factory.updateCatchClause(node, factory.createVariableDeclaration(factory.createTempVariable(undefined)), ts.visitNode(node.block, visitor, ts.isBlock));
            }
            return ts.visitEachChild(node, visitor, context);
        }
    }
    ts.transformES2019 = transformES2019;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformES2020(context) {
        var factory = context.factory, hoistVariableDeclaration = context.hoistVariableDeclaration;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 32) === 0) {
                return node;
            }
            switch (node.kind) {
                case 210: {
                    var updated = visitNonOptionalCallExpression(node, false);
                    ts.Debug.assertNotNode(updated, ts.isSyntheticReference);
                    return updated;
                }
                case 208:
                case 209:
                    if (ts.isOptionalChain(node)) {
                        var updated = visitOptionalExpression(node, false, false);
                        ts.Debug.assertNotNode(updated, ts.isSyntheticReference);
                        return updated;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 223:
                    if (node.operatorToken.kind === 60) {
                        return transformNullishCoalescingExpression(node);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 217:
                    return visitDeleteExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function flattenChain(chain) {
            ts.Debug.assertNotNode(chain, ts.isNonNullChain);
            var links = [chain];
            while (!chain.questionDotToken && !ts.isTaggedTemplateExpression(chain)) {
                chain = ts.cast(ts.skipPartiallyEmittedExpressions(chain.expression), ts.isOptionalChain);
                ts.Debug.assertNotNode(chain, ts.isNonNullChain);
                links.unshift(chain);
            }
            return { expression: chain.expression, chain: links };
        }
        function visitNonOptionalParenthesizedExpression(node, captureThisArg, isDelete) {
            var expression = visitNonOptionalExpression(node.expression, captureThisArg, isDelete);
            if (ts.isSyntheticReference(expression)) {
                return factory.createSyntheticReferenceExpression(factory.updateParenthesizedExpression(node, expression.expression), expression.thisArg);
            }
            return factory.updateParenthesizedExpression(node, expression);
        }
        function visitNonOptionalPropertyOrElementAccessExpression(node, captureThisArg, isDelete) {
            if (ts.isOptionalChain(node)) {
                return visitOptionalExpression(node, captureThisArg, isDelete);
            }
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            ts.Debug.assertNotNode(expression, ts.isSyntheticReference);
            var thisArg;
            if (captureThisArg) {
                if (!ts.isSimpleCopiableExpression(expression)) {
                    thisArg = factory.createTempVariable(hoistVariableDeclaration);
                    expression = factory.createAssignment(thisArg, expression);
                }
                else {
                    thisArg = expression;
                }
            }
            expression = node.kind === 208
                ? factory.updatePropertyAccessExpression(node, expression, ts.visitNode(node.name, visitor, ts.isIdentifier))
                : factory.updateElementAccessExpression(node, expression, ts.visitNode(node.argumentExpression, visitor, ts.isExpression));
            return thisArg ? factory.createSyntheticReferenceExpression(expression, thisArg) : expression;
        }
        function visitNonOptionalCallExpression(node, captureThisArg) {
            if (ts.isOptionalChain(node)) {
                return visitOptionalExpression(node, captureThisArg, false);
            }
            if (ts.isParenthesizedExpression(node.expression) && ts.isOptionalChain(ts.skipParentheses(node.expression))) {
                var expression = visitNonOptionalParenthesizedExpression(node.expression, true, false);
                var args = ts.visitNodes(node.arguments, visitor, ts.isExpression);
                if (ts.isSyntheticReference(expression)) {
                    return ts.setTextRange(factory.createFunctionCallCall(expression.expression, expression.thisArg, args), node);
                }
                return factory.updateCallExpression(node, expression, undefined, args);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitNonOptionalExpression(node, captureThisArg, isDelete) {
            switch (node.kind) {
                case 214: return visitNonOptionalParenthesizedExpression(node, captureThisArg, isDelete);
                case 208:
                case 209: return visitNonOptionalPropertyOrElementAccessExpression(node, captureThisArg, isDelete);
                case 210: return visitNonOptionalCallExpression(node, captureThisArg);
                default: return ts.visitNode(node, visitor, ts.isExpression);
            }
        }
        function visitOptionalExpression(node, captureThisArg, isDelete) {
            var _a = flattenChain(node), expression = _a.expression, chain = _a.chain;
            var left = visitNonOptionalExpression(ts.skipPartiallyEmittedExpressions(expression), ts.isCallChain(chain[0]), false);
            var leftThisArg = ts.isSyntheticReference(left) ? left.thisArg : undefined;
            var capturedLeft = ts.isSyntheticReference(left) ? left.expression : left;
            var leftExpression = factory.restoreOuterExpressions(expression, capturedLeft, 8);
            if (!ts.isSimpleCopiableExpression(capturedLeft)) {
                capturedLeft = factory.createTempVariable(hoistVariableDeclaration);
                leftExpression = factory.createAssignment(capturedLeft, leftExpression);
            }
            var rightExpression = capturedLeft;
            var thisArg;
            for (var i = 0; i < chain.length; i++) {
                var segment = chain[i];
                switch (segment.kind) {
                    case 208:
                    case 209:
                        if (i === chain.length - 1 && captureThisArg) {
                            if (!ts.isSimpleCopiableExpression(rightExpression)) {
                                thisArg = factory.createTempVariable(hoistVariableDeclaration);
                                rightExpression = factory.createAssignment(thisArg, rightExpression);
                            }
                            else {
                                thisArg = rightExpression;
                            }
                        }
                        rightExpression = segment.kind === 208
                            ? factory.createPropertyAccessExpression(rightExpression, ts.visitNode(segment.name, visitor, ts.isIdentifier))
                            : factory.createElementAccessExpression(rightExpression, ts.visitNode(segment.argumentExpression, visitor, ts.isExpression));
                        break;
                    case 210:
                        if (i === 0 && leftThisArg) {
                            if (!ts.isGeneratedIdentifier(leftThisArg)) {
                                leftThisArg = factory.cloneNode(leftThisArg);
                                ts.addEmitFlags(leftThisArg, 1536);
                            }
                            rightExpression = factory.createFunctionCallCall(rightExpression, leftThisArg.kind === 106 ? factory.createThis() : leftThisArg, ts.visitNodes(segment.arguments, visitor, ts.isExpression));
                        }
                        else {
                            rightExpression = factory.createCallExpression(rightExpression, undefined, ts.visitNodes(segment.arguments, visitor, ts.isExpression));
                        }
                        break;
                }
                ts.setOriginalNode(rightExpression, segment);
            }
            var target = isDelete
                ? factory.createConditionalExpression(createNotNullCondition(leftExpression, capturedLeft, true), undefined, factory.createTrue(), undefined, factory.createDeleteExpression(rightExpression))
                : factory.createConditionalExpression(createNotNullCondition(leftExpression, capturedLeft, true), undefined, factory.createVoidZero(), undefined, rightExpression);
            ts.setTextRange(target, node);
            return thisArg ? factory.createSyntheticReferenceExpression(target, thisArg) : target;
        }
        function createNotNullCondition(left, right, invert) {
            return factory.createBinaryExpression(factory.createBinaryExpression(left, factory.createToken(invert ? 36 : 37), factory.createNull()), factory.createToken(invert ? 56 : 55), factory.createBinaryExpression(right, factory.createToken(invert ? 36 : 37), factory.createVoidZero()));
        }
        function transformNullishCoalescingExpression(node) {
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = left;
            if (!ts.isSimpleCopiableExpression(left)) {
                right = factory.createTempVariable(hoistVariableDeclaration);
                left = factory.createAssignment(right, left);
            }
            return ts.setTextRange(factory.createConditionalExpression(createNotNullCondition(left, right), undefined, right, undefined, ts.visitNode(node.right, visitor, ts.isExpression)), node);
        }
        function visitDeleteExpression(node) {
            return ts.isOptionalChain(ts.skipParentheses(node.expression))
                ? ts.setOriginalNode(visitNonOptionalExpression(node.expression, false, true), node)
                : factory.updateDeleteExpression(node, ts.visitNode(node.expression, visitor, ts.isExpression));
        }
    }
    ts.transformES2020 = transformES2020;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformES2021(context) {
        var hoistVariableDeclaration = context.hoistVariableDeclaration, factory = context.factory;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 16) === 0) {
                return node;
            }
            switch (node.kind) {
                case 223:
                    var binaryExpression = node;
                    if (ts.isLogicalOrCoalescingAssignmentExpression(binaryExpression)) {
                        return transformLogicalAssignment(binaryExpression);
                    }
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformLogicalAssignment(binaryExpression) {
            var operator = binaryExpression.operatorToken;
            var nonAssignmentOperator = ts.getNonAssignmentOperatorForCompoundAssignment(operator.kind);
            var left = ts.skipParentheses(ts.visitNode(binaryExpression.left, visitor, ts.isLeftHandSideExpression));
            var assignmentTarget = left;
            var right = ts.skipParentheses(ts.visitNode(binaryExpression.right, visitor, ts.isExpression));
            if (ts.isAccessExpression(left)) {
                var propertyAccessTargetSimpleCopiable = ts.isSimpleCopiableExpression(left.expression);
                var propertyAccessTarget = propertyAccessTargetSimpleCopiable ? left.expression :
                    factory.createTempVariable(hoistVariableDeclaration);
                var propertyAccessTargetAssignment = propertyAccessTargetSimpleCopiable ? left.expression : factory.createAssignment(propertyAccessTarget, left.expression);
                if (ts.isPropertyAccessExpression(left)) {
                    assignmentTarget = factory.createPropertyAccessExpression(propertyAccessTarget, left.name);
                    left = factory.createPropertyAccessExpression(propertyAccessTargetAssignment, left.name);
                }
                else {
                    var elementAccessArgumentSimpleCopiable = ts.isSimpleCopiableExpression(left.argumentExpression);
                    var elementAccessArgument = elementAccessArgumentSimpleCopiable ? left.argumentExpression :
                        factory.createTempVariable(hoistVariableDeclaration);
                    assignmentTarget = factory.createElementAccessExpression(propertyAccessTarget, elementAccessArgument);
                    left = factory.createElementAccessExpression(propertyAccessTargetAssignment, elementAccessArgumentSimpleCopiable ? left.argumentExpression : factory.createAssignment(elementAccessArgument, left.argumentExpression));
                }
            }
            return factory.createBinaryExpression(left, nonAssignmentOperator, factory.createParenthesizedExpression(factory.createAssignment(assignmentTarget, right)));
        }
    }
    ts.transformES2021 = transformES2021;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformESNext(context) {
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 4) === 0) {
                return node;
            }
            switch (node.kind) {
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
    }
    ts.transformESNext = transformESNext;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformJsx(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory;
        var compilerOptions = context.getCompilerOptions();
        var currentSourceFile;
        var currentFileState;
        return ts.chainBundle(context, transformSourceFile);
        function getCurrentFileNameExpression() {
            if (currentFileState.filenameDeclaration) {
                return currentFileState.filenameDeclaration.name;
            }
            var declaration = factory.createVariableDeclaration(factory.createUniqueName("_jsxFileName", 16 | 32), undefined, undefined, factory.createStringLiteral(currentSourceFile.fileName));
            currentFileState.filenameDeclaration = declaration;
            return currentFileState.filenameDeclaration.name;
        }
        function getJsxFactoryCalleePrimitive(isStaticChildren) {
            return compilerOptions.jsx === 5 ? "jsxDEV" : isStaticChildren ? "jsxs" : "jsx";
        }
        function getJsxFactoryCallee(isStaticChildren) {
            var type = getJsxFactoryCalleePrimitive(isStaticChildren);
            return getImplicitImportForName(type);
        }
        function getImplicitJsxFragmentReference() {
            return getImplicitImportForName("Fragment");
        }
        function getImplicitImportForName(name) {
            var _a, _b;
            var importSource = name === "createElement"
                ? currentFileState.importSpecifier
                : ts.getJSXRuntimeImport(currentFileState.importSpecifier, compilerOptions);
            var existing = (_b = (_a = currentFileState.utilizedImplicitRuntimeImports) === null || _a === void 0 ? void 0 : _a.get(importSource)) === null || _b === void 0 ? void 0 : _b.get(name);
            if (existing) {
                return existing.name;
            }
            if (!currentFileState.utilizedImplicitRuntimeImports) {
                currentFileState.utilizedImplicitRuntimeImports = new ts.Map();
            }
            var specifierSourceImports = currentFileState.utilizedImplicitRuntimeImports.get(importSource);
            if (!specifierSourceImports) {
                specifierSourceImports = new ts.Map();
                currentFileState.utilizedImplicitRuntimeImports.set(importSource, specifierSourceImports);
            }
            var generatedName = factory.createUniqueName("_".concat(name), 16 | 32 | 64);
            var specifier = factory.createImportSpecifier(false, factory.createIdentifier(name), generatedName);
            generatedName.generatedImportReference = specifier;
            specifierSourceImports.set(name, specifier);
            return generatedName;
        }
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            currentFileState = {};
            currentFileState.importSpecifier = ts.getJSXImplicitImportBase(compilerOptions, node);
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            var statements = visited.statements;
            if (currentFileState.filenameDeclaration) {
                statements = ts.insertStatementAfterCustomPrologue(statements.slice(), factory.createVariableStatement(undefined, factory.createVariableDeclarationList([currentFileState.filenameDeclaration], 2)));
            }
            if (currentFileState.utilizedImplicitRuntimeImports) {
                for (var _i = 0, _a = ts.arrayFrom(currentFileState.utilizedImplicitRuntimeImports.entries()); _i < _a.length; _i++) {
                    var _b = _a[_i], importSource = _b[0], importSpecifiersMap = _b[1];
                    if (ts.isExternalModule(node)) {
                        var importStatement = factory.createImportDeclaration(undefined, factory.createImportClause(false, undefined, factory.createNamedImports(ts.arrayFrom(importSpecifiersMap.values()))), factory.createStringLiteral(importSource), undefined);
                        ts.setParentRecursive(importStatement, false);
                        statements = ts.insertStatementAfterCustomPrologue(statements.slice(), importStatement);
                    }
                    else if (ts.isExternalOrCommonJsModule(node)) {
                        var requireStatement = factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                            factory.createVariableDeclaration(factory.createObjectBindingPattern(ts.map(ts.arrayFrom(importSpecifiersMap.values()), function (s) { return factory.createBindingElement(undefined, s.propertyName, s.name); })), undefined, undefined, factory.createCallExpression(factory.createIdentifier("require"), undefined, [factory.createStringLiteral(importSource)]))
                        ], 2));
                        ts.setParentRecursive(requireStatement, false);
                        statements = ts.insertStatementAfterCustomPrologue(statements.slice(), requireStatement);
                    }
                    else {
                    }
                }
            }
            if (statements !== visited.statements) {
                visited = factory.updateSourceFile(visited, statements);
            }
            currentFileState = undefined;
            return visited;
        }
        function visitor(node) {
            if (node.transformFlags & 2) {
                return visitorWorker(node);
            }
            else {
                return node;
            }
        }
        function visitorWorker(node) {
            switch (node.kind) {
                case 281:
                    return visitJsxElement(node, false);
                case 282:
                    return visitJsxSelfClosingElement(node, false);
                case 285:
                    return visitJsxFragment(node, false);
                case 291:
                    return visitJsxExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformJsxChildToExpression(node) {
            switch (node.kind) {
                case 11:
                    return visitJsxText(node);
                case 291:
                    return visitJsxExpression(node);
                case 281:
                    return visitJsxElement(node, true);
                case 282:
                    return visitJsxSelfClosingElement(node, true);
                case 285:
                    return visitJsxFragment(node, true);
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
        }
        function hasKeyAfterPropsSpread(node) {
            var spread = false;
            for (var _i = 0, _a = node.attributes.properties; _i < _a.length; _i++) {
                var elem = _a[_i];
                if (ts.isJsxSpreadAttribute(elem)) {
                    spread = true;
                }
                else if (spread && ts.isJsxAttribute(elem) && elem.name.escapedText === "key") {
                    return true;
                }
            }
            return false;
        }
        function shouldUseCreateElement(node) {
            return currentFileState.importSpecifier === undefined || hasKeyAfterPropsSpread(node);
        }
        function visitJsxElement(node, isChild) {
            var tagTransform = shouldUseCreateElement(node.openingElement) ? visitJsxOpeningLikeElementCreateElement : visitJsxOpeningLikeElementJSX;
            return tagTransform(node.openingElement, node.children, isChild, node);
        }
        function visitJsxSelfClosingElement(node, isChild) {
            var tagTransform = shouldUseCreateElement(node) ? visitJsxOpeningLikeElementCreateElement : visitJsxOpeningLikeElementJSX;
            return tagTransform(node, undefined, isChild, node);
        }
        function visitJsxFragment(node, isChild) {
            var tagTransform = currentFileState.importSpecifier === undefined ? visitJsxOpeningFragmentCreateElement : visitJsxOpeningFragmentJSX;
            return tagTransform(node.openingFragment, node.children, isChild, node);
        }
        function convertJsxChildrenToChildrenPropObject(children) {
            var prop = convertJsxChildrenToChildrenPropAssignment(children);
            return prop && factory.createObjectLiteralExpression([prop]);
        }
        function convertJsxChildrenToChildrenPropAssignment(children) {
            var nonWhitespaceChildren = ts.getSemanticJsxChildren(children);
            if (ts.length(nonWhitespaceChildren) === 1 && !nonWhitespaceChildren[0].dotDotDotToken) {
                var result_13 = transformJsxChildToExpression(nonWhitespaceChildren[0]);
                return result_13 && factory.createPropertyAssignment("children", result_13);
            }
            var result = ts.mapDefined(children, transformJsxChildToExpression);
            return ts.length(result) ? factory.createPropertyAssignment("children", factory.createArrayLiteralExpression(result)) : undefined;
        }
        function visitJsxOpeningLikeElementJSX(node, children, isChild, location) {
            var tagName = getTagName(node);
            var childrenProp = children && children.length ? convertJsxChildrenToChildrenPropAssignment(children) : undefined;
            var keyAttr = ts.find(node.attributes.properties, function (p) { return !!p.name && ts.isIdentifier(p.name) && p.name.escapedText === "key"; });
            var attrs = keyAttr ? ts.filter(node.attributes.properties, function (p) { return p !== keyAttr; }) : node.attributes.properties;
            var objectProperties = ts.length(attrs) ? transformJsxAttributesToObjectProps(attrs, childrenProp) :
                factory.createObjectLiteralExpression(childrenProp ? [childrenProp] : ts.emptyArray);
            return visitJsxOpeningLikeElementOrFragmentJSX(tagName, objectProperties, keyAttr, children || ts.emptyArray, isChild, location);
        }
        function visitJsxOpeningLikeElementOrFragmentJSX(tagName, objectProperties, keyAttr, children, isChild, location) {
            var _a;
            var nonWhitespaceChildren = ts.getSemanticJsxChildren(children);
            var isStaticChildren = ts.length(nonWhitespaceChildren) > 1 || !!((_a = nonWhitespaceChildren[0]) === null || _a === void 0 ? void 0 : _a.dotDotDotToken);
            var args = [tagName, objectProperties];
            if (keyAttr) {
                args.push(transformJsxAttributeInitializer(keyAttr.initializer));
            }
            if (compilerOptions.jsx === 5) {
                var originalFile = ts.getOriginalNode(currentSourceFile);
                if (originalFile && ts.isSourceFile(originalFile)) {
                    if (keyAttr === undefined) {
                        args.push(factory.createVoidZero());
                    }
                    args.push(isStaticChildren ? factory.createTrue() : factory.createFalse());
                    var lineCol = ts.getLineAndCharacterOfPosition(originalFile, location.pos);
                    args.push(factory.createObjectLiteralExpression([
                        factory.createPropertyAssignment("fileName", getCurrentFileNameExpression()),
                        factory.createPropertyAssignment("lineNumber", factory.createNumericLiteral(lineCol.line + 1)),
                        factory.createPropertyAssignment("columnNumber", factory.createNumericLiteral(lineCol.character + 1))
                    ]));
                    args.push(factory.createThis());
                }
            }
            var element = ts.setTextRange(factory.createCallExpression(getJsxFactoryCallee(isStaticChildren), undefined, args), location);
            if (isChild) {
                ts.startOnNewLine(element);
            }
            return element;
        }
        function visitJsxOpeningLikeElementCreateElement(node, children, isChild, location) {
            var tagName = getTagName(node);
            var attrs = node.attributes.properties;
            var objectProperties = ts.length(attrs) ? transformJsxAttributesToObjectProps(attrs) :
                factory.createNull();
            var callee = currentFileState.importSpecifier === undefined
                ? ts.createJsxFactoryExpression(factory, context.getEmitResolver().getJsxFactoryEntity(currentSourceFile), compilerOptions.reactNamespace, node)
                : getImplicitImportForName("createElement");
            var element = ts.createExpressionForJsxElement(factory, callee, tagName, objectProperties, ts.mapDefined(children, transformJsxChildToExpression), location);
            if (isChild) {
                ts.startOnNewLine(element);
            }
            return element;
        }
        function visitJsxOpeningFragmentJSX(_node, children, isChild, location) {
            var childrenProps;
            if (children && children.length) {
                var result = convertJsxChildrenToChildrenPropObject(children);
                if (result) {
                    childrenProps = result;
                }
            }
            return visitJsxOpeningLikeElementOrFragmentJSX(getImplicitJsxFragmentReference(), childrenProps || factory.createObjectLiteralExpression([]), undefined, children, isChild, location);
        }
        function visitJsxOpeningFragmentCreateElement(node, children, isChild, location) {
            var element = ts.createExpressionForJsxFragment(factory, context.getEmitResolver().getJsxFactoryEntity(currentSourceFile), context.getEmitResolver().getJsxFragmentFactoryEntity(currentSourceFile), compilerOptions.reactNamespace, ts.mapDefined(children, transformJsxChildToExpression), node, location);
            if (isChild) {
                ts.startOnNewLine(element);
            }
            return element;
        }
        function transformJsxSpreadAttributeToSpreadAssignment(node) {
            return factory.createSpreadAssignment(ts.visitNode(node.expression, visitor, ts.isExpression));
        }
        function transformJsxAttributesToObjectProps(attrs, children) {
            var target = ts.getEmitScriptTarget(compilerOptions);
            return target && target >= 5 ? factory.createObjectLiteralExpression(transformJsxAttributesToProps(attrs, children)) :
                transformJsxAttributesToExpression(attrs, children);
        }
        function transformJsxAttributesToProps(attrs, children) {
            var props = ts.flatten(ts.spanMap(attrs, ts.isJsxSpreadAttribute, function (attrs, isSpread) {
                return ts.map(attrs, function (attr) { return isSpread ? transformJsxSpreadAttributeToSpreadAssignment(attr) : transformJsxAttributeToObjectLiteralElement(attr); });
            }));
            if (children) {
                props.push(children);
            }
            return props;
        }
        function transformJsxAttributesToExpression(attrs, children) {
            var expressions = ts.flatten(ts.spanMap(attrs, ts.isJsxSpreadAttribute, function (attrs, isSpread) { return isSpread
                ? ts.map(attrs, transformJsxSpreadAttributeToExpression)
                : factory.createObjectLiteralExpression(ts.map(attrs, transformJsxAttributeToObjectLiteralElement)); }));
            if (ts.isJsxSpreadAttribute(attrs[0])) {
                expressions.unshift(factory.createObjectLiteralExpression());
            }
            if (children) {
                expressions.push(factory.createObjectLiteralExpression([children]));
            }
            return ts.singleOrUndefined(expressions) || emitHelpers().createAssignHelper(expressions);
        }
        function transformJsxSpreadAttributeToExpression(node) {
            return ts.visitNode(node.expression, visitor, ts.isExpression);
        }
        function transformJsxAttributeToObjectLiteralElement(node) {
            var name = getAttributeName(node);
            var expression = transformJsxAttributeInitializer(node.initializer);
            return factory.createPropertyAssignment(name, expression);
        }
        function transformJsxAttributeInitializer(node) {
            if (node === undefined) {
                return factory.createTrue();
            }
            if (node.kind === 10) {
                var singleQuote = node.singleQuote !== undefined ? node.singleQuote : !ts.isStringDoubleQuoted(node, currentSourceFile);
                var literal = factory.createStringLiteral(tryDecodeEntities(node.text) || node.text, singleQuote);
                return ts.setTextRange(literal, node);
            }
            if (node.kind === 291) {
                if (node.expression === undefined) {
                    return factory.createTrue();
                }
                return ts.visitNode(node.expression, visitor, ts.isExpression);
            }
            if (ts.isJsxElement(node)) {
                return visitJsxElement(node, false);
            }
            if (ts.isJsxSelfClosingElement(node)) {
                return visitJsxSelfClosingElement(node, false);
            }
            if (ts.isJsxFragment(node)) {
                return visitJsxFragment(node, false);
            }
            return ts.Debug.failBadSyntaxKind(node);
        }
        function visitJsxText(node) {
            var fixed = fixupWhitespaceAndDecodeEntities(node.text);
            return fixed === undefined ? undefined : factory.createStringLiteral(fixed);
        }
        function fixupWhitespaceAndDecodeEntities(text) {
            var acc;
            var firstNonWhitespace = 0;
            var lastNonWhitespace = -1;
            for (var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);
                if (ts.isLineBreak(c)) {
                    if (firstNonWhitespace !== -1 && lastNonWhitespace !== -1) {
                        acc = addLineOfJsxText(acc, text.substr(firstNonWhitespace, lastNonWhitespace - firstNonWhitespace + 1));
                    }
                    firstNonWhitespace = -1;
                }
                else if (!ts.isWhiteSpaceSingleLine(c)) {
                    lastNonWhitespace = i;
                    if (firstNonWhitespace === -1) {
                        firstNonWhitespace = i;
                    }
                }
            }
            return firstNonWhitespace !== -1
                ? addLineOfJsxText(acc, text.substr(firstNonWhitespace))
                : acc;
        }
        function addLineOfJsxText(acc, trimmedLine) {
            var decoded = decodeEntities(trimmedLine);
            return acc === undefined ? decoded : acc + " " + decoded;
        }
        function decodeEntities(text) {
            return text.replace(/&((#((\d+)|x([\da-fA-F]+)))|(\w+));/g, function (match, _all, _number, _digits, decimal, hex, word) {
                if (decimal) {
                    return ts.utf16EncodeAsString(parseInt(decimal, 10));
                }
                else if (hex) {
                    return ts.utf16EncodeAsString(parseInt(hex, 16));
                }
                else {
                    var ch = entities.get(word);
                    return ch ? ts.utf16EncodeAsString(ch) : match;
                }
            });
        }
        function tryDecodeEntities(text) {
            var decoded = decodeEntities(text);
            return decoded === text ? undefined : decoded;
        }
        function getTagName(node) {
            if (node.kind === 281) {
                return getTagName(node.openingElement);
            }
            else {
                var name = node.tagName;
                if (ts.isIdentifier(name) && ts.isIntrinsicJsxName(name.escapedText)) {
                    return factory.createStringLiteral(ts.idText(name));
                }
                else {
                    return ts.createExpressionFromEntityName(factory, name);
                }
            }
        }
        function getAttributeName(node) {
            var name = node.name;
            var text = ts.idText(name);
            if (/^[A-Za-z_]\w*$/.test(text)) {
                return name;
            }
            else {
                return factory.createStringLiteral(text);
            }
        }
        function visitJsxExpression(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            return node.dotDotDotToken ? factory.createSpreadElement(expression) : expression;
        }
    }
    ts.transformJsx = transformJsx;
    var entities = new ts.Map(ts.getEntries({
        quot: 0x0022,
        amp: 0x0026,
        apos: 0x0027,
        lt: 0x003C,
        gt: 0x003E,
        nbsp: 0x00A0,
        iexcl: 0x00A1,
        cent: 0x00A2,
        pound: 0x00A3,
        curren: 0x00A4,
        yen: 0x00A5,
        brvbar: 0x00A6,
        sect: 0x00A7,
        uml: 0x00A8,
        copy: 0x00A9,
        ordf: 0x00AA,
        laquo: 0x00AB,
        not: 0x00AC,
        shy: 0x00AD,
        reg: 0x00AE,
        macr: 0x00AF,
        deg: 0x00B0,
        plusmn: 0x00B1,
        sup2: 0x00B2,
        sup3: 0x00B3,
        acute: 0x00B4,
        micro: 0x00B5,
        para: 0x00B6,
        middot: 0x00B7,
        cedil: 0x00B8,
        sup1: 0x00B9,
        ordm: 0x00BA,
        raquo: 0x00BB,
        frac14: 0x00BC,
        frac12: 0x00BD,
        frac34: 0x00BE,
        iquest: 0x00BF,
        Agrave: 0x00C0,
        Aacute: 0x00C1,
        Acirc: 0x00C2,
        Atilde: 0x00C3,
        Auml: 0x00C4,
        Aring: 0x00C5,
        AElig: 0x00C6,
        Ccedil: 0x00C7,
        Egrave: 0x00C8,
        Eacute: 0x00C9,
        Ecirc: 0x00CA,
        Euml: 0x00CB,
        Igrave: 0x00CC,
        Iacute: 0x00CD,
        Icirc: 0x00CE,
        Iuml: 0x00CF,
        ETH: 0x00D0,
        Ntilde: 0x00D1,
        Ograve: 0x00D2,
        Oacute: 0x00D3,
        Ocirc: 0x00D4,
        Otilde: 0x00D5,
        Ouml: 0x00D6,
        times: 0x00D7,
        Oslash: 0x00D8,
        Ugrave: 0x00D9,
        Uacute: 0x00DA,
        Ucirc: 0x00DB,
        Uuml: 0x00DC,
        Yacute: 0x00DD,
        THORN: 0x00DE,
        szlig: 0x00DF,
        agrave: 0x00E0,
        aacute: 0x00E1,
        acirc: 0x00E2,
        atilde: 0x00E3,
        auml: 0x00E4,
        aring: 0x00E5,
        aelig: 0x00E6,
        ccedil: 0x00E7,
        egrave: 0x00E8,
        eacute: 0x00E9,
        ecirc: 0x00EA,
        euml: 0x00EB,
        igrave: 0x00EC,
        iacute: 0x00ED,
        icirc: 0x00EE,
        iuml: 0x00EF,
        eth: 0x00F0,
        ntilde: 0x00F1,
        ograve: 0x00F2,
        oacute: 0x00F3,
        ocirc: 0x00F4,
        otilde: 0x00F5,
        ouml: 0x00F6,
        divide: 0x00F7,
        oslash: 0x00F8,
        ugrave: 0x00F9,
        uacute: 0x00FA,
        ucirc: 0x00FB,
        uuml: 0x00FC,
        yacute: 0x00FD,
        thorn: 0x00FE,
        yuml: 0x00FF,
        OElig: 0x0152,
        oelig: 0x0153,
        Scaron: 0x0160,
        scaron: 0x0161,
        Yuml: 0x0178,
        fnof: 0x0192,
        circ: 0x02C6,
        tilde: 0x02DC,
        Alpha: 0x0391,
        Beta: 0x0392,
        Gamma: 0x0393,
        Delta: 0x0394,
        Epsilon: 0x0395,
        Zeta: 0x0396,
        Eta: 0x0397,
        Theta: 0x0398,
        Iota: 0x0399,
        Kappa: 0x039A,
        Lambda: 0x039B,
        Mu: 0x039C,
        Nu: 0x039D,
        Xi: 0x039E,
        Omicron: 0x039F,
        Pi: 0x03A0,
        Rho: 0x03A1,
        Sigma: 0x03A3,
        Tau: 0x03A4,
        Upsilon: 0x03A5,
        Phi: 0x03A6,
        Chi: 0x03A7,
        Psi: 0x03A8,
        Omega: 0x03A9,
        alpha: 0x03B1,
        beta: 0x03B2,
        gamma: 0x03B3,
        delta: 0x03B4,
        epsilon: 0x03B5,
        zeta: 0x03B6,
        eta: 0x03B7,
        theta: 0x03B8,
        iota: 0x03B9,
        kappa: 0x03BA,
        lambda: 0x03BB,
        mu: 0x03BC,
        nu: 0x03BD,
        xi: 0x03BE,
        omicron: 0x03BF,
        pi: 0x03C0,
        rho: 0x03C1,
        sigmaf: 0x03C2,
        sigma: 0x03C3,
        tau: 0x03C4,
        upsilon: 0x03C5,
        phi: 0x03C6,
        chi: 0x03C7,
        psi: 0x03C8,
        omega: 0x03C9,
        thetasym: 0x03D1,
        upsih: 0x03D2,
        piv: 0x03D6,
        ensp: 0x2002,
        emsp: 0x2003,
        thinsp: 0x2009,
        zwnj: 0x200C,
        zwj: 0x200D,
        lrm: 0x200E,
        rlm: 0x200F,
        ndash: 0x2013,
        mdash: 0x2014,
        lsquo: 0x2018,
        rsquo: 0x2019,
        sbquo: 0x201A,
        ldquo: 0x201C,
        rdquo: 0x201D,
        bdquo: 0x201E,
        dagger: 0x2020,
        Dagger: 0x2021,
        bull: 0x2022,
        hellip: 0x2026,
        permil: 0x2030,
        prime: 0x2032,
        Prime: 0x2033,
        lsaquo: 0x2039,
        rsaquo: 0x203A,
        oline: 0x203E,
        frasl: 0x2044,
        euro: 0x20AC,
        image: 0x2111,
        weierp: 0x2118,
        real: 0x211C,
        trade: 0x2122,
        alefsym: 0x2135,
        larr: 0x2190,
        uarr: 0x2191,
        rarr: 0x2192,
        darr: 0x2193,
        harr: 0x2194,
        crarr: 0x21B5,
        lArr: 0x21D0,
        uArr: 0x21D1,
        rArr: 0x21D2,
        dArr: 0x21D3,
        hArr: 0x21D4,
        forall: 0x2200,
        part: 0x2202,
        exist: 0x2203,
        empty: 0x2205,
        nabla: 0x2207,
        isin: 0x2208,
        notin: 0x2209,
        ni: 0x220B,
        prod: 0x220F,
        sum: 0x2211,
        minus: 0x2212,
        lowast: 0x2217,
        radic: 0x221A,
        prop: 0x221D,
        infin: 0x221E,
        ang: 0x2220,
        and: 0x2227,
        or: 0x2228,
        cap: 0x2229,
        cup: 0x222A,
        int: 0x222B,
        there4: 0x2234,
        sim: 0x223C,
        cong: 0x2245,
        asymp: 0x2248,
        ne: 0x2260,
        equiv: 0x2261,
        le: 0x2264,
        ge: 0x2265,
        sub: 0x2282,
        sup: 0x2283,
        nsub: 0x2284,
        sube: 0x2286,
        supe: 0x2287,
        oplus: 0x2295,
        otimes: 0x2297,
        perp: 0x22A5,
        sdot: 0x22C5,
        lceil: 0x2308,
        rceil: 0x2309,
        lfloor: 0x230A,
        rfloor: 0x230B,
        lang: 0x2329,
        rang: 0x232A,
        loz: 0x25CA,
        spades: 0x2660,
        clubs: 0x2663,
        hearts: 0x2665,
        diams: 0x2666
    }));
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformES2016(context) {
        var factory = context.factory, hoistVariableDeclaration = context.hoistVariableDeclaration;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 512) === 0) {
                return node;
            }
            switch (node.kind) {
                case 223:
                    return visitBinaryExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitBinaryExpression(node) {
            switch (node.operatorToken.kind) {
                case 67:
                    return visitExponentiationAssignmentExpression(node);
                case 42:
                    return visitExponentiationExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitExponentiationAssignmentExpression(node) {
            var target;
            var value;
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = ts.visitNode(node.right, visitor, ts.isExpression);
            if (ts.isElementAccessExpression(left)) {
                var expressionTemp = factory.createTempVariable(hoistVariableDeclaration);
                var argumentExpressionTemp = factory.createTempVariable(hoistVariableDeclaration);
                target = ts.setTextRange(factory.createElementAccessExpression(ts.setTextRange(factory.createAssignment(expressionTemp, left.expression), left.expression), ts.setTextRange(factory.createAssignment(argumentExpressionTemp, left.argumentExpression), left.argumentExpression)), left);
                value = ts.setTextRange(factory.createElementAccessExpression(expressionTemp, argumentExpressionTemp), left);
            }
            else if (ts.isPropertyAccessExpression(left)) {
                var expressionTemp = factory.createTempVariable(hoistVariableDeclaration);
                target = ts.setTextRange(factory.createPropertyAccessExpression(ts.setTextRange(factory.createAssignment(expressionTemp, left.expression), left.expression), left.name), left);
                value = ts.setTextRange(factory.createPropertyAccessExpression(expressionTemp, left.name), left);
            }
            else {
                target = left;
                value = left;
            }
            return ts.setTextRange(factory.createAssignment(target, ts.setTextRange(factory.createGlobalMethodCall("Math", "pow", [value, right]), node)), node);
        }
        function visitExponentiationExpression(node) {
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = ts.visitNode(node.right, visitor, ts.isExpression);
            return ts.setTextRange(factory.createGlobalMethodCall("Math", "pow", [left, right]), node);
        }
    }
    ts.transformES2016 = transformES2016;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function createSpreadSegment(kind, expression) {
        return { kind: kind, expression: expression };
    }
    function transformES2015(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var compilerOptions = context.getCompilerOptions();
        var resolver = context.getEmitResolver();
        var previousOnSubstituteNode = context.onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        var currentSourceFile;
        var currentText;
        var hierarchyFacts;
        var taggedTemplateStringDeclarations;
        function recordTaggedTemplateString(temp) {
            taggedTemplateStringDeclarations = ts.append(taggedTemplateStringDeclarations, factory.createVariableDeclaration(temp));
        }
        var convertedLoopState;
        var enabledSubstitutions;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            currentText = node.text;
            var visited = visitSourceFile(node);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            currentText = undefined;
            taggedTemplateStringDeclarations = undefined;
            hierarchyFacts = 0;
            return visited;
        }
        function enterSubtree(excludeFacts, includeFacts) {
            var ancestorFacts = hierarchyFacts;
            hierarchyFacts = (hierarchyFacts & ~excludeFacts | includeFacts) & 32767;
            return ancestorFacts;
        }
        function exitSubtree(ancestorFacts, excludeFacts, includeFacts) {
            hierarchyFacts = (hierarchyFacts & ~excludeFacts | includeFacts) & -32768 | ancestorFacts;
        }
        function isReturnVoidStatementInConstructorWithCapturedSuper(node) {
            return (hierarchyFacts & 8192) !== 0
                && node.kind === 250
                && !node.expression;
        }
        function isOrMayContainReturnCompletion(node) {
            return node.transformFlags & 4194304
                && (ts.isReturnStatement(node)
                    || ts.isIfStatement(node)
                    || ts.isWithStatement(node)
                    || ts.isSwitchStatement(node)
                    || ts.isCaseBlock(node)
                    || ts.isCaseClause(node)
                    || ts.isDefaultClause(node)
                    || ts.isTryStatement(node)
                    || ts.isCatchClause(node)
                    || ts.isLabeledStatement(node)
                    || ts.isIterationStatement(node, false)
                    || ts.isBlock(node));
        }
        function shouldVisitNode(node) {
            return (node.transformFlags & 1024) !== 0
                || convertedLoopState !== undefined
                || (hierarchyFacts & 8192 && isOrMayContainReturnCompletion(node))
                || (ts.isIterationStatement(node, false) && shouldConvertIterationStatement(node))
                || (ts.getEmitFlags(node) & 33554432) !== 0;
        }
        function visitor(node) {
            return shouldVisitNode(node) ? visitorWorker(node, false) : node;
        }
        function visitorWithUnusedExpressionResult(node) {
            return shouldVisitNode(node) ? visitorWorker(node, true) : node;
        }
        function classWrapperStatementVisitor(node) {
            if (shouldVisitNode(node)) {
                var original = ts.getOriginalNode(node);
                if (ts.isPropertyDeclaration(original) && ts.hasStaticModifier(original)) {
                    var ancestorFacts = enterSubtree(32670, 16449);
                    var result = visitorWorker(node, false);
                    exitSubtree(ancestorFacts, 98304, 0);
                    return result;
                }
                return visitorWorker(node, false);
            }
            return node;
        }
        function callExpressionVisitor(node) {
            if (node.kind === 106) {
                return visitSuperKeyword(true);
            }
            return visitor(node);
        }
        function visitorWorker(node, expressionResultIsUnused) {
            switch (node.kind) {
                case 124:
                    return undefined;
                case 260:
                    return visitClassDeclaration(node);
                case 228:
                    return visitClassExpression(node);
                case 166:
                    return visitParameter(node);
                case 259:
                    return visitFunctionDeclaration(node);
                case 216:
                    return visitArrowFunction(node);
                case 215:
                    return visitFunctionExpression(node);
                case 257:
                    return visitVariableDeclaration(node);
                case 79:
                    return visitIdentifier(node);
                case 258:
                    return visitVariableDeclarationList(node);
                case 252:
                    return visitSwitchStatement(node);
                case 266:
                    return visitCaseBlock(node);
                case 238:
                    return visitBlock(node, false);
                case 249:
                case 248:
                    return visitBreakOrContinueStatement(node);
                case 253:
                    return visitLabeledStatement(node);
                case 243:
                case 244:
                    return visitDoOrWhileStatement(node, undefined);
                case 245:
                    return visitForStatement(node, undefined);
                case 246:
                    return visitForInStatement(node, undefined);
                case 247:
                    return visitForOfStatement(node, undefined);
                case 241:
                    return visitExpressionStatement(node);
                case 207:
                    return visitObjectLiteralExpression(node);
                case 295:
                    return visitCatchClause(node);
                case 300:
                    return visitShorthandPropertyAssignment(node);
                case 164:
                    return visitComputedPropertyName(node);
                case 206:
                    return visitArrayLiteralExpression(node);
                case 210:
                    return visitCallExpression(node);
                case 211:
                    return visitNewExpression(node);
                case 214:
                    return visitParenthesizedExpression(node, expressionResultIsUnused);
                case 223:
                    return visitBinaryExpression(node, expressionResultIsUnused);
                case 354:
                    return visitCommaListExpression(node, expressionResultIsUnused);
                case 14:
                case 15:
                case 16:
                case 17:
                    return visitTemplateLiteral(node);
                case 10:
                    return visitStringLiteral(node);
                case 8:
                    return visitNumericLiteral(node);
                case 212:
                    return visitTaggedTemplateExpression(node);
                case 225:
                    return visitTemplateExpression(node);
                case 226:
                    return visitYieldExpression(node);
                case 227:
                    return visitSpreadElement(node);
                case 106:
                    return visitSuperKeyword(false);
                case 108:
                    return visitThisKeyword(node);
                case 233:
                    return visitMetaProperty(node);
                case 171:
                    return visitMethodDeclaration(node);
                case 174:
                case 175:
                    return visitAccessorDeclaration(node);
                case 240:
                    return visitVariableStatement(node);
                case 250:
                    return visitReturnStatement(node);
                case 219:
                    return visitVoidExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitSourceFile(node) {
            var ancestorFacts = enterSubtree(8064, 64);
            var prologue = [];
            var statements = [];
            startLexicalEnvironment();
            var statementOffset = factory.copyPrologue(node.statements, prologue, false, visitor);
            ts.addRange(statements, ts.visitNodes(node.statements, visitor, ts.isStatement, statementOffset));
            if (taggedTemplateStringDeclarations) {
                statements.push(factory.createVariableStatement(undefined, factory.createVariableDeclarationList(taggedTemplateStringDeclarations)));
            }
            factory.mergeLexicalEnvironment(prologue, endLexicalEnvironment());
            insertCaptureThisForNodeIfNeeded(prologue, node);
            exitSubtree(ancestorFacts, 0, 0);
            return factory.updateSourceFile(node, ts.setTextRange(factory.createNodeArray(ts.concatenate(prologue, statements)), node.statements));
        }
        function visitSwitchStatement(node) {
            if (convertedLoopState !== undefined) {
                var savedAllowedNonLabeledJumps = convertedLoopState.allowedNonLabeledJumps;
                convertedLoopState.allowedNonLabeledJumps |= 2;
                var result = ts.visitEachChild(node, visitor, context);
                convertedLoopState.allowedNonLabeledJumps = savedAllowedNonLabeledJumps;
                return result;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCaseBlock(node) {
            var ancestorFacts = enterSubtree(7104, 0);
            var updated = ts.visitEachChild(node, visitor, context);
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function returnCapturedThis(node) {
            return ts.setOriginalNode(factory.createReturnStatement(factory.createUniqueName("_this", 16 | 32)), node);
        }
        function visitReturnStatement(node) {
            if (convertedLoopState) {
                convertedLoopState.nonLocalJumps |= 8;
                if (isReturnVoidStatementInConstructorWithCapturedSuper(node)) {
                    node = returnCapturedThis(node);
                }
                return factory.createReturnStatement(factory.createObjectLiteralExpression([
                    factory.createPropertyAssignment(factory.createIdentifier("value"), node.expression
                        ? ts.visitNode(node.expression, visitor, ts.isExpression)
                        : factory.createVoidZero())
                ]));
            }
            else if (isReturnVoidStatementInConstructorWithCapturedSuper(node)) {
                return returnCapturedThis(node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitThisKeyword(node) {
            if (hierarchyFacts & 2 && !(hierarchyFacts & 16384)) {
                hierarchyFacts |= 65536;
            }
            if (convertedLoopState) {
                if (hierarchyFacts & 2) {
                    convertedLoopState.containsLexicalThis = true;
                    return node;
                }
                return convertedLoopState.thisName || (convertedLoopState.thisName = factory.createUniqueName("this"));
            }
            return node;
        }
        function visitVoidExpression(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        function visitIdentifier(node) {
            if (convertedLoopState) {
                if (resolver.isArgumentsLocalBinding(node)) {
                    return convertedLoopState.argumentsName || (convertedLoopState.argumentsName = factory.createUniqueName("arguments"));
                }
            }
            if (node.hasExtendedUnicodeEscape) {
                return ts.setOriginalNode(ts.setTextRange(factory.createIdentifier(ts.unescapeLeadingUnderscores(node.escapedText)), node), node);
            }
            return node;
        }
        function visitBreakOrContinueStatement(node) {
            if (convertedLoopState) {
                var jump = node.kind === 249 ? 2 : 4;
                var canUseBreakOrContinue = (node.label && convertedLoopState.labels && convertedLoopState.labels.get(ts.idText(node.label))) ||
                    (!node.label && (convertedLoopState.allowedNonLabeledJumps & jump));
                if (!canUseBreakOrContinue) {
                    var labelMarker = void 0;
                    var label = node.label;
                    if (!label) {
                        if (node.kind === 249) {
                            convertedLoopState.nonLocalJumps |= 2;
                            labelMarker = "break";
                        }
                        else {
                            convertedLoopState.nonLocalJumps |= 4;
                            labelMarker = "continue";
                        }
                    }
                    else {
                        if (node.kind === 249) {
                            labelMarker = "break-".concat(label.escapedText);
                            setLabeledJump(convertedLoopState, true, ts.idText(label), labelMarker);
                        }
                        else {
                            labelMarker = "continue-".concat(label.escapedText);
                            setLabeledJump(convertedLoopState, false, ts.idText(label), labelMarker);
                        }
                    }
                    var returnExpression = factory.createStringLiteral(labelMarker);
                    if (convertedLoopState.loopOutParameters.length) {
                        var outParams = convertedLoopState.loopOutParameters;
                        var expr = void 0;
                        for (var i = 0; i < outParams.length; i++) {
                            var copyExpr = copyOutParameter(outParams[i], 1);
                            if (i === 0) {
                                expr = copyExpr;
                            }
                            else {
                                expr = factory.createBinaryExpression(expr, 27, copyExpr);
                            }
                        }
                        returnExpression = factory.createBinaryExpression(expr, 27, returnExpression);
                    }
                    return factory.createReturnStatement(returnExpression);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitClassDeclaration(node) {
            var variable = factory.createVariableDeclaration(factory.getLocalName(node, true), undefined, undefined, transformClassLikeDeclarationToExpression(node));
            ts.setOriginalNode(variable, node);
            var statements = [];
            var statement = factory.createVariableStatement(undefined, factory.createVariableDeclarationList([variable]));
            ts.setOriginalNode(statement, node);
            ts.setTextRange(statement, node);
            ts.startOnNewLine(statement);
            statements.push(statement);
            if (ts.hasSyntacticModifier(node, 1)) {
                var exportStatement = ts.hasSyntacticModifier(node, 1024)
                    ? factory.createExportDefault(factory.getLocalName(node))
                    : factory.createExternalModuleExport(factory.getLocalName(node));
                ts.setOriginalNode(exportStatement, statement);
                statements.push(exportStatement);
            }
            var emitFlags = ts.getEmitFlags(node);
            if ((emitFlags & 4194304) === 0) {
                statements.push(factory.createEndOfDeclarationMarker(node));
                ts.setEmitFlags(statement, emitFlags | 4194304);
            }
            return ts.singleOrMany(statements);
        }
        function visitClassExpression(node) {
            return transformClassLikeDeclarationToExpression(node);
        }
        function transformClassLikeDeclarationToExpression(node) {
            if (node.name) {
                enableSubstitutionsForBlockScopedBindings();
            }
            var extendsClauseElement = ts.getClassExtendsHeritageElement(node);
            var classFunction = factory.createFunctionExpression(undefined, undefined, undefined, undefined, extendsClauseElement ? [factory.createParameterDeclaration(undefined, undefined, factory.createUniqueName("_super", 16 | 32))] : [], undefined, transformClassBody(node, extendsClauseElement));
            ts.setEmitFlags(classFunction, (ts.getEmitFlags(node) & 65536) | 524288);
            var inner = factory.createPartiallyEmittedExpression(classFunction);
            ts.setTextRangeEnd(inner, node.end);
            ts.setEmitFlags(inner, 1536);
            var outer = factory.createPartiallyEmittedExpression(inner);
            ts.setTextRangeEnd(outer, ts.skipTrivia(currentText, node.pos));
            ts.setEmitFlags(outer, 1536);
            var result = factory.createParenthesizedExpression(factory.createCallExpression(outer, undefined, extendsClauseElement
                ? [ts.visitNode(extendsClauseElement.expression, visitor, ts.isExpression)]
                : []));
            ts.addSyntheticLeadingComment(result, 3, "* @class ");
            return result;
        }
        function transformClassBody(node, extendsClauseElement) {
            var statements = [];
            var name = factory.getInternalName(node);
            var constructorLikeName = ts.isIdentifierANonContextualKeyword(name) ? factory.getGeneratedNameForNode(name) : name;
            startLexicalEnvironment();
            addExtendsHelperIfNeeded(statements, node, extendsClauseElement);
            addConstructor(statements, node, constructorLikeName, extendsClauseElement);
            addClassMembers(statements, node);
            var closingBraceLocation = ts.createTokenRange(ts.skipTrivia(currentText, node.members.end), 19);
            var outer = factory.createPartiallyEmittedExpression(constructorLikeName);
            ts.setTextRangeEnd(outer, closingBraceLocation.end);
            ts.setEmitFlags(outer, 1536);
            var statement = factory.createReturnStatement(outer);
            ts.setTextRangePos(statement, closingBraceLocation.pos);
            ts.setEmitFlags(statement, 1536 | 384);
            statements.push(statement);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var block = factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), node.members), true);
            ts.setEmitFlags(block, 1536);
            return block;
        }
        function addExtendsHelperIfNeeded(statements, node, extendsClauseElement) {
            if (extendsClauseElement) {
                statements.push(ts.setTextRange(factory.createExpressionStatement(emitHelpers().createExtendsHelper(factory.getInternalName(node))), extendsClauseElement));
            }
        }
        function addConstructor(statements, node, name, extendsClauseElement) {
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(32662, 73);
            var constructor = ts.getFirstConstructorWithBody(node);
            var hasSynthesizedSuper = hasSynthesizedDefaultSuperCall(constructor, extendsClauseElement !== undefined);
            var constructorFunction = factory.createFunctionDeclaration(undefined, undefined, name, undefined, transformConstructorParameters(constructor, hasSynthesizedSuper), undefined, transformConstructorBody(constructor, node, extendsClauseElement, hasSynthesizedSuper));
            ts.setTextRange(constructorFunction, constructor || node);
            if (extendsClauseElement) {
                ts.setEmitFlags(constructorFunction, 8);
            }
            statements.push(constructorFunction);
            exitSubtree(ancestorFacts, 98304, 0);
            convertedLoopState = savedConvertedLoopState;
        }
        function transformConstructorParameters(constructor, hasSynthesizedSuper) {
            return ts.visitParameterList(constructor && !hasSynthesizedSuper ? constructor.parameters : undefined, visitor, context)
                || [];
        }
        function createDefaultConstructorBody(node, isDerivedClass) {
            var statements = [];
            resumeLexicalEnvironment();
            factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
            if (isDerivedClass) {
                statements.push(factory.createReturnStatement(createDefaultSuperCallOrThis()));
            }
            var statementsArray = factory.createNodeArray(statements);
            ts.setTextRange(statementsArray, node.members);
            var block = factory.createBlock(statementsArray, true);
            ts.setTextRange(block, node);
            ts.setEmitFlags(block, 1536);
            return block;
        }
        function transformConstructorBody(constructor, node, extendsClauseElement, hasSynthesizedSuper) {
            var isDerivedClass = !!extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 104;
            if (!constructor)
                return createDefaultConstructorBody(node, isDerivedClass);
            var prologue = [];
            var statements = [];
            resumeLexicalEnvironment();
            var existingPrologue = ts.takeWhile(constructor.body.statements, ts.isPrologueDirective);
            var _a = findSuperCallAndStatementIndex(constructor.body.statements, existingPrologue), superCall = _a.superCall, superStatementIndex = _a.superStatementIndex;
            var postSuperStatementsStart = superStatementIndex === -1 ? existingPrologue.length : superStatementIndex + 1;
            var statementOffset = postSuperStatementsStart;
            if (!hasSynthesizedSuper)
                statementOffset = factory.copyStandardPrologue(constructor.body.statements, prologue, statementOffset, false);
            if (!hasSynthesizedSuper)
                statementOffset = factory.copyCustomPrologue(constructor.body.statements, statements, statementOffset, visitor, undefined);
            var superCallExpression;
            if (hasSynthesizedSuper) {
                superCallExpression = createDefaultSuperCallOrThis();
            }
            else if (superCall) {
                superCallExpression = visitSuperCallInBody(superCall);
            }
            if (superCallExpression) {
                hierarchyFacts |= 8192;
            }
            addDefaultValueAssignmentsIfNeeded(prologue, constructor);
            addRestParameterIfNeeded(prologue, constructor, hasSynthesizedSuper);
            ts.addRange(statements, ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, statementOffset));
            factory.mergeLexicalEnvironment(prologue, endLexicalEnvironment());
            insertCaptureNewTargetIfNeeded(prologue, constructor, false);
            if (isDerivedClass || superCallExpression) {
                if (superCallExpression && postSuperStatementsStart === constructor.body.statements.length && !(constructor.body.transformFlags & 16384)) {
                    var superCall_1 = ts.cast(ts.cast(superCallExpression, ts.isBinaryExpression).left, ts.isCallExpression);
                    var returnStatement = factory.createReturnStatement(superCallExpression);
                    ts.setCommentRange(returnStatement, ts.getCommentRange(superCall_1));
                    ts.setEmitFlags(superCall_1, 1536);
                    statements.push(returnStatement);
                }
                else {
                    if (superStatementIndex <= existingPrologue.length) {
                        insertCaptureThisForNode(statements, constructor, superCallExpression || createActualThis());
                    }
                    else {
                        insertCaptureThisForNode(prologue, constructor, createActualThis());
                        if (superCallExpression) {
                            insertSuperThisCaptureThisForNode(statements, superCallExpression);
                        }
                    }
                    if (!isSufficientlyCoveredByReturnStatements(constructor.body)) {
                        statements.push(factory.createReturnStatement(factory.createUniqueName("_this", 16 | 32)));
                    }
                }
            }
            else {
                insertCaptureThisForNodeIfNeeded(prologue, constructor);
            }
            var body = factory.createBlock(ts.setTextRange(factory.createNodeArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], existingPrologue, true), prologue, true), (superStatementIndex <= existingPrologue.length ? ts.emptyArray : ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, existingPrologue.length, superStatementIndex - existingPrologue.length)), true), statements, true)), constructor.body.statements), true);
            ts.setTextRange(body, constructor.body);
            return body;
        }
        function findSuperCallAndStatementIndex(originalBodyStatements, existingPrologue) {
            for (var i = existingPrologue.length; i < originalBodyStatements.length; i += 1) {
                var superCall = ts.getSuperCallFromStatement(originalBodyStatements[i]);
                if (superCall) {
                    return {
                        superCall: superCall,
                        superStatementIndex: i,
                    };
                }
            }
            return {
                superStatementIndex: -1,
            };
        }
        function isSufficientlyCoveredByReturnStatements(statement) {
            if (statement.kind === 250) {
                return true;
            }
            else if (statement.kind === 242) {
                var ifStatement = statement;
                if (ifStatement.elseStatement) {
                    return isSufficientlyCoveredByReturnStatements(ifStatement.thenStatement) &&
                        isSufficientlyCoveredByReturnStatements(ifStatement.elseStatement);
                }
            }
            else if (statement.kind === 238) {
                var lastStatement = ts.lastOrUndefined(statement.statements);
                if (lastStatement && isSufficientlyCoveredByReturnStatements(lastStatement)) {
                    return true;
                }
            }
            return false;
        }
        function createActualThis() {
            return ts.setEmitFlags(factory.createThis(), 4);
        }
        function createDefaultSuperCallOrThis() {
            return factory.createLogicalOr(factory.createLogicalAnd(factory.createStrictInequality(factory.createUniqueName("_super", 16 | 32), factory.createNull()), factory.createFunctionApplyCall(factory.createUniqueName("_super", 16 | 32), createActualThis(), factory.createIdentifier("arguments"))), createActualThis());
        }
        function visitParameter(node) {
            if (node.dotDotDotToken) {
                return undefined;
            }
            else if (ts.isBindingPattern(node.name)) {
                return ts.setOriginalNode(ts.setTextRange(factory.createParameterDeclaration(undefined, undefined, factory.getGeneratedNameForNode(node), undefined, undefined, undefined), node), node);
            }
            else if (node.initializer) {
                return ts.setOriginalNode(ts.setTextRange(factory.createParameterDeclaration(undefined, undefined, node.name, undefined, undefined, undefined), node), node);
            }
            else {
                return node;
            }
        }
        function hasDefaultValueOrBindingPattern(node) {
            return node.initializer !== undefined
                || ts.isBindingPattern(node.name);
        }
        function addDefaultValueAssignmentsIfNeeded(statements, node) {
            if (!ts.some(node.parameters, hasDefaultValueOrBindingPattern)) {
                return false;
            }
            var added = false;
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                var name = parameter.name, initializer = parameter.initializer, dotDotDotToken = parameter.dotDotDotToken;
                if (dotDotDotToken) {
                    continue;
                }
                if (ts.isBindingPattern(name)) {
                    added = insertDefaultValueAssignmentForBindingPattern(statements, parameter, name, initializer) || added;
                }
                else if (initializer) {
                    insertDefaultValueAssignmentForInitializer(statements, parameter, name, initializer);
                    added = true;
                }
            }
            return added;
        }
        function insertDefaultValueAssignmentForBindingPattern(statements, parameter, name, initializer) {
            if (name.elements.length > 0) {
                ts.insertStatementAfterCustomPrologue(statements, ts.setEmitFlags(factory.createVariableStatement(undefined, factory.createVariableDeclarationList(ts.flattenDestructuringBinding(parameter, visitor, context, 0, factory.getGeneratedNameForNode(parameter)))), 1048576));
                return true;
            }
            else if (initializer) {
                ts.insertStatementAfterCustomPrologue(statements, ts.setEmitFlags(factory.createExpressionStatement(factory.createAssignment(factory.getGeneratedNameForNode(parameter), ts.visitNode(initializer, visitor, ts.isExpression))), 1048576));
                return true;
            }
            return false;
        }
        function insertDefaultValueAssignmentForInitializer(statements, parameter, name, initializer) {
            initializer = ts.visitNode(initializer, visitor, ts.isExpression);
            var statement = factory.createIfStatement(factory.createTypeCheck(factory.cloneNode(name), "undefined"), ts.setEmitFlags(ts.setTextRange(factory.createBlock([
                factory.createExpressionStatement(ts.setEmitFlags(ts.setTextRange(factory.createAssignment(ts.setEmitFlags(ts.setParent(ts.setTextRange(factory.cloneNode(name), name), name.parent), 48), ts.setEmitFlags(initializer, 48 | ts.getEmitFlags(initializer) | 1536)), parameter), 1536))
            ]), parameter), 1 | 32 | 384 | 1536));
            ts.startOnNewLine(statement);
            ts.setTextRange(statement, parameter);
            ts.setEmitFlags(statement, 384 | 32 | 1048576 | 1536);
            ts.insertStatementAfterCustomPrologue(statements, statement);
        }
        function shouldAddRestParameter(node, inConstructorWithSynthesizedSuper) {
            return !!(node && node.dotDotDotToken && !inConstructorWithSynthesizedSuper);
        }
        function addRestParameterIfNeeded(statements, node, inConstructorWithSynthesizedSuper) {
            var prologueStatements = [];
            var parameter = ts.lastOrUndefined(node.parameters);
            if (!shouldAddRestParameter(parameter, inConstructorWithSynthesizedSuper)) {
                return false;
            }
            var declarationName = parameter.name.kind === 79 ? ts.setParent(ts.setTextRange(factory.cloneNode(parameter.name), parameter.name), parameter.name.parent) : factory.createTempVariable(undefined);
            ts.setEmitFlags(declarationName, 48);
            var expressionName = parameter.name.kind === 79 ? factory.cloneNode(parameter.name) : declarationName;
            var restIndex = node.parameters.length - 1;
            var temp = factory.createLoopVariable();
            prologueStatements.push(ts.setEmitFlags(ts.setTextRange(factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration(declarationName, undefined, undefined, factory.createArrayLiteralExpression([]))
            ])), parameter), 1048576));
            var forStatement = factory.createForStatement(ts.setTextRange(factory.createVariableDeclarationList([
                factory.createVariableDeclaration(temp, undefined, undefined, factory.createNumericLiteral(restIndex))
            ]), parameter), ts.setTextRange(factory.createLessThan(temp, factory.createPropertyAccessExpression(factory.createIdentifier("arguments"), "length")), parameter), ts.setTextRange(factory.createPostfixIncrement(temp), parameter), factory.createBlock([
                ts.startOnNewLine(ts.setTextRange(factory.createExpressionStatement(factory.createAssignment(factory.createElementAccessExpression(expressionName, restIndex === 0
                    ? temp
                    : factory.createSubtract(temp, factory.createNumericLiteral(restIndex))), factory.createElementAccessExpression(factory.createIdentifier("arguments"), temp))), parameter))
            ]));
            ts.setEmitFlags(forStatement, 1048576);
            ts.startOnNewLine(forStatement);
            prologueStatements.push(forStatement);
            if (parameter.name.kind !== 79) {
                prologueStatements.push(ts.setEmitFlags(ts.setTextRange(factory.createVariableStatement(undefined, factory.createVariableDeclarationList(ts.flattenDestructuringBinding(parameter, visitor, context, 0, expressionName))), parameter), 1048576));
            }
            ts.insertStatementsAfterCustomPrologue(statements, prologueStatements);
            return true;
        }
        function insertCaptureThisForNodeIfNeeded(statements, node) {
            if (hierarchyFacts & 65536 && node.kind !== 216) {
                insertCaptureThisForNode(statements, node, factory.createThis());
                return true;
            }
            return false;
        }
        function insertSuperThisCaptureThisForNode(statements, superExpression) {
            enableSubstitutionsForCapturedThis();
            var assignSuperExpression = factory.createExpressionStatement(factory.createBinaryExpression(factory.createThis(), 63, superExpression));
            ts.insertStatementAfterCustomPrologue(statements, assignSuperExpression);
            ts.setCommentRange(assignSuperExpression, ts.getOriginalNode(superExpression).parent);
        }
        function insertCaptureThisForNode(statements, node, initializer) {
            enableSubstitutionsForCapturedThis();
            var captureThisStatement = factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration(factory.createUniqueName("_this", 16 | 32), undefined, undefined, initializer)
            ]));
            ts.setEmitFlags(captureThisStatement, 1536 | 1048576);
            ts.setSourceMapRange(captureThisStatement, node);
            ts.insertStatementAfterCustomPrologue(statements, captureThisStatement);
        }
        function insertCaptureNewTargetIfNeeded(statements, node, copyOnWrite) {
            if (hierarchyFacts & 32768) {
                var newTarget = void 0;
                switch (node.kind) {
                    case 216:
                        return statements;
                    case 171:
                    case 174:
                    case 175:
                        newTarget = factory.createVoidZero();
                        break;
                    case 173:
                        newTarget = factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createThis(), 4), "constructor");
                        break;
                    case 259:
                    case 215:
                        newTarget = factory.createConditionalExpression(factory.createLogicalAnd(ts.setEmitFlags(factory.createThis(), 4), factory.createBinaryExpression(ts.setEmitFlags(factory.createThis(), 4), 102, factory.getLocalName(node))), undefined, factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createThis(), 4), "constructor"), undefined, factory.createVoidZero());
                        break;
                    default:
                        return ts.Debug.failBadSyntaxKind(node);
                }
                var captureNewTargetStatement = factory.createVariableStatement(undefined, factory.createVariableDeclarationList([
                    factory.createVariableDeclaration(factory.createUniqueName("_newTarget", 16 | 32), undefined, undefined, newTarget)
                ]));
                ts.setEmitFlags(captureNewTargetStatement, 1536 | 1048576);
                if (copyOnWrite) {
                    statements = statements.slice();
                }
                ts.insertStatementAfterCustomPrologue(statements, captureNewTargetStatement);
            }
            return statements;
        }
        function addClassMembers(statements, node) {
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                switch (member.kind) {
                    case 237:
                        statements.push(transformSemicolonClassElementToStatement(member));
                        break;
                    case 171:
                        statements.push(transformClassMethodDeclarationToStatement(getClassMemberPrefix(node, member), member, node));
                        break;
                    case 174:
                    case 175:
                        var accessors = ts.getAllAccessorDeclarations(node.members, member);
                        if (member === accessors.firstAccessor) {
                            statements.push(transformAccessorsToStatement(getClassMemberPrefix(node, member), accessors, node));
                        }
                        break;
                    case 173:
                    case 172:
                        break;
                    default:
                        ts.Debug.failBadSyntaxKind(member, currentSourceFile && currentSourceFile.fileName);
                        break;
                }
            }
        }
        function transformSemicolonClassElementToStatement(member) {
            return ts.setTextRange(factory.createEmptyStatement(), member);
        }
        function transformClassMethodDeclarationToStatement(receiver, member, container) {
            var commentRange = ts.getCommentRange(member);
            var sourceMapRange = ts.getSourceMapRange(member);
            var memberFunction = transformFunctionLikeToExpression(member, member, undefined, container);
            var propertyName = ts.visitNode(member.name, visitor, ts.isPropertyName);
            var e;
            if (!ts.isPrivateIdentifier(propertyName) && ts.getUseDefineForClassFields(context.getCompilerOptions())) {
                var name = ts.isComputedPropertyName(propertyName) ? propertyName.expression
                    : ts.isIdentifier(propertyName) ? factory.createStringLiteral(ts.unescapeLeadingUnderscores(propertyName.escapedText))
                        : propertyName;
                e = factory.createObjectDefinePropertyCall(receiver, name, factory.createPropertyDescriptor({ value: memberFunction, enumerable: false, writable: true, configurable: true }));
            }
            else {
                var memberName = ts.createMemberAccessForPropertyName(factory, receiver, propertyName, member.name);
                e = factory.createAssignment(memberName, memberFunction);
            }
            ts.setEmitFlags(memberFunction, 1536);
            ts.setSourceMapRange(memberFunction, sourceMapRange);
            var statement = ts.setTextRange(factory.createExpressionStatement(e), member);
            ts.setOriginalNode(statement, member);
            ts.setCommentRange(statement, commentRange);
            ts.setEmitFlags(statement, 48);
            return statement;
        }
        function transformAccessorsToStatement(receiver, accessors, container) {
            var statement = factory.createExpressionStatement(transformAccessorsToExpression(receiver, accessors, container, false));
            ts.setEmitFlags(statement, 1536);
            ts.setSourceMapRange(statement, ts.getSourceMapRange(accessors.firstAccessor));
            return statement;
        }
        function transformAccessorsToExpression(receiver, _a, container, startsOnNewLine) {
            var firstAccessor = _a.firstAccessor, getAccessor = _a.getAccessor, setAccessor = _a.setAccessor;
            var target = ts.setParent(ts.setTextRange(factory.cloneNode(receiver), receiver), receiver.parent);
            ts.setEmitFlags(target, 1536 | 32);
            ts.setSourceMapRange(target, firstAccessor.name);
            var visitedAccessorName = ts.visitNode(firstAccessor.name, visitor, ts.isPropertyName);
            if (ts.isPrivateIdentifier(visitedAccessorName)) {
                return ts.Debug.failBadSyntaxKind(visitedAccessorName, "Encountered unhandled private identifier while transforming ES2015.");
            }
            var propertyName = ts.createExpressionForPropertyName(factory, visitedAccessorName);
            ts.setEmitFlags(propertyName, 1536 | 16);
            ts.setSourceMapRange(propertyName, firstAccessor.name);
            var properties = [];
            if (getAccessor) {
                var getterFunction = transformFunctionLikeToExpression(getAccessor, undefined, undefined, container);
                ts.setSourceMapRange(getterFunction, ts.getSourceMapRange(getAccessor));
                ts.setEmitFlags(getterFunction, 512);
                var getter = factory.createPropertyAssignment("get", getterFunction);
                ts.setCommentRange(getter, ts.getCommentRange(getAccessor));
                properties.push(getter);
            }
            if (setAccessor) {
                var setterFunction = transformFunctionLikeToExpression(setAccessor, undefined, undefined, container);
                ts.setSourceMapRange(setterFunction, ts.getSourceMapRange(setAccessor));
                ts.setEmitFlags(setterFunction, 512);
                var setter = factory.createPropertyAssignment("set", setterFunction);
                ts.setCommentRange(setter, ts.getCommentRange(setAccessor));
                properties.push(setter);
            }
            properties.push(factory.createPropertyAssignment("enumerable", getAccessor || setAccessor ? factory.createFalse() : factory.createTrue()), factory.createPropertyAssignment("configurable", factory.createTrue()));
            var call = factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "defineProperty"), undefined, [
                target,
                propertyName,
                factory.createObjectLiteralExpression(properties, true)
            ]);
            if (startsOnNewLine) {
                ts.startOnNewLine(call);
            }
            return call;
        }
        function visitArrowFunction(node) {
            if (node.transformFlags & 16384 && !(hierarchyFacts & 16384)) {
                hierarchyFacts |= 65536;
            }
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(15232, 66);
            var func = factory.createFunctionExpression(undefined, undefined, undefined, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, transformFunctionBody(node));
            ts.setTextRange(func, node);
            ts.setOriginalNode(func, node);
            ts.setEmitFlags(func, 8);
            exitSubtree(ancestorFacts, 0, 0);
            convertedLoopState = savedConvertedLoopState;
            return func;
        }
        function visitFunctionExpression(node) {
            var ancestorFacts = ts.getEmitFlags(node) & 262144
                ? enterSubtree(32662, 69)
                : enterSubtree(32670, 65);
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var parameters = ts.visitParameterList(node.parameters, visitor, context);
            var body = transformFunctionBody(node);
            var name = hierarchyFacts & 32768
                ? factory.getLocalName(node)
                : node.name;
            exitSubtree(ancestorFacts, 98304, 0);
            convertedLoopState = savedConvertedLoopState;
            return factory.updateFunctionExpression(node, undefined, node.asteriskToken, name, undefined, parameters, undefined, body);
        }
        function visitFunctionDeclaration(node) {
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(32670, 65);
            var parameters = ts.visitParameterList(node.parameters, visitor, context);
            var body = transformFunctionBody(node);
            var name = hierarchyFacts & 32768
                ? factory.getLocalName(node)
                : node.name;
            exitSubtree(ancestorFacts, 98304, 0);
            convertedLoopState = savedConvertedLoopState;
            return factory.updateFunctionDeclaration(node, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, name, undefined, parameters, undefined, body);
        }
        function transformFunctionLikeToExpression(node, location, name, container) {
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = container && ts.isClassLike(container) && !ts.isStatic(node)
                ? enterSubtree(32670, 65 | 8)
                : enterSubtree(32670, 65);
            var parameters = ts.visitParameterList(node.parameters, visitor, context);
            var body = transformFunctionBody(node);
            if (hierarchyFacts & 32768 && !name && (node.kind === 259 || node.kind === 215)) {
                name = factory.getGeneratedNameForNode(node);
            }
            exitSubtree(ancestorFacts, 98304, 0);
            convertedLoopState = savedConvertedLoopState;
            return ts.setOriginalNode(ts.setTextRange(factory.createFunctionExpression(undefined, node.asteriskToken, name, undefined, parameters, undefined, body), location), node);
        }
        function transformFunctionBody(node) {
            var multiLine = false;
            var singleLine = false;
            var statementsLocation;
            var closeBraceLocation;
            var prologue = [];
            var statements = [];
            var body = node.body;
            var statementOffset;
            resumeLexicalEnvironment();
            if (ts.isBlock(body)) {
                statementOffset = factory.copyStandardPrologue(body.statements, prologue, 0, false);
                statementOffset = factory.copyCustomPrologue(body.statements, statements, statementOffset, visitor, ts.isHoistedFunction);
                statementOffset = factory.copyCustomPrologue(body.statements, statements, statementOffset, visitor, ts.isHoistedVariableStatement);
            }
            multiLine = addDefaultValueAssignmentsIfNeeded(statements, node) || multiLine;
            multiLine = addRestParameterIfNeeded(statements, node, false) || multiLine;
            if (ts.isBlock(body)) {
                statementOffset = factory.copyCustomPrologue(body.statements, statements, statementOffset, visitor);
                statementsLocation = body.statements;
                ts.addRange(statements, ts.visitNodes(body.statements, visitor, ts.isStatement, statementOffset));
                if (!multiLine && body.multiLine) {
                    multiLine = true;
                }
            }
            else {
                ts.Debug.assert(node.kind === 216);
                statementsLocation = ts.moveRangeEnd(body, -1);
                var equalsGreaterThanToken = node.equalsGreaterThanToken;
                if (!ts.nodeIsSynthesized(equalsGreaterThanToken) && !ts.nodeIsSynthesized(body)) {
                    if (ts.rangeEndIsOnSameLineAsRangeStart(equalsGreaterThanToken, body, currentSourceFile)) {
                        singleLine = true;
                    }
                    else {
                        multiLine = true;
                    }
                }
                var expression = ts.visitNode(body, visitor, ts.isExpression);
                var returnStatement = factory.createReturnStatement(expression);
                ts.setTextRange(returnStatement, body);
                ts.moveSyntheticComments(returnStatement, body);
                ts.setEmitFlags(returnStatement, 384 | 32 | 1024);
                statements.push(returnStatement);
                closeBraceLocation = body;
            }
            factory.mergeLexicalEnvironment(prologue, endLexicalEnvironment());
            insertCaptureNewTargetIfNeeded(prologue, node, false);
            insertCaptureThisForNodeIfNeeded(prologue, node);
            if (ts.some(prologue)) {
                multiLine = true;
            }
            statements.unshift.apply(statements, prologue);
            if (ts.isBlock(body) && ts.arrayIsEqualTo(statements, body.statements)) {
                return body;
            }
            var block = factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), statementsLocation), multiLine);
            ts.setTextRange(block, node.body);
            if (!multiLine && singleLine) {
                ts.setEmitFlags(block, 1);
            }
            if (closeBraceLocation) {
                ts.setTokenSourceMapRange(block, 19, closeBraceLocation);
            }
            ts.setOriginalNode(block, node.body);
            return block;
        }
        function visitBlock(node, isFunctionBody) {
            if (isFunctionBody) {
                return ts.visitEachChild(node, visitor, context);
            }
            var ancestorFacts = hierarchyFacts & 256
                ? enterSubtree(7104, 512)
                : enterSubtree(6976, 128);
            var updated = ts.visitEachChild(node, visitor, context);
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function visitExpressionStatement(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        function visitParenthesizedExpression(node, expressionResultIsUnused) {
            return ts.visitEachChild(node, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, context);
        }
        function visitBinaryExpression(node, expressionResultIsUnused) {
            if (ts.isDestructuringAssignment(node)) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 0, !expressionResultIsUnused);
            }
            if (node.operatorToken.kind === 27) {
                return factory.updateBinaryExpression(node, ts.visitNode(node.left, visitorWithUnusedExpressionResult, ts.isExpression), node.operatorToken, ts.visitNode(node.right, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCommaListExpression(node, expressionResultIsUnused) {
            if (expressionResultIsUnused) {
                return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
            }
            var result;
            for (var i = 0; i < node.elements.length; i++) {
                var element = node.elements[i];
                var visited = ts.visitNode(element, i < node.elements.length - 1 ? visitorWithUnusedExpressionResult : visitor, ts.isExpression);
                if (result || visited !== element) {
                    result || (result = node.elements.slice(0, i));
                    result.push(visited);
                }
            }
            var elements = result ? ts.setTextRange(factory.createNodeArray(result), node.elements) : node.elements;
            return factory.updateCommaListExpression(node, elements);
        }
        function isVariableStatementOfTypeScriptClassWrapper(node) {
            return node.declarationList.declarations.length === 1
                && !!node.declarationList.declarations[0].initializer
                && !!(ts.getEmitFlags(node.declarationList.declarations[0].initializer) & 33554432);
        }
        function visitVariableStatement(node) {
            var ancestorFacts = enterSubtree(0, ts.hasSyntacticModifier(node, 1) ? 32 : 0);
            var updated;
            if (convertedLoopState && (node.declarationList.flags & 3) === 0 && !isVariableStatementOfTypeScriptClassWrapper(node)) {
                var assignments = void 0;
                for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    hoistVariableDeclarationDeclaredInConvertedLoop(convertedLoopState, decl);
                    if (decl.initializer) {
                        var assignment = void 0;
                        if (ts.isBindingPattern(decl.name)) {
                            assignment = ts.flattenDestructuringAssignment(decl, visitor, context, 0);
                        }
                        else {
                            assignment = factory.createBinaryExpression(decl.name, 63, ts.visitNode(decl.initializer, visitor, ts.isExpression));
                            ts.setTextRange(assignment, decl);
                        }
                        assignments = ts.append(assignments, assignment);
                    }
                }
                if (assignments) {
                    updated = ts.setTextRange(factory.createExpressionStatement(factory.inlineExpressions(assignments)), node);
                }
                else {
                    updated = undefined;
                }
            }
            else {
                updated = ts.visitEachChild(node, visitor, context);
            }
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function visitVariableDeclarationList(node) {
            if (node.flags & 3 || node.transformFlags & 524288) {
                if (node.flags & 3) {
                    enableSubstitutionsForBlockScopedBindings();
                }
                var declarations = ts.flatMap(node.declarations, node.flags & 1
                    ? visitVariableDeclarationInLetDeclarationList
                    : visitVariableDeclaration);
                var declarationList = factory.createVariableDeclarationList(declarations);
                ts.setOriginalNode(declarationList, node);
                ts.setTextRange(declarationList, node);
                ts.setCommentRange(declarationList, node);
                if (node.transformFlags & 524288
                    && (ts.isBindingPattern(node.declarations[0].name) || ts.isBindingPattern(ts.last(node.declarations).name))) {
                    ts.setSourceMapRange(declarationList, getRangeUnion(declarations));
                }
                return declarationList;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function getRangeUnion(declarations) {
            var pos = -1, end = -1;
            for (var _i = 0, declarations_10 = declarations; _i < declarations_10.length; _i++) {
                var node = declarations_10[_i];
                pos = pos === -1 ? node.pos : node.pos === -1 ? pos : Math.min(pos, node.pos);
                end = Math.max(end, node.end);
            }
            return ts.createRange(pos, end);
        }
        function shouldEmitExplicitInitializerForLetDeclaration(node) {
            var flags = resolver.getNodeCheckFlags(node);
            var isCapturedInFunction = flags & 262144;
            var isDeclaredInLoop = flags & 524288;
            var emittedAsTopLevel = (hierarchyFacts & 64) !== 0
                || (isCapturedInFunction
                    && isDeclaredInLoop
                    && (hierarchyFacts & 512) !== 0);
            var emitExplicitInitializer = !emittedAsTopLevel
                && (hierarchyFacts & 4096) === 0
                && (!resolver.isDeclarationWithCollidingName(node)
                    || (isDeclaredInLoop
                        && !isCapturedInFunction
                        && (hierarchyFacts & (2048 | 4096)) === 0));
            return emitExplicitInitializer;
        }
        function visitVariableDeclarationInLetDeclarationList(node) {
            var name = node.name;
            if (ts.isBindingPattern(name)) {
                return visitVariableDeclaration(node);
            }
            if (!node.initializer && shouldEmitExplicitInitializerForLetDeclaration(node)) {
                return factory.updateVariableDeclaration(node, node.name, undefined, undefined, factory.createVoidZero());
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitVariableDeclaration(node) {
            var ancestorFacts = enterSubtree(32, 0);
            var updated;
            if (ts.isBindingPattern(node.name)) {
                updated = ts.flattenDestructuringBinding(node, visitor, context, 0, undefined, (ancestorFacts & 32) !== 0);
            }
            else {
                updated = ts.visitEachChild(node, visitor, context);
            }
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function recordLabel(node) {
            convertedLoopState.labels.set(ts.idText(node.label), true);
        }
        function resetLabel(node) {
            convertedLoopState.labels.set(ts.idText(node.label), false);
        }
        function visitLabeledStatement(node) {
            if (convertedLoopState && !convertedLoopState.labels) {
                convertedLoopState.labels = new ts.Map();
            }
            var statement = ts.unwrapInnermostStatementOfLabel(node, convertedLoopState && recordLabel);
            return ts.isIterationStatement(statement, false)
                ? visitIterationStatement(statement, node)
                : factory.restoreEnclosingLabel(ts.visitNode(statement, visitor, ts.isStatement, factory.liftToBlock), node, convertedLoopState && resetLabel);
        }
        function visitIterationStatement(node, outermostLabeledStatement) {
            switch (node.kind) {
                case 243:
                case 244:
                    return visitDoOrWhileStatement(node, outermostLabeledStatement);
                case 245:
                    return visitForStatement(node, outermostLabeledStatement);
                case 246:
                    return visitForInStatement(node, outermostLabeledStatement);
                case 247:
                    return visitForOfStatement(node, outermostLabeledStatement);
            }
        }
        function visitIterationStatementWithFacts(excludeFacts, includeFacts, node, outermostLabeledStatement, convert) {
            var ancestorFacts = enterSubtree(excludeFacts, includeFacts);
            var updated = convertIterationStatementBodyIfNecessary(node, outermostLabeledStatement, ancestorFacts, convert);
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function visitDoOrWhileStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(0, 1280, node, outermostLabeledStatement);
        }
        function visitForStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(5056, 3328, node, outermostLabeledStatement);
        }
        function visitEachChildOfForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, visitorWithUnusedExpressionResult, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitorWithUnusedExpressionResult, ts.isExpression), ts.visitNode(node.statement, visitor, ts.isStatement, factory.liftToBlock));
        }
        function visitForInStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(3008, 5376, node, outermostLabeledStatement);
        }
        function visitForOfStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(3008, 5376, node, outermostLabeledStatement, compilerOptions.downlevelIteration ? convertForOfStatementForIterable : convertForOfStatementForArray);
        }
        function convertForOfStatementHead(node, boundValue, convertedLoopBodyStatements) {
            var statements = [];
            var initializer = node.initializer;
            if (ts.isVariableDeclarationList(initializer)) {
                if (node.initializer.flags & 3) {
                    enableSubstitutionsForBlockScopedBindings();
                }
                var firstOriginalDeclaration = ts.firstOrUndefined(initializer.declarations);
                if (firstOriginalDeclaration && ts.isBindingPattern(firstOriginalDeclaration.name)) {
                    var declarations = ts.flattenDestructuringBinding(firstOriginalDeclaration, visitor, context, 0, boundValue);
                    var declarationList = ts.setTextRange(factory.createVariableDeclarationList(declarations), node.initializer);
                    ts.setOriginalNode(declarationList, node.initializer);
                    ts.setSourceMapRange(declarationList, ts.createRange(declarations[0].pos, ts.last(declarations).end));
                    statements.push(factory.createVariableStatement(undefined, declarationList));
                }
                else {
                    statements.push(ts.setTextRange(factory.createVariableStatement(undefined, ts.setOriginalNode(ts.setTextRange(factory.createVariableDeclarationList([
                        factory.createVariableDeclaration(firstOriginalDeclaration ? firstOriginalDeclaration.name : factory.createTempVariable(undefined), undefined, undefined, boundValue)
                    ]), ts.moveRangePos(initializer, -1)), initializer)), ts.moveRangeEnd(initializer, -1)));
                }
            }
            else {
                var assignment = factory.createAssignment(initializer, boundValue);
                if (ts.isDestructuringAssignment(assignment)) {
                    statements.push(factory.createExpressionStatement(visitBinaryExpression(assignment, true)));
                }
                else {
                    ts.setTextRangeEnd(assignment, initializer.end);
                    statements.push(ts.setTextRange(factory.createExpressionStatement(ts.visitNode(assignment, visitor, ts.isExpression)), ts.moveRangeEnd(initializer, -1)));
                }
            }
            if (convertedLoopBodyStatements) {
                return createSyntheticBlockForConvertedStatements(ts.addRange(statements, convertedLoopBodyStatements));
            }
            else {
                var statement = ts.visitNode(node.statement, visitor, ts.isStatement, factory.liftToBlock);
                if (ts.isBlock(statement)) {
                    return factory.updateBlock(statement, ts.setTextRange(factory.createNodeArray(ts.concatenate(statements, statement.statements)), statement.statements));
                }
                else {
                    statements.push(statement);
                    return createSyntheticBlockForConvertedStatements(statements);
                }
            }
        }
        function createSyntheticBlockForConvertedStatements(statements) {
            return ts.setEmitFlags(factory.createBlock(factory.createNodeArray(statements), true), 48 | 384);
        }
        function convertForOfStatementForArray(node, outermostLabeledStatement, convertedLoopBodyStatements) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var counter = factory.createLoopVariable();
            var rhsReference = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(expression) : factory.createTempVariable(undefined);
            ts.setEmitFlags(expression, 48 | ts.getEmitFlags(expression));
            var forStatement = ts.setTextRange(factory.createForStatement(ts.setEmitFlags(ts.setTextRange(factory.createVariableDeclarationList([
                ts.setTextRange(factory.createVariableDeclaration(counter, undefined, undefined, factory.createNumericLiteral(0)), ts.moveRangePos(node.expression, -1)),
                ts.setTextRange(factory.createVariableDeclaration(rhsReference, undefined, undefined, expression), node.expression)
            ]), node.expression), 2097152), ts.setTextRange(factory.createLessThan(counter, factory.createPropertyAccessExpression(rhsReference, "length")), node.expression), ts.setTextRange(factory.createPostfixIncrement(counter), node.expression), convertForOfStatementHead(node, factory.createElementAccessExpression(rhsReference, counter), convertedLoopBodyStatements)), node);
            ts.setEmitFlags(forStatement, 256);
            ts.setTextRange(forStatement, node);
            return factory.restoreEnclosingLabel(forStatement, outermostLabeledStatement, convertedLoopState && resetLabel);
        }
        function convertForOfStatementForIterable(node, outermostLabeledStatement, convertedLoopBodyStatements, ancestorFacts) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var iterator = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(expression) : factory.createTempVariable(undefined);
            var result = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(iterator) : factory.createTempVariable(undefined);
            var errorRecord = factory.createUniqueName("e");
            var catchVariable = factory.getGeneratedNameForNode(errorRecord);
            var returnMethod = factory.createTempVariable(undefined);
            var values = ts.setTextRange(emitHelpers().createValuesHelper(expression), node.expression);
            var next = factory.createCallExpression(factory.createPropertyAccessExpression(iterator, "next"), undefined, []);
            hoistVariableDeclaration(errorRecord);
            hoistVariableDeclaration(returnMethod);
            var initializer = ancestorFacts & 1024
                ? factory.inlineExpressions([factory.createAssignment(errorRecord, factory.createVoidZero()), values])
                : values;
            var forStatement = ts.setEmitFlags(ts.setTextRange(factory.createForStatement(ts.setEmitFlags(ts.setTextRange(factory.createVariableDeclarationList([
                ts.setTextRange(factory.createVariableDeclaration(iterator, undefined, undefined, initializer), node.expression),
                factory.createVariableDeclaration(result, undefined, undefined, next)
            ]), node.expression), 2097152), factory.createLogicalNot(factory.createPropertyAccessExpression(result, "done")), factory.createAssignment(result, next), convertForOfStatementHead(node, factory.createPropertyAccessExpression(result, "value"), convertedLoopBodyStatements)), node), 256);
            return factory.createTryStatement(factory.createBlock([
                factory.restoreEnclosingLabel(forStatement, outermostLabeledStatement, convertedLoopState && resetLabel)
            ]), factory.createCatchClause(factory.createVariableDeclaration(catchVariable), ts.setEmitFlags(factory.createBlock([
                factory.createExpressionStatement(factory.createAssignment(errorRecord, factory.createObjectLiteralExpression([
                    factory.createPropertyAssignment("error", catchVariable)
                ])))
            ]), 1)), factory.createBlock([
                factory.createTryStatement(factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(factory.createLogicalAnd(factory.createLogicalAnd(result, factory.createLogicalNot(factory.createPropertyAccessExpression(result, "done"))), factory.createAssignment(returnMethod, factory.createPropertyAccessExpression(iterator, "return"))), factory.createExpressionStatement(factory.createFunctionCallCall(returnMethod, iterator, []))), 1),
                ]), undefined, ts.setEmitFlags(factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(errorRecord, factory.createThrowStatement(factory.createPropertyAccessExpression(errorRecord, "error"))), 1)
                ]), 1))
            ]));
        }
        function visitObjectLiteralExpression(node) {
            var properties = node.properties;
            var numInitialProperties = -1, hasComputed = false;
            for (var i = 0; i < properties.length; i++) {
                var property = properties[i];
                if ((property.transformFlags & 1048576 &&
                    hierarchyFacts & 4)
                    || (hasComputed = ts.Debug.checkDefined(property.name).kind === 164)) {
                    numInitialProperties = i;
                    break;
                }
            }
            if (numInitialProperties < 0) {
                return ts.visitEachChild(node, visitor, context);
            }
            var temp = factory.createTempVariable(hoistVariableDeclaration);
            var expressions = [];
            var assignment = factory.createAssignment(temp, ts.setEmitFlags(factory.createObjectLiteralExpression(ts.visitNodes(properties, visitor, ts.isObjectLiteralElementLike, 0, numInitialProperties), node.multiLine), hasComputed ? 65536 : 0));
            if (node.multiLine) {
                ts.startOnNewLine(assignment);
            }
            expressions.push(assignment);
            addObjectLiteralMembers(expressions, node, temp, numInitialProperties);
            expressions.push(node.multiLine ? ts.startOnNewLine(ts.setParent(ts.setTextRange(factory.cloneNode(temp), temp), temp.parent)) : temp);
            return factory.inlineExpressions(expressions);
        }
        function shouldConvertPartOfIterationStatement(node) {
            return (resolver.getNodeCheckFlags(node) & 131072) !== 0;
        }
        function shouldConvertInitializerOfForStatement(node) {
            return ts.isForStatement(node) && !!node.initializer && shouldConvertPartOfIterationStatement(node.initializer);
        }
        function shouldConvertConditionOfForStatement(node) {
            return ts.isForStatement(node) && !!node.condition && shouldConvertPartOfIterationStatement(node.condition);
        }
        function shouldConvertIncrementorOfForStatement(node) {
            return ts.isForStatement(node) && !!node.incrementor && shouldConvertPartOfIterationStatement(node.incrementor);
        }
        function shouldConvertIterationStatement(node) {
            return shouldConvertBodyOfIterationStatement(node)
                || shouldConvertInitializerOfForStatement(node);
        }
        function shouldConvertBodyOfIterationStatement(node) {
            return (resolver.getNodeCheckFlags(node) & 65536) !== 0;
        }
        function hoistVariableDeclarationDeclaredInConvertedLoop(state, node) {
            if (!state.hoistedLocalVariables) {
                state.hoistedLocalVariables = [];
            }
            visit(node.name);
            function visit(node) {
                if (node.kind === 79) {
                    state.hoistedLocalVariables.push(node);
                }
                else {
                    for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                        var element = _a[_i];
                        if (!ts.isOmittedExpression(element)) {
                            visit(element.name);
                        }
                    }
                }
            }
        }
        function convertIterationStatementBodyIfNecessary(node, outermostLabeledStatement, ancestorFacts, convert) {
            if (!shouldConvertIterationStatement(node)) {
                var saveAllowedNonLabeledJumps = void 0;
                if (convertedLoopState) {
                    saveAllowedNonLabeledJumps = convertedLoopState.allowedNonLabeledJumps;
                    convertedLoopState.allowedNonLabeledJumps = 2 | 4;
                }
                var result = convert
                    ? convert(node, outermostLabeledStatement, undefined, ancestorFacts)
                    : factory.restoreEnclosingLabel(ts.isForStatement(node) ? visitEachChildOfForStatement(node) : ts.visitEachChild(node, visitor, context), outermostLabeledStatement, convertedLoopState && resetLabel);
                if (convertedLoopState) {
                    convertedLoopState.allowedNonLabeledJumps = saveAllowedNonLabeledJumps;
                }
                return result;
            }
            var currentState = createConvertedLoopState(node);
            var statements = [];
            var outerConvertedLoopState = convertedLoopState;
            convertedLoopState = currentState;
            var initializerFunction = shouldConvertInitializerOfForStatement(node) ? createFunctionForInitializerOfForStatement(node, currentState) : undefined;
            var bodyFunction = shouldConvertBodyOfIterationStatement(node) ? createFunctionForBodyOfIterationStatement(node, currentState, outerConvertedLoopState) : undefined;
            convertedLoopState = outerConvertedLoopState;
            if (initializerFunction)
                statements.push(initializerFunction.functionDeclaration);
            if (bodyFunction)
                statements.push(bodyFunction.functionDeclaration);
            addExtraDeclarationsForConvertedLoop(statements, currentState, outerConvertedLoopState);
            if (initializerFunction) {
                statements.push(generateCallToConvertedLoopInitializer(initializerFunction.functionName, initializerFunction.containsYield));
            }
            var loop;
            if (bodyFunction) {
                if (convert) {
                    loop = convert(node, outermostLabeledStatement, bodyFunction.part, ancestorFacts);
                }
                else {
                    var clone_4 = convertIterationStatementCore(node, initializerFunction, factory.createBlock(bodyFunction.part, true));
                    loop = factory.restoreEnclosingLabel(clone_4, outermostLabeledStatement, convertedLoopState && resetLabel);
                }
            }
            else {
                var clone_5 = convertIterationStatementCore(node, initializerFunction, ts.visitNode(node.statement, visitor, ts.isStatement, factory.liftToBlock));
                loop = factory.restoreEnclosingLabel(clone_5, outermostLabeledStatement, convertedLoopState && resetLabel);
            }
            statements.push(loop);
            return statements;
        }
        function convertIterationStatementCore(node, initializerFunction, convertedLoopBody) {
            switch (node.kind) {
                case 245: return convertForStatement(node, initializerFunction, convertedLoopBody);
                case 246: return convertForInStatement(node, convertedLoopBody);
                case 247: return convertForOfStatement(node, convertedLoopBody);
                case 243: return convertDoStatement(node, convertedLoopBody);
                case 244: return convertWhileStatement(node, convertedLoopBody);
                default: return ts.Debug.failBadSyntaxKind(node, "IterationStatement expected");
            }
        }
        function convertForStatement(node, initializerFunction, convertedLoopBody) {
            var shouldConvertCondition = node.condition && shouldConvertPartOfIterationStatement(node.condition);
            var shouldConvertIncrementor = shouldConvertCondition || node.incrementor && shouldConvertPartOfIterationStatement(node.incrementor);
            return factory.updateForStatement(node, ts.visitNode(initializerFunction ? initializerFunction.part : node.initializer, visitorWithUnusedExpressionResult, ts.isForInitializer), ts.visitNode(shouldConvertCondition ? undefined : node.condition, visitor, ts.isExpression), ts.visitNode(shouldConvertIncrementor ? undefined : node.incrementor, visitorWithUnusedExpressionResult, ts.isExpression), convertedLoopBody);
        }
        function convertForOfStatement(node, convertedLoopBody) {
            return factory.updateForOfStatement(node, undefined, ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), convertedLoopBody);
        }
        function convertForInStatement(node, convertedLoopBody) {
            return factory.updateForInStatement(node, ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), convertedLoopBody);
        }
        function convertDoStatement(node, convertedLoopBody) {
            return factory.updateDoStatement(node, convertedLoopBody, ts.visitNode(node.expression, visitor, ts.isExpression));
        }
        function convertWhileStatement(node, convertedLoopBody) {
            return factory.updateWhileStatement(node, ts.visitNode(node.expression, visitor, ts.isExpression), convertedLoopBody);
        }
        function createConvertedLoopState(node) {
            var loopInitializer;
            switch (node.kind) {
                case 245:
                case 246:
                case 247:
                    var initializer = node.initializer;
                    if (initializer && initializer.kind === 258) {
                        loopInitializer = initializer;
                    }
                    break;
            }
            var loopParameters = [];
            var loopOutParameters = [];
            if (loopInitializer && (ts.getCombinedNodeFlags(loopInitializer) & 3)) {
                var hasCapturedBindingsInForHead = shouldConvertInitializerOfForStatement(node) ||
                    shouldConvertConditionOfForStatement(node) ||
                    shouldConvertIncrementorOfForStatement(node);
                for (var _i = 0, _a = loopInitializer.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    processLoopVariableDeclaration(node, decl, loopParameters, loopOutParameters, hasCapturedBindingsInForHead);
                }
            }
            var currentState = { loopParameters: loopParameters, loopOutParameters: loopOutParameters };
            if (convertedLoopState) {
                if (convertedLoopState.argumentsName) {
                    currentState.argumentsName = convertedLoopState.argumentsName;
                }
                if (convertedLoopState.thisName) {
                    currentState.thisName = convertedLoopState.thisName;
                }
                if (convertedLoopState.hoistedLocalVariables) {
                    currentState.hoistedLocalVariables = convertedLoopState.hoistedLocalVariables;
                }
            }
            return currentState;
        }
        function addExtraDeclarationsForConvertedLoop(statements, state, outerState) {
            var extraVariableDeclarations;
            if (state.argumentsName) {
                if (outerState) {
                    outerState.argumentsName = state.argumentsName;
                }
                else {
                    (extraVariableDeclarations || (extraVariableDeclarations = [])).push(factory.createVariableDeclaration(state.argumentsName, undefined, undefined, factory.createIdentifier("arguments")));
                }
            }
            if (state.thisName) {
                if (outerState) {
                    outerState.thisName = state.thisName;
                }
                else {
                    (extraVariableDeclarations || (extraVariableDeclarations = [])).push(factory.createVariableDeclaration(state.thisName, undefined, undefined, factory.createIdentifier("this")));
                }
            }
            if (state.hoistedLocalVariables) {
                if (outerState) {
                    outerState.hoistedLocalVariables = state.hoistedLocalVariables;
                }
                else {
                    if (!extraVariableDeclarations) {
                        extraVariableDeclarations = [];
                    }
                    for (var _i = 0, _a = state.hoistedLocalVariables; _i < _a.length; _i++) {
                        var identifier = _a[_i];
                        extraVariableDeclarations.push(factory.createVariableDeclaration(identifier));
                    }
                }
            }
            if (state.loopOutParameters.length) {
                if (!extraVariableDeclarations) {
                    extraVariableDeclarations = [];
                }
                for (var _b = 0, _c = state.loopOutParameters; _b < _c.length; _b++) {
                    var outParam = _c[_b];
                    extraVariableDeclarations.push(factory.createVariableDeclaration(outParam.outParamName));
                }
            }
            if (state.conditionVariable) {
                if (!extraVariableDeclarations) {
                    extraVariableDeclarations = [];
                }
                extraVariableDeclarations.push(factory.createVariableDeclaration(state.conditionVariable, undefined, undefined, factory.createFalse()));
            }
            if (extraVariableDeclarations) {
                statements.push(factory.createVariableStatement(undefined, factory.createVariableDeclarationList(extraVariableDeclarations)));
            }
        }
        function createOutVariable(p) {
            return factory.createVariableDeclaration(p.originalName, undefined, undefined, p.outParamName);
        }
        function createFunctionForInitializerOfForStatement(node, currentState) {
            var functionName = factory.createUniqueName("_loop_init");
            var containsYield = (node.initializer.transformFlags & 1048576) !== 0;
            var emitFlags = 0;
            if (currentState.containsLexicalThis)
                emitFlags |= 8;
            if (containsYield && hierarchyFacts & 4)
                emitFlags |= 262144;
            var statements = [];
            statements.push(factory.createVariableStatement(undefined, node.initializer));
            copyOutParameters(currentState.loopOutParameters, 2, 1, statements);
            var functionDeclaration = factory.createVariableStatement(undefined, ts.setEmitFlags(factory.createVariableDeclarationList([
                factory.createVariableDeclaration(functionName, undefined, undefined, ts.setEmitFlags(factory.createFunctionExpression(undefined, containsYield ? factory.createToken(41) : undefined, undefined, undefined, undefined, undefined, ts.visitNode(factory.createBlock(statements, true), visitor, ts.isBlock)), emitFlags))
            ]), 2097152));
            var part = factory.createVariableDeclarationList(ts.map(currentState.loopOutParameters, createOutVariable));
            return { functionName: functionName, containsYield: containsYield, functionDeclaration: functionDeclaration, part: part };
        }
        function createFunctionForBodyOfIterationStatement(node, currentState, outerState) {
            var functionName = factory.createUniqueName("_loop");
            startLexicalEnvironment();
            var statement = ts.visitNode(node.statement, visitor, ts.isStatement, factory.liftToBlock);
            var lexicalEnvironment = endLexicalEnvironment();
            var statements = [];
            if (shouldConvertConditionOfForStatement(node) || shouldConvertIncrementorOfForStatement(node)) {
                currentState.conditionVariable = factory.createUniqueName("inc");
                if (node.incrementor) {
                    statements.push(factory.createIfStatement(currentState.conditionVariable, factory.createExpressionStatement(ts.visitNode(node.incrementor, visitor, ts.isExpression)), factory.createExpressionStatement(factory.createAssignment(currentState.conditionVariable, factory.createTrue()))));
                }
                else {
                    statements.push(factory.createIfStatement(factory.createLogicalNot(currentState.conditionVariable), factory.createExpressionStatement(factory.createAssignment(currentState.conditionVariable, factory.createTrue()))));
                }
                if (shouldConvertConditionOfForStatement(node)) {
                    statements.push(factory.createIfStatement(factory.createPrefixUnaryExpression(53, ts.visitNode(node.condition, visitor, ts.isExpression)), ts.visitNode(factory.createBreakStatement(), visitor, ts.isStatement)));
                }
            }
            if (ts.isBlock(statement)) {
                ts.addRange(statements, statement.statements);
            }
            else {
                statements.push(statement);
            }
            copyOutParameters(currentState.loopOutParameters, 1, 1, statements);
            ts.insertStatementsAfterStandardPrologue(statements, lexicalEnvironment);
            var loopBody = factory.createBlock(statements, true);
            if (ts.isBlock(statement))
                ts.setOriginalNode(loopBody, statement);
            var containsYield = (node.statement.transformFlags & 1048576) !== 0;
            var emitFlags = 524288;
            if (currentState.containsLexicalThis)
                emitFlags |= 8;
            if (containsYield && (hierarchyFacts & 4) !== 0)
                emitFlags |= 262144;
            var functionDeclaration = factory.createVariableStatement(undefined, ts.setEmitFlags(factory.createVariableDeclarationList([
                factory.createVariableDeclaration(functionName, undefined, undefined, ts.setEmitFlags(factory.createFunctionExpression(undefined, containsYield ? factory.createToken(41) : undefined, undefined, undefined, currentState.loopParameters, undefined, loopBody), emitFlags))
            ]), 2097152));
            var part = generateCallToConvertedLoop(functionName, currentState, outerState, containsYield);
            return { functionName: functionName, containsYield: containsYield, functionDeclaration: functionDeclaration, part: part };
        }
        function copyOutParameter(outParam, copyDirection) {
            var source = copyDirection === 0 ? outParam.outParamName : outParam.originalName;
            var target = copyDirection === 0 ? outParam.originalName : outParam.outParamName;
            return factory.createBinaryExpression(target, 63, source);
        }
        function copyOutParameters(outParams, partFlags, copyDirection, statements) {
            for (var _i = 0, outParams_1 = outParams; _i < outParams_1.length; _i++) {
                var outParam = outParams_1[_i];
                if (outParam.flags & partFlags) {
                    statements.push(factory.createExpressionStatement(copyOutParameter(outParam, copyDirection)));
                }
            }
        }
        function generateCallToConvertedLoopInitializer(initFunctionExpressionName, containsYield) {
            var call = factory